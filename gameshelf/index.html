<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XRL2SVN0YF"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-XRL2SVN0YF');
    </script>
    

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
    <meta name="version" content="1.3.4">
    <meta name="gs-app-id" content="gameshelf">
    <meta name="theme-color" content="#667eea">
    <meta name="description" content="Track your daily puzzle games, build streaks, compete with friends!">
    
    <!-- PWA Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- Dynamic Manifest & Icons based on repo detection -->
    <script>
        // Detect if running from test repo
        const isTestBuild = window.location.pathname.toLowerCase().includes('gameshelftest');
        
        // Set theme color based on build
        const themeColor = isTestBuild ? '#ff9900' : '#667eea';
        document.querySelector('meta[name="theme-color"]')?.setAttribute('content', themeColor);
        
        // Set apple-mobile-web-app-title
        const appTitle = isTestBuild ? 'GS Test' : 'Game Shelf';
        const metaTitle = document.createElement('meta');
        metaTitle.name = 'apple-mobile-web-app-title';
        metaTitle.content = appTitle;
        document.head.appendChild(metaTitle);
        
        // Set manifest link
        const manifestLink = document.createElement('link');
        manifestLink.rel = 'manifest';
        manifestLink.href = isTestBuild ? 'manifest-test.json' : 'manifest.json';
        document.head.appendChild(manifestLink);
        
        // Set icons
        const iconFolder = isTestBuild ? 'icons-test' : 'icons';
        
        const appleIcon = document.createElement('link');
        appleIcon.rel = 'apple-touch-icon';
        appleIcon.href = iconFolder + '/apple-touch-icon.png';
        document.head.appendChild(appleIcon);
        
        const favicon = document.createElement('link');
        favicon.rel = 'icon';
        favicon.type = 'image/png';
        favicon.sizes = '192x192';
        favicon.href = iconFolder + '/icon-192.png';
        document.head.appendChild(favicon);
        
        // Log which build is running
        console.log(isTestBuild ? 'ðŸ§ª TEST BUILD detected' : 'ðŸš€ PRODUCTION BUILD');
    </script>
    
    <title>Game Shelf PWA</title>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-functions-compat.js"></script>
    
    <!-- Tesseract.js for OCR -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a25;
            --bg-hover: #22222f;
            --text-primary: #ffffff;
            --text-secondary: #a0a0b0;
            --text-muted: #606070;
            --border: #2a2a3a;
            --accent-purple: #667eea;
            --accent-green: #48bb78;
            --accent-red: #f56565;
            --accent-orange: #ed8936;
            --accent-gold: #ffd700;
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
        }
        
        body.light-mode {
            --bg-primary: #f5f5f7;
            --bg-secondary: #ffffff;
            --bg-tertiary: #e8e8ed;
            --bg-hover: #d8d8e0;
            --text-primary: #1a1a1f;
            --text-secondary: #505060;
            --text-muted: #909098;
            --border: #d0d0d8;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        
        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: calc(var(--safe-top) + 12px) 16px 12px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }
        
        .logo {
            font-size: 1.1rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .header-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 1px solid var(--border);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 1.1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.2s;
        }
        
        .header-btn:active {
            transform: scale(0.95);
            background: var(--bg-primary);
        }
        
        .header-btn.has-badge::after {
            content: attr(data-badge);
            position: absolute;
            top: -4px;
            right: -4px;
            background: var(--accent-green);
            color: white;
            font-size: 0.6rem;
            font-weight: 700;
            min-width: 16px;
            height: 16px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 3px;
        }
        
        .header-btn.hint-btn.has-badge::after {
            background: var(--accent-orange);
            content: "!";
        }
        
        .wallet-display {
            display: none; /* Moved to menu */
        }
        
        .tokens { color: var(--accent-purple); }
        .coins { color: var(--accent-gold); }
        
        /* Quick Action Bar - DISABLED, reverted to FABs */
        .action-bar {
            display: none !important;
        }
        
        .action-bar-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .action-bar-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .action-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            border-radius: 20px;
            border: 1px solid var(--border);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .action-btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent-purple);
        }
        
        .action-btn:active {
            transform: scale(0.97);
        }
        
        .action-btn.highlight {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(102, 126, 234, 0.2));
            border-color: var(--accent-purple);
            color: var(--accent-purple);
        }
        
        .action-btn.highlight.pulse {
            animation: action-btn-pulse 2s ease-in-out infinite;
        }
        
        @keyframes action-btn-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.4); }
            50% { box-shadow: 0 0 0 6px rgba(139, 92, 246, 0); }
        }
        
        .action-btn-badge {
            position: absolute;
            top: -6px;
            right: -6px;
            background: var(--accent-green);
            color: white;
            font-size: 0.65rem;
            font-weight: 700;
            min-width: 18px;
            height: 18px;
            border-radius: 9px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 4px;
        }
        
        .action-btn-badge.hint {
            background: var(--accent-orange);
        }
        
        .wallet-inline {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 0.8rem;
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border-radius: 16px;
            border: 1px solid var(--border);
        }
        
        .menu-btn {
            background: none;
            border: none;
            font-size: 1.4rem;
            cursor: pointer;
            padding: 4px 8px;
            touch-action: manipulation;
            color: var(--text-primary);
        }
        
        /* Slide-out Settings Menu */
        .settings-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            z-index: 900; /* Increased from 400 */
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        
        .settings-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .settings-menu {
            position: fixed;
            top: 0;
            left: -300px; /* Use left instead of transform */
            width: 85%;
            max-width: 300px;
            height: 100%;
            background: #12121a;
            color: #e0e0e0;
            z-index: 1000;
            transition: left 0.3s ease;
            display: flex;
            flex-direction: column;
            box-shadow: 4px 0 20px rgba(0,0,0,0.3);
        }
        
        .light-mode .settings-menu {
            background: #ffffff;
            color: #1a1a2e;
        }
        
        .settings-menu.active {
            left: 0;
        }
        
        .settings-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px 16px;
            border-bottom: 1px solid var(--border, #333);
            color: inherit;
        }
        
        .settings-header h2 {
            font-size: 1.2rem;
            margin: 0;
            color: inherit;
        }
        
        .settings-close {
            background: var(--bg-tertiary);
            border: none;
            color: var(--text-secondary);
            width: 32px;
            height: 32px;
            border-radius: 50%;
            font-size: 1rem;
            cursor: pointer;
            touch-action: manipulation;
        }
        
        .settings-body {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 16px;
            background: inherit;
            color: inherit;
        }
        
        .settings-section {
            margin-bottom: 24px;
        }
        
        .settings-section-title {
            font-size: 0.7rem;
            font-weight: 700;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }
        
        .settings-link {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 0;
            color: var(--text-primary, #e0e0e0);
            text-decoration: none;
            font-size: 0.95rem;
            cursor: pointer;
            touch-action: manipulation;
        }
        
        .settings-link:active {
            opacity: 0.7;
        }
        
        .settings-link .icon {
            font-size: 1.1rem;
        }
        
        .settings-desc {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin: -8px 0 8px 32px;
        }
        
        .theme-options {
            display: flex;
            gap: 10px;
        }
        
        .theme-option {
            flex: 1;
            padding: 12px;
            border-radius: 10px;
            border: 2px solid var(--border);
            text-align: center;
            cursor: pointer;
            touch-action: manipulation;
            transition: border-color 0.2s;
        }
        
        .theme-option.active {
            border-color: var(--accent-purple);
        }
        
        .theme-option .label {
            font-size: 0.85rem;
            margin-top: 4px;
        }
        
        .settings-toggle-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 0;
        }
        
        .settings-toggle-row label {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }
        
        .settings-toggle-row input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }
        
        .settings-footer {
            padding: 16px;
            border-top: 1px solid var(--border);
            text-align: center;
        }
        
        .settings-version {
            font-size: 0.8rem;
            color: var(--text-muted);
        }
        
        /* Settings Submenu Expandable */
        .settings-submenu-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 16px;
            background: var(--bg-secondary);
            border-radius: 12px;
            cursor: pointer;
            margin-top: 8px;
        }
        
        .settings-submenu-toggle:active {
            opacity: 0.7;
        }
        
        .settings-submenu-toggle .toggle-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .settings-submenu-toggle .toggle-icon {
            font-size: 1.2rem;
        }
        
        .settings-submenu-toggle .toggle-label {
            font-weight: 600;
        }
        
        .settings-submenu-toggle .toggle-arrow {
            transition: transform 0.2s ease;
            color: var(--text-muted);
        }
        
        .settings-submenu-toggle.expanded .toggle-arrow {
            transform: rotate(180deg);
        }
        
        .settings-submenu-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            background: var(--bg-tertiary);
            border-radius: 0 0 12px 12px;
            margin-top: -8px;
            padding-top: 8px;
        }
        
        .settings-submenu-content.expanded {
            max-height: 1500px;
        }
        
        .settings-submenu-content .settings-section {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
        }
        
        .settings-submenu-content .settings-section:last-child {
            border-bottom: none;
        }
        
        .settings-submenu-content .settings-section-title {
            font-size: 0.75rem;
            margin-bottom: 8px;
        }
        
        /* Sound Customizer Modal */
        .sound-event-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 10px;
            margin-bottom: 8px;
        }
        
        .sound-event-info {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
            min-width: 0;
        }
        
        .sound-event-icon {
            font-size: 1.3rem;
            width: 32px;
            text-align: center;
            flex-shrink: 0;
        }
        
        .sound-event-name {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.9rem;
        }
        
        .sound-event-desc {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 2px;
        }
        
        .sound-event-selector {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-shrink: 0;
        }
        
        .sound-event-selector select {
            padding: 6px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.8rem;
            cursor: pointer;
            min-width: 110px;
        }
        
        .sound-event-selector select:focus {
            outline: none;
            border-color: var(--accent-purple);
        }
        
        .preview-btn {
            padding: 6px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
        }
        
        .preview-btn:active {
            background: var(--accent-purple);
            border-color: var(--accent-purple);
        }
        
        .volume-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 0;
        }
        
        .volume-row input[type="range"] {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: var(--bg-tertiary);
            border-radius: 3px;
        }
        
        .volume-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent-purple);
            cursor: pointer;
        }
        
        @media (max-width: 400px) {
            .sound-event-row {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            .sound-event-selector {
                width: 100%;
            }
            
            .sound-event-selector select {
                flex: 1;
            }
        }
        
        .avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
        }
        
        .avatar.signed-out {
            background: var(--bg-tertiary);
            border: 2px dashed var(--border);
        }
        
        /* Main Content Area */
        .main-content {
            flex: 1 1 0;
            min-height: 0;
            overflow-y: auto;
            overflow-x: hidden;
            padding-bottom: calc(70px + var(--safe-bottom));
            -webkit-overflow-scrolling: touch;
        }
        
        /* Screens */
        .screen {
            display: none;
            padding: 0 0 20px;
            overflow-x: hidden;
        }
        
        .screen.active {
            display: block;
        }
        
        /* Primary Action Card */
        .primary-action {
            margin: 16px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.15), rgba(118, 75, 162, 0.15));
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 20px;
            padding: 20px;
        }
        
        .big-log-button {
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 16px;
            color: white;
            font-size: 1.05rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
            transition: transform 0.15s, box-shadow 0.15s;
        }
        
        .big-log-button:active {
            transform: scale(0.97);
            box-shadow: 0 2px 10px rgba(102, 126, 234, 0.3);
        }
        
        .quick-games {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .quick-game-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: 2px solid var(--border);
            background: var(--bg-secondary);
            font-size: 1.2rem;
            cursor: pointer;
            transition: transform 0.15s, border-color 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .quick-game-btn:active {
            transform: scale(0.9);
        }
        
        .quick-game-btn.done {
            border-color: var(--accent-green);
            background: rgba(72, 187, 120, 0.15);
        }
        
        /* Progress Section */
        .progress-section {
            margin: 0 16px 12px;
            padding: 14px 16px;
            background: var(--bg-secondary);
            border-radius: 14px;
            border: 1px solid var(--border);
        }
        
        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }
        
        .progress-bar-container {
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 4px;
            transition: width 0.5s ease;
        }
        
        .progress-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .streak-badge {
            color: var(--accent-orange);
            font-weight: 600;
        }
        
        .share-today-btn {
            width: 100%;
            margin-top: 12px;
            padding: 10px 16px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .share-today-btn:active {
            opacity: 0.9;
            transform: scale(0.98);
        }
        
        /* Floating Action Button for Share - MOVED TO HEADER */
        .share-fab {
            display: none !important; /* Moved to header */
            position: fixed;
            bottom: 90px;
            right: 20px;
            width: 56px;
            height: 56px;
            border-radius: 28px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
            z-index: 100;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .share-fab.visible {
            display: none !important; /* Moved to header */
        }
        
        .share-fab:active {
            transform: scale(0.95);
        }
        
        .share-fab-badge {
            position: absolute;
            top: -4px;
            right: -4px;
            background: var(--accent-green);
            color: white;
            font-size: 0.7rem;
            font-weight: 700;
            min-width: 20px;
            height: 20px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 4px;
        }
        
        /* Weekly Recap Card */
        .weekly-recap-btn {
            width: 100%;
            margin-top: 8px;
            padding: 10px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .weekly-recap-btn:active {
            background: var(--bg-secondary);
        }
        
        /* Widget Cards */
        .widget {
            margin: 0 16px 12px;
            background: var(--bg-secondary);
            border-radius: 14px;
            padding: 16px;
            border: 1px solid var(--border);
        }
        
        .widget-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .widget-icon { font-size: 1.1rem; }
        
        .widget-title {
            font-weight: 700;
            font-size: 0.95rem;
            flex: 1;
        }
        
        .widget-badge {
            font-size: 0.7rem;
            background: var(--accent-orange);
            color: white;
            padding: 4px 10px;
            border-radius: 10px;
            font-weight: 600;
        }
        
        .widget-action {
            width: 100%;
            padding: 12px;
            background: var(--bg-tertiary);
            border: none;
            border-radius: 12px;
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
            margin-top: 12px;
            transition: background 0.15s;
        }
        
        .widget-action:active {
            background: var(--bg-hover);
        }
        
        /* Battle Widget */
        .battle-name {
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 8px;
        }
        
        .battle-standings {
            display: flex;
            gap: 20px;
            font-size: 0.9rem;
        }
        
        .standing {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .standing.winning { color: var(--accent-green); }
        
        /* Friends Widget */
        .friends-row {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            padding: 6px 0;
            -webkit-overflow-scrolling: touch;
        }
        
        .friend-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            min-width: 56px;
        }
        
        .friend-avatar {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: 2px solid var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            background: var(--bg-tertiary);
        }
        
        .friend-item.played .friend-avatar {
            border-color: var(--accent-green);
        }
        
        .friend-item.waiting .friend-avatar {
            opacity: 0.5;
        }
        
        .friend-status {
            font-size: 0.7rem;
            color: var(--text-muted);
        }
        
        .friend-item.played .friend-status {
            color: var(--accent-green);
        }
        
        /* v1.3.1: Show friend names in widget */
        .friend-name {
            font-size: 0.65rem;
            color: var(--text-secondary);
            max-width: 56px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            text-align: center;
        }
        
        /* Friends System - Full UI */
        .friends-section {
            padding: 16px;
        }
        
        .friends-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        
        .friends-count {
            background: var(--bg-tertiary);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8rem;
            color: var(--text-muted);
        }
        
        .friends-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .friend-card {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 12px;
            cursor: pointer;
            position: relative;
        }
        
        .friend-card:active {
            opacity: 0.7;
        }
        
        .friend-card-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-muted);
            flex-shrink: 0;
            position: relative;
        }
        
        .friend-card-avatar img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
        }
        
        /* Inactive indicator dot */
        .friend-inactive-dot {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--text-muted);
            border: 2px solid var(--bg-secondary);
        }
        
        .friend-active-dot {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent-green);
            border: 2px solid var(--bg-secondary);
        }
        
        .friend-card-info {
            flex: 1;
            min-width: 0;
        }
        
        .friend-card-name {
            font-weight: 600;
            font-size: 0.95rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .friend-card-status {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-top: 2px;
        }
        
        .friend-card-status.played {
            color: var(--accent-green);
        }
        
        .friend-card-status.inactive {
            color: var(--accent-orange);
        }
        
        .friend-card-streak {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.85rem;
            color: var(--accent-orange);
        }
        
        /* Nudge button on friend card */
        .friend-card-nudge {
            background: var(--accent-purple);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: transform 0.2s, opacity 0.2s;
            flex-shrink: 0;
        }
        
        .friend-card-nudge:active {
            transform: scale(0.95);
        }
        
        .friend-card-nudge.sent {
            background: var(--bg-tertiary);
            color: var(--text-muted);
        }
        
        .friend-card-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }
        
        .friend-card-challenge {
            background: none;
            border: none;
            color: var(--accent-purple);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 4px;
        }
        
        /* Nudge received banner */
        .nudge-banner {
            position: fixed;
            top: calc(var(--safe-top) + 75px);
            left: 16px;
            right: 16px;
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-purple-dark, #5a67d8));
            color: white;
            border-radius: 16px;
            padding: 16px;
            z-index: 200;
            transform: translateY(-150%);
            transition: transform 0.3s ease-out;
            box-shadow: 0 8px 32px rgba(102, 126, 234, 0.4);
        }
        
        .nudge-banner.visible {
            transform: translateY(0);
        }
        
        .nudge-banner-content {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .nudge-banner-icon {
            font-size: 2rem;
            animation: nudgeWiggle 0.5s ease-in-out 3;
        }
        
        @keyframes nudgeWiggle {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-10deg); }
            75% { transform: rotate(10deg); }
        }
        
        .nudge-banner-text {
            flex: 1;
        }
        
        .nudge-banner-title {
            font-weight: 700;
            font-size: 1rem;
            margin-bottom: 2px;
        }
        
        .nudge-banner-subtitle {
            font-size: 0.85rem;
            opacity: 0.9;
        }
        
        .nudge-banner-close {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            font-size: 1.1rem;
            cursor: pointer;
        }
        
        .nudge-banner-close:active {
            background: rgba(255,255,255,0.3);
        }
        
        /* ============ TAP TO LOG CARD ============ */
        .tap-to-log-card {
            position: fixed;
            top: calc(var(--safe-top) + 75px);
            left: 16px;
            right: 16px;
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
            border-radius: 16px;
            padding: 4px;
            z-index: 250;
            box-shadow: 0 8px 32px rgba(34, 197, 94, 0.5);
            animation: tapToLogPulse 2s ease-in-out infinite, tapToLogSlideIn 0.4s ease-out;
        }
        
        @keyframes tapToLogSlideIn {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes tapToLogPulse {
            0%, 100% { box-shadow: 0 8px 32px rgba(34, 197, 94, 0.5); }
            50% { box-shadow: 0 8px 48px rgba(34, 197, 94, 0.8); }
        }
        
        .tap-to-log-content {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 16px;
            cursor: pointer;
            border-radius: 14px;
            transition: background 0.2s;
        }
        
        .tap-to-log-content:active {
            background: rgba(255,255,255,0.15);
        }
        
        .tap-to-log-icon {
            font-size: 2.2rem;
            animation: tapToLogBounce 1s ease-in-out infinite;
        }
        
        @keyframes tapToLogBounce {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .tap-to-log-text {
            flex: 1;
        }
        
        .tap-to-log-title {
            font-weight: 700;
            font-size: 1.1rem;
            margin-bottom: 2px;
        }
        
        .tap-to-log-subtitle {
            font-size: 0.9rem;
            opacity: 0.9;
        }
        
        .tap-to-log-arrow {
            font-size: 1.5rem;
            font-weight: bold;
            animation: tapToLogArrow 1s ease-in-out infinite;
        }
        
        @keyframes tapToLogArrow {
            0%, 100% { transform: translateX(0); }
            50% { transform: translateX(5px); }
        }
        
        .tap-to-log-dismiss {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            font-size: 1rem;
            cursor: pointer;
        }
        
        /* ============ CELEBRATION OVERLAY ============ */
        .celebration-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .celebration-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .celebration-content {
            text-align: center;
            padding: 40px 24px;
            animation: celebrationZoom 0.4s ease-out;
        }
        
        @keyframes celebrationZoom {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        .celebration-emoji {
            font-size: 5rem;
            margin-bottom: 16px;
            animation: celebrationBounce 0.6s ease-out;
        }
        
        @keyframes celebrationBounce {
            0% { transform: scale(0) rotate(-10deg); }
            50% { transform: scale(1.3) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); }
        }
        
        .celebration-title {
            font-size: 2.5rem;
            font-weight: 900;
            color: #22c55e;
            letter-spacing: 2px;
            margin-bottom: 24px;
            text-shadow: 0 0 40px rgba(34, 197, 94, 0.5);
        }
        
        .celebration-game {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin-bottom: 8px;
        }
        
        .celebration-game-icon {
            font-size: 2.5rem;
        }
        
        .celebration-game-name {
            font-size: 1.8rem;
            font-weight: 600;
            color: white;
        }
        
        .celebration-score {
            font-size: 3rem;
            font-weight: 900;
            color: white;
            margin-bottom: 12px;
        }
        
        .celebration-streak {
            font-size: 1.3rem;
            color: #fbbf24;
            margin-bottom: 40px;
        }
        
        .celebration-actions {
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-width: 300px;
            margin: 0 auto 24px;
        }
        
        .celebration-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 16px 24px;
            border-radius: 14px;
            font-size: 1.1rem;
            font-weight: 600;
            border: none;
            cursor: pointer;
            transition: transform 0.15s, box-shadow 0.15s;
        }
        
        .celebration-btn:active {
            transform: scale(0.97);
        }
        
        .celebration-btn.primary {
            background: linear-gradient(135deg, #667eea, #5a67d8);
            color: white;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
        }
        
        .celebration-btn.secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }
        
        .celebration-done {
            color: var(--text-muted);
            font-size: 1rem;
            cursor: pointer;
            padding: 12px;
        }
        
        .celebration-done:active {
            color: var(--text-secondary);
        }
        
        /* ============ RECORDING TUTORIAL MODAL ============ */
        .recording-tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10001;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .recording-tutorial-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .recording-tutorial-modal {
            background: var(--bg-secondary);
            border-radius: 24px;
            padding: 32px 24px;
            max-width: 360px;
            width: 100%;
            text-align: center;
            animation: tutorialSlide 0.4s ease-out;
        }
        
        .recording-tutorial-modal h2 {
            color: #ffffff !important;
            text-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
        }
        
        @keyframes tutorialSlide {
            from { transform: translateY(30px) scale(0.95); opacity: 0; }
            to { transform: translateY(0) scale(1); opacity: 1; }
        }
        
        .tutorial-step {
            display: none;
        }
        
        .tutorial-step.active {
            display: block;
            animation: tutorialFade 0.3s ease-out;
        }
        
        @keyframes tutorialFade {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        .tutorial-icon {
            font-size: 3rem;
            margin-bottom: 16px;
        }
        
        .tutorial-step h2 {
            font-size: 1.4rem;
            font-weight: 700;
            margin-bottom: 20px;
            color: var(--text-primary);
        }
        
        .tutorial-desc {
            color: var(--text-muted);
            font-size: 0.95rem;
            margin-bottom: 20px;
        }
        
        /* Visual animation for step 1 */
        .tutorial-visual {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            margin-bottom: 24px;
            padding: 20px;
            background: var(--bg-tertiary);
            border-radius: 16px;
        }
        
        .tutorial-phone {
            width: 80px;
            height: 100px;
            background: var(--bg-primary);
            border-radius: 12px;
            border: 2px solid var(--border);
            padding: 8px;
        }
        
        .tutorial-phone-screen {
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .tutorial-game-result {
            font-size: 0.7rem;
            letter-spacing: 1px;
        }
        
        .tutorial-share-btn {
            font-size: 0.6rem;
            background: var(--accent-purple);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            animation: tutorialPulse 1.5s ease-in-out infinite;
        }
        
        @keyframes tutorialPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .tutorial-arrow {
            font-size: 1.5rem;
            color: var(--accent-purple);
            animation: tutorialArrow 1s ease-in-out infinite;
        }
        
        @keyframes tutorialArrow {
            0%, 100% { transform: translateX(0); opacity: 1; }
            50% { transform: translateX(5px); opacity: 0.6; }
        }
        
        .tutorial-copy-icon {
            font-size: 2rem;
        }
        
        /* Steps list for step 1 */
        .tutorial-steps-list {
            text-align: left;
            margin-bottom: 24px;
        }
        
        .tutorial-step-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 0;
            border-bottom: 1px solid var(--border);
        }
        
        .tutorial-step-item:last-child {
            border-bottom: none;
        }
        
        .step-num {
            width: 28px;
            height: 28px;
            background: var(--accent-purple);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.9rem;
            flex-shrink: 0;
        }
        
        /* Benefits for step 2 */
        .tutorial-benefits {
            text-align: left;
            margin-bottom: 24px;
        }
        
        .tutorial-benefit {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 10px;
            margin-bottom: 8px;
        }
        
        .benefit-icon {
            font-size: 1.3rem;
        }
        
        /* Features for step 3 */
        .tutorial-features {
            margin-bottom: 20px;
        }
        
        .tutorial-feature {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            text-align: left;
        }
        
        .feature-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 6px;
        }
        
        .feature-icon {
            font-size: 1.3rem;
        }
        
        .feature-title {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .tutorial-feature p {
            color: var(--text-muted);
            font-size: 0.9rem;
            margin: 0;
        }
        
        .tutorial-cta {
            color: var(--accent-purple);
            font-weight: 600;
            margin-bottom: 20px;
        }
        
        /* Tutorial buttons */
        .tutorial-btn {
            width: 100%;
            padding: 14px 24px;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .tutorial-btn.primary {
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-secondary));
            color: white;
            margin-bottom: 12px;
        }
        
        .tutorial-btn.primary:active {
            transform: scale(0.98);
        }
        
        .tutorial-btn.ghost {
            background: transparent;
            color: var(--text-muted);
        }
        
        .tutorial-btn.ghost:active {
            color: var(--text-secondary);
        }
        
        /* ============ LAUNCH PREFERENCE MODAL ============ */
        .launch-pref-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s ease;
        }
        
        .launch-pref-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .launch-pref-modal {
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 28px 24px;
            max-width: 340px;
            width: 100%;
            animation: launchPrefSlide 0.3s ease-out;
        }
        
        @keyframes launchPrefSlide {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .launch-pref-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }
        
        .launch-pref-icon {
            font-size: 2.2rem;
        }
        
        .launch-pref-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-primary);
        }
        
        .launch-pref-subtitle {
            color: var(--text-muted);
            font-size: 0.9rem;
            margin-bottom: 20px;
            line-height: 1.4;
        }
        
        .launch-pref-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .launch-pref-option {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 16px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 14px;
            cursor: pointer;
            text-align: left;
            transition: all 0.15s ease;
        }
        
        .launch-pref-option:active {
            transform: scale(0.98);
            border-color: var(--accent-purple);
            background: rgba(102, 126, 234, 0.1);
        }
        
        .launch-pref-option-icon {
            font-size: 1.8rem;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-primary);
            border-radius: 12px;
        }
        
        .launch-pref-option-text {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .launch-pref-option-title {
            font-weight: 600;
            font-size: 1rem;
            color: var(--text-primary);
        }
        
        .launch-pref-option-desc {
            font-size: 0.85rem;
            color: var(--text-muted);
        }
        
        .launch-pref-footer {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.8rem;
        }
        
        /* ============ LAUNCH VERIFY MODAL ============ */
        .launch-verify-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s ease;
        }
        
        .launch-verify-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .launch-verify-modal {
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 28px 24px;
            max-width: 340px;
            width: 100%;
            text-align: center;
        }
        
        .launch-verify-header {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }
        
        .launch-verify-icon {
            font-size: 2.5rem;
        }
        
        .launch-verify-title {
            font-size: 1.15rem;
            font-weight: 700;
            color: var(--text-primary);
        }
        
        .launch-verify-subtitle {
            color: var(--text-muted);
            font-size: 0.9rem;
            margin-bottom: 24px;
        }
        
        .launch-verify-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .launch-verify-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 16px;
            border-radius: 14px;
            font-size: 1.05rem;
            font-weight: 600;
            border: none;
            cursor: pointer;
        }
        
        .launch-verify-btn.success {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
        }
        
        .launch-verify-btn.fail {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }
        
        /* ============ LAUNCH FIX MODAL ============ */
        .launch-fix-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10001;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s ease;
        }
        
        .launch-fix-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .launch-fix-modal {
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 24px;
            max-width: 340px;
            width: 100%;
        }
        
        .launch-fix-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }
        
        .launch-fix-icon {
            font-size: 1.8rem;
        }
        
        .launch-fix-title {
            font-size: 1.2rem;
            font-weight: 700;
        }
        
        .launch-fix-subtitle {
            color: var(--text-muted);
            font-size: 0.9rem;
            margin-bottom: 16px;
        }
        
        .launch-fix-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 16px;
        }
        
        .launch-fix-option {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 12px;
            cursor: pointer;
            text-align: left;
            font-size: 0.95rem;
            color: var(--text-primary);
        }
        
        .launch-fix-option:active {
            background: rgba(102, 126, 234, 0.1);
            border-color: var(--accent-purple);
        }
        
        .launch-fix-option-icon {
            font-size: 1.3rem;
        }
        
        .launch-fix-cancel {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.9rem;
            cursor: pointer;
            padding: 8px;
        }
        
        /* ============ CUSTOM URL MODAL ============ */
        .custom-url-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10002;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s ease;
        }
        
        .custom-url-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .custom-url-modal {
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 24px;
            max-width: 340px;
            width: 100%;
        }
        
        .custom-url-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }
        
        .custom-url-icon {
            font-size: 1.8rem;
        }
        
        .custom-url-title {
            font-size: 1.1rem;
            font-weight: 700;
        }
        
        .custom-url-subtitle {
            color: var(--text-muted);
            font-size: 0.9rem;
            margin-bottom: 16px;
        }
        
        .custom-url-input {
            width: 100%;
            padding: 14px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 12px;
            font-size: 1rem;
            color: var(--text-primary);
            margin-bottom: 16px;
        }
        
        .custom-url-input:focus {
            outline: none;
            border-color: var(--accent-purple);
        }
        
        .custom-url-actions {
            display: flex;
            gap: 12px;
        }
        
        .custom-url-btn {
            flex: 1;
            padding: 14px;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            cursor: pointer;
        }
        
        .custom-url-btn.cancel {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }
        
        .custom-url-btn.save {
            background: var(--accent-purple);
            color: white;
        }
        
        .friend-empty {
            text-align: center;
            padding: 32px 16px;
            color: var(--text-muted);
        }
        
        .friend-empty-icon {
            font-size: 3rem;
            margin-bottom: 12px;
        }
        
        .friend-empty-text {
            font-size: 0.9rem;
            margin-bottom: 16px;
        }
        
        /* Add Friend Modal */
        .friend-code-display {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 16px;
            text-align: center;
            margin-bottom: 16px;
        }
        
        .friend-code-label {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-bottom: 8px;
        }
        
        .friend-code-value {
            font-size: 1.8rem;
            font-weight: 700;
            font-family: monospace;
            letter-spacing: 4px;
            color: var(--accent-purple);
        }
        
        .friend-code-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }
        
        .friend-code-btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
        }
        
        .friend-code-btn.primary {
            background: var(--accent-purple);
            color: white;
        }
        
        .friend-code-btn.secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .friend-input-section {
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid var(--border);
        }
        
        .friend-input-label {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .friend-code-input {
            width: 100%;
            padding: 14px;
            border: 2px solid var(--border);
            border-radius: 12px;
            font-size: 1.2rem;
            font-family: monospace;
            text-align: center;
            letter-spacing: 4px;
            text-transform: uppercase;
            background: var(--bg-primary);
            color: var(--text-primary);
            box-sizing: border-box;
        }
        
        .friend-code-input:focus {
            outline: none;
            border-color: var(--accent-purple);
        }
        
        /* Contact Finder */
        .contact-finder-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border);
        }
        
        .contact-finder-btn {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, #48bb78, #38a169);
            border: none;
            border-radius: 12px;
            color: white;
            font-weight: 600;
            font-size: 0.95rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .contact-finder-btn:active {
            opacity: 0.9;
        }
        
        .contact-finder-btn:disabled {
            background: var(--bg-tertiary);
            color: var(--text-muted);
            cursor: not-allowed;
        }
        
        .contact-finder-hint {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 8px;
            text-align: center;
        }
        
        .contact-results-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 50vh;
            overflow-y: auto;
        }
        
        .contact-result-card {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            border: 1px solid var(--border);
        }
        
        .contact-result-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: 700;
            color: white;
            flex-shrink: 0;
        }
        
        .contact-result-info {
            flex: 1;
            min-width: 0;
        }
        
        .contact-result-name {
            font-weight: 600;
            font-size: 0.95rem;
        }
        
        .contact-result-status {
            font-size: 0.8rem;
            color: var(--accent-green);
            margin-top: 2px;
        }
        
        .contact-result-add {
            background: var(--accent-purple);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.85rem;
            cursor: pointer;
        }
        
        .contact-result-add:active {
            opacity: 0.8;
        }
        
        .contact-result-add.added {
            background: var(--bg-secondary);
            color: var(--accent-green);
        }
        
        .contact-empty-state {
            text-align: center;
            padding: 30px 20px;
            color: var(--text-muted);
        }
        
        .contact-empty-icon {
            font-size: 3rem;
            margin-bottom: 12px;
        }
        
        .contact-searching {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-muted);
        }
        
        .contact-searching-spinner {
            font-size: 2rem;
            animation: spin 1s linear infinite;
            margin-bottom: 12px;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        /* Activity Feed */
        .activity-feed {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .activity-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            background: var(--bg-secondary);
            border-radius: 10px;
        }
        
        .activity-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            flex-shrink: 0;
        }
        
        .activity-content {
            flex: 1;
            min-width: 0;
        }
        
        .activity-text {
            font-size: 0.85rem;
        }
        
        .activity-text strong {
            font-weight: 600;
        }
        
        .activity-time {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 2px;
        }
        
        .activity-game-icon {
            font-size: 1.2rem;
        }
        
        /* Friends Leaderboard */
        .friends-leaderboard {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .leaderboard-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            background: var(--bg-secondary);
            border-radius: 10px;
        }
        
        .leaderboard-row.you {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.2));
            border: 1px solid var(--accent-purple);
        }
        
        .leaderboard-row.not-played {
            opacity: 0.5;
        }
        
        .leaderboard-rank {
            width: 24px;
            font-weight: 700;
            font-size: 0.9rem;
            color: var(--text-muted);
        }
        
        .leaderboard-rank.gold { color: #FFD700; }
        .leaderboard-rank.silver { color: #C0C0C0; }
        .leaderboard-rank.bronze { color: #CD7F32; }
        
        .leaderboard-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
        }
        
        .leaderboard-name {
            flex: 1;
            font-weight: 500;
            font-size: 0.9rem;
        }
        
        .leaderboard-score {
            font-weight: 700;
            font-size: 0.95rem;
        }
        
        /* Profile View */
        .profile-header {
            text-align: center;
            padding: 24px 16px;
        }
        
        .profile-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            margin: 0 auto 12px;
        }
        
        .profile-avatar img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
        }
        
        .profile-name {
            font-size: 1.4rem;
            font-weight: 700;
            margin-bottom: 4px;
        }
        
        .profile-subtitle {
            color: var(--text-muted);
            font-size: 0.85rem;
        }
        
        .profile-stats {
            display: flex;
            justify-content: center;
            gap: 24px;
            margin-top: 16px;
        }
        
        .profile-stat {
            text-align: center;
        }
        
        .profile-stat-value {
            font-size: 1.3rem;
            font-weight: 700;
        }
        
        .profile-stat-label {
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        
        .profile-actions {
            display: flex;
            gap: 12px;
            padding: 16px;
        }
        
        .profile-action-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
        }
        
        .profile-action-btn.primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        
        .profile-action-btn.secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* Games Section */
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 16px;
            margin-bottom: 12px;
        }
        
        .section-title {
            font-weight: 700;
            font-size: 1rem;
        }
        
        .see-all {
            color: var(--accent-purple);
            font-size: 0.85rem;
            background: none;
            border: none;
            cursor: pointer;
        }
        
        /* Games Grid */
        .games-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            padding: 0 16px;
            max-width: 100%;
            box-sizing: border-box;
        }
        
        /* Prevent double padding in games list */
        .games-list .games-grid {
            padding: 0;
            width: 100%;
        }
        
        .game-card {
            background: var(--bg-secondary);
            border-radius: 14px;
            padding: 14px 10px;
            text-align: center;
            border: 1px solid var(--border);
            cursor: pointer;
            transition: transform 0.15s, border-color 0.15s;
            min-width: 0;
            overflow: hidden;
        }
        
        .game-card:active {
            transform: scale(0.95);
        }
        
        /* v1.3.1: Visual feedback during long-press */
        .game-card.long-pressing,
        .quick-game-btn.long-pressing {
            transform: scale(0.92);
            border-color: var(--accent-purple);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
        }
        
        .game-card.done {
            border-color: var(--accent-green);
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.15), rgba(34, 197, 94, 0.08));
            position: relative;
        }
        
        .game-card.done::before {
            content: 'âœ“';
            position: absolute;
            top: 6px;
            right: 6px;
            background: var(--accent-green);
            color: white;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            font-size: 0.7rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .game-icon {
            font-size: 1.5rem;
            margin-bottom: 6px;
        }
        
        .game-name {
            font-size: 0.72rem;
            color: var(--text-secondary);
            margin-bottom: 4px;
            white-space: normal;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            line-height: 1.3;
            min-height: 1.9em;
        }
        
        .game-status {
            font-size: 0.7rem;
            color: var(--text-muted);
        }
        
        .game-card.done .game-status {
            color: var(--accent-green);
        }
        
        /* Collapsible Game Categories */
        .game-category-accordion {
            margin-bottom: 8px;
        }
        
        .game-category-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .game-category-header:active {
            background: var(--bg-tertiary);
        }
        
        .game-category-header.expanded {
            border-radius: 10px 10px 0 0;
        }
        
        .game-category-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .game-category-icon {
            font-size: 1.2rem;
        }
        
        .game-category-name {
            font-weight: 600;
            font-size: 0.9rem;
        }
        
        .game-category-count {
            color: var(--text-muted);
            font-size: 0.8rem;
            font-weight: normal;
        }
        
        .game-category-chevron {
            color: var(--text-muted);
            transition: transform 0.2s;
        }
        
        .game-category-header.expanded .game-category-chevron {
            transform: rotate(180deg);
        }
        
        .game-category-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .add-all-btn {
            padding: 6px 12px;
            background: var(--accent-purple);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .add-all-btn:active {
            transform: scale(0.95);
            opacity: 0.9;
        }
        
        .all-added-badge {
            padding: 4px 8px;
            background: rgba(72, 187, 120, 0.2);
            border-radius: 6px;
            color: var(--accent-green);
            font-size: 0.7rem;
            font-weight: 600;
        }
        
        .game-category-content {
            display: none;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 0 0 10px 10px;
            margin-top: -1px;
        }
        
        .game-category-content.expanded {
            display: block;
        }
        
        .game-category-content .games-grid {
            gap: 8px;
        }
        
        .game-mini-card {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            cursor: pointer;
        }
        
        .game-mini-card:active {
            opacity: 0.7;
        }
        
        .game-mini-card.on-shelf {
            opacity: 0.5;
        }
        
        .game-mini-icon {
            font-size: 1.3rem;
        }
        
        .game-mini-info {
            flex: 1;
        }
        
        .game-mini-name {
            font-weight: 600;
            font-size: 0.85rem;
        }
        
        .game-mini-status {
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        
        .game-mini-status.on-shelf {
            color: var(--accent-green);
        }
        
        .game-mini-add {
            color: var(--accent-purple);
            font-weight: 600;
            font-size: 0.85rem;
        }
        
        /* ============ RECOMMENDATIONS SECTION ============ */
        .recommendations-section {
            margin: 0 16px 16px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-radius: 16px;
            padding: 16px;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }
        
        .recommendations-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
        }
        
        .recommendations-header.expanded {
            margin-bottom: 12px;
        }
        
        .recommendations-title {
            font-size: 0.95rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .recommendations-chevron {
            color: var(--text-muted);
            font-size: 0.8rem;
            transition: transform 0.2s;
        }
        
        .recommendations-header.expanded .recommendations-chevron {
            transform: rotate(180deg);
        }
        
        .recommendations-subtitle {
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        
        .recommendations-refresh {
            background: none;
            border: none;
            color: var(--accent-purple);
            font-size: 1.1rem;
            cursor: pointer;
            padding: 4px;
            border-radius: 50%;
            transition: transform 0.3s;
        }
        
        .recommendations-refresh:active {
            transform: rotate(180deg);
        }
        
        .recommendations-list {
            display: none;
            flex-direction: column;
            gap: 10px;
        }
        
        .recommendations-list.expanded {
            display: flex;
        }
        
        .recommendation-card {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 14px;
            background: var(--bg-secondary);
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.15s, box-shadow 0.15s;
            border: 1px solid var(--border);
        }
        
        .recommendation-card:active {
            transform: scale(0.98);
        }
        
        .recommendation-icon {
            font-size: 1.6rem;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-tertiary);
            border-radius: 10px;
            flex-shrink: 0;
        }
        
        .recommendation-info {
            flex: 1;
            min-width: 0;
        }
        
        .recommendation-name {
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 2px;
        }
        
        .recommendation-reason {
            font-size: 0.75rem;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .recommendation-reason .reason-icon {
            font-size: 0.8rem;
        }
        
        .recommendation-action {
            background: var(--accent-purple);
            color: white;
            border: none;
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            flex-shrink: 0;
            transition: opacity 0.2s;
        }
        
        .recommendation-action:active {
            opacity: 0.8;
        }
        
        .recommendation-badge {
            position: absolute;
            top: -4px;
            right: -4px;
            background: var(--accent-orange);
            color: white;
            font-size: 0.65rem;
            font-weight: 700;
            padding: 2px 6px;
            border-radius: 10px;
        }
        
        .recommendations-empty {
            text-align: center;
            padding: 16px;
            color: var(--text-muted);
            font-size: 0.85rem;
        }
        
        .recommendations-empty .empty-icon {
            font-size: 2rem;
            margin-bottom: 8px;
        }
        
        /* Friend avatars in recommendation */
        .recommendation-friends {
            display: flex;
            margin-left: 4px;
        }
        
        .recommendation-friend-avatar {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent-purple);
            border: 2px solid var(--bg-secondary);
            margin-left: -6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.5rem;
            color: white;
            font-weight: 600;
        }
        
        .recommendation-friend-avatar:first-child {
            margin-left: 0;
        }
        
        .recommendation-friend-avatar.more {
            background: var(--bg-tertiary);
            color: var(--text-muted);
            font-size: 0.55rem;
        }

        /* Bottom Navigation */
        .nav-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-around;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
            padding: 8px 0 calc(8px + var(--safe-bottom));
            z-index: 100;
        }
        
        .nav-tab {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 8px;
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            transition: color 0.2s;
        }
        
        .nav-tab.active {
            color: var(--accent-purple);
        }
        
        .nav-icon { font-size: 1.3rem; }
        .nav-label { font-size: 0.7rem; font-weight: 600; }
        
        /* Bottom Sheet */
        .bottom-sheet-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 200;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }
        
        .bottom-sheet-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        .bottom-sheet {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border-radius: 20px 20px 0 0;
            padding: 12px 20px calc(20px + var(--safe-bottom));
            transform: translateY(100%);
            transition: transform 0.3s ease-out;
            max-height: 85vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .bottom-sheet-overlay.active .bottom-sheet {
            transform: translateY(0);
        }
        
        .modal-overlay.active .bottom-sheet {
            transform: translateY(0);
        }
        
        .bottom-sheet-handle {
            width: 40px;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            margin: 0 auto 16px;
        }
        
        .bottom-sheet-header {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 16px;
            text-align: center;
        }
        
        .log-textarea {
            width: 100%;
            height: 180px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 14px;
            color: var(--text-primary);
            font-size: 0.95rem;
            resize: none;
            font-family: inherit;
        }
        
        .log-textarea::placeholder {
            color: var(--text-muted);
        }
        
        .log-btn {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 14px;
            color: white;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            margin-top: 16px;
        }
        
        .log-btn:active {
            opacity: 0.9;
        }
        
        /* Parse Result Preview */
        .parse-preview {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 14px;
            margin-top: 12px;
            display: none;
        }
        
        .parse-preview.visible { display: block; }
        
        .parse-game-name {
            font-weight: 700;
            font-size: 1rem;
            margin-bottom: 4px;
        }
        
        .parse-score {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        
        /* Log Sheet Tabs */
        .log-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }
        
        .log-tab {
            flex: 1;
            padding: 10px 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 10px;
            color: var(--text-secondary);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .log-tab.active {
            background: var(--accent-purple);
            border-color: var(--accent-purple);
            color: white;
        }
        
        .log-tab-content {
            animation: fadeIn 0.2s ease;
        }
        
        .log-buttons {
            display: flex;
            gap: 10px;
            margin-top: 16px;
        }
        
        .log-buttons .log-btn {
            flex: 1;
            margin-top: 0;
        }
        
        .log-btn-secondary {
            flex: 0 0 auto;
            padding: 16px 20px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 14px;
            color: var(--text-primary);
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
        }
        
        .log-btn-secondary:active {
            background: var(--bg-secondary);
        }
        
        /* Quick Log */
        .quick-log-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .quick-log-game-btn {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .quick-log-game-btn:active {
            background: var(--accent-purple);
            border-color: var(--accent-purple);
        }
        
        .quick-log-icon {
            font-size: 1.4rem;
        }
        
        .quick-log-name {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .quick-log-options {
            margin-top: 16px;
            padding: 16px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            animation: slideUp 0.2s ease;
        }
        
        .quick-log-options-title {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 14px;
            text-align: center;
        }
        
        .quick-log-scores {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }
        
        .quick-score-btn {
            padding: 12px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .quick-score-btn:active {
            transform: scale(0.95);
        }
        
        .quick-score-btn.perfect {
            background: linear-gradient(135deg, #10b981, #059669);
            border-color: transparent;
            color: white;
        }
        
        .quick-score-btn.fail {
            background: var(--accent-red);
            border-color: transparent;
            color: white;
        }
        
        .quick-log-time-input {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .quick-log-presets {
            display: flex;
            gap: 8px;
            justify-content: center;
        }
        
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translate(-50%, -20px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }
        
        /* Auto-log toast styles */
        .auto-log-toast {
            animation: slideDown 0.3s ease !important;
        }
        
        /* Clipboard Prompt */
        .clipboard-prompt {
            position: fixed;
            bottom: calc(80px + var(--safe-bottom));
            left: 16px;
            right: 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--accent-purple);
            border-radius: 14px;
            padding: 14px;
            display: flex;
            align-items: center;
            gap: 12px;
            z-index: 150;
            transform: translateY(150%);
            transition: transform 0.3s ease-out;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        .clipboard-prompt.visible {
            transform: translateY(0);
        }
        
        .prompt-icon { font-size: 1.3rem; }
        .prompt-text { flex: 1; font-size: 0.9rem; }
        
        .prompt-yes, .prompt-no {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .prompt-yes {
            background: var(--accent-green);
            color: white;
        }
        
        .prompt-yes:active {
            background: #3a9d68;
        }
        
        .prompt-no {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }
        
        .prompt-no:active {
            background: var(--bg-hover);
        }
        
        /* Return-from-Game Prompt */
        .return-prompt {
            position: fixed;
            bottom: calc(90px + var(--safe-bottom));
            left: 16px;
            right: 16px;
            background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(102, 126, 234, 0.1) 100%);
            border: 2px solid var(--accent-purple);
            border-radius: 16px;
            padding: 16px;
            z-index: 160;
            transform: translateY(150%);
            transition: transform 0.3s ease-out;
            box-shadow: 0 8px 32px rgba(102, 126, 234, 0.3);
        }
        
        .return-prompt.visible {
            transform: translateY(0);
        }
        
        .return-prompt-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .return-prompt-icon {
            font-size: 2rem;
            width: 50px;
            height: 50px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .return-prompt-title {
            font-weight: 700;
            font-size: 1rem;
            margin-bottom: 2px;
        }
        
        .return-prompt-subtitle {
            color: var(--text-muted);
            font-size: 0.85rem;
        }
        
        .return-prompt-actions {
            display: flex;
            gap: 10px;
        }
        
        .return-prompt-btn {
            flex: 1;
            padding: 12px;
            border-radius: 10px;
            border: none;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        
        .return-prompt-btn:active {
            opacity: 0.8;
        }
        
        .return-prompt-btn.primary {
            background: var(--accent-purple);
            color: white;
        }
        
        .return-prompt-btn.secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .return-prompt-btn.manual {
            background: var(--bg-tertiary);
            color: var(--accent-purple);
            font-size: 0.85rem;
        }
        
        .return-prompt-close {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 4px;
        }
        
        /* ============ HINT FAB & SHEET ============ */
        .hint-fab {
            display: none; /* Moved to header */
            position: fixed;
            bottom: calc(160px + var(--safe-bottom));
            right: 20px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
            z-index: 100;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .hint-fab:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(139, 92, 246, 0.5);
        }
        
        .hint-fab:active {
            transform: scale(0.95);
        }
        
        .hint-fab.has-data {
            animation: hint-fab-pulse 2s ease-in-out infinite;
        }
        
        @keyframes hint-fab-pulse {
            0%, 100% { box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4); }
            50% { box-shadow: 0 4px 20px rgba(245, 158, 11, 0.6); }
        }
        
        .hint-fab-badge {
            position: absolute;
            top: -4px;
            right: -4px;
            background: #10b981;
            color: white;
            font-size: 0.65rem;
            font-weight: 700;
            padding: 2px 6px;
            border-radius: 10px;
            border: 2px solid var(--bg-primary);
        }
        
        .hint-sheet {
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
        }
        
        .hint-sheet-close {
            position: absolute;
            top: calc(16px + env(safe-area-inset-top, 0px));
            right: 16px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-muted);
            font-size: 1.5rem;
            line-height: 1;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 100;
        }
        
        .hint-sheet-close:hover {
            background: var(--bg-primary);
            color: var(--text-primary);
        }
        
        .hint-sheet-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }
        
        .hint-sheet-icon {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }
        
        .hint-sheet-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-primary);
        }
        
        .hint-sheet-subtitle {
            font-size: 0.85rem;
            color: var(--text-muted);
        }
        
        .hint-game-card {
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        .hint-game-card.detected {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.1);
        }
        
        .hint-game-info {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .hint-game-icon {
            font-size: 2rem;
        }
        
        .hint-game-name {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .hint-game-puzzle {
            font-size: 0.85rem;
            color: var(--text-muted);
        }
        
        .hint-detected-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .hint-level-control {
            margin-bottom: 16px;
        }
        
        .hint-level-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .hint-level-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        
        .hint-level-value {
            font-weight: 600;
            color: #f59e0b;
        }
        
        .hint-level-slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--bg-tertiary);
            border-radius: 3px;
            outline: none;
        }
        
        .hint-level-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .hint-level-bar {
            display: flex;
            gap: 3px;
            margin-top: 8px;
        }
        
        .hint-level-segment {
            flex: 1;
            height: 4px;
            border-radius: 2px;
            background: var(--bg-tertiary);
            transition: background 0.2s;
        }
        
        .hint-level-segment.active.green { background: #10b981; }
        .hint-level-segment.active.yellow { background: #f59e0b; }
        .hint-level-segment.active.red { background: #ef4444; }
        
        .hint-level-desc {
            text-align: center;
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-top: 8px;
        }
        
        .hint-get-btn {
            width: 100%;
            padding: 16px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
            color: white;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s, transform 0.2s;
        }
        
        .hint-get-btn:hover {
            opacity: 0.9;
        }
        
        .hint-get-btn:active {
            transform: scale(0.98);
        }
        
        .hint-get-btn:disabled {
            opacity: 0.6;
            cursor: wait;
        }
        
        .hint-get-btn .spinner {
            display: inline-block;
            width: 18px;
            height: 18px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 8px;
            vertical-align: middle;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .hint-get-btn.loading {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            animation: hint-btn-pulse 1.5s ease-in-out infinite;
        }
        
        @keyframes hint-btn-pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.85; transform: scale(0.98); }
        }
        
        .hint-loading-text {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        
        .hint-loading-dots::after {
            content: '';
            animation: hint-dots 1.5s steps(4, end) infinite;
        }
        
        @keyframes hint-dots {
            0% { content: ''; }
            25% { content: '.'; }
            50% { content: '..'; }
            75% { content: '...'; }
            100% { content: ''; }
        }
        
        .hint-result {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.15), rgba(99, 102, 241, 0.15));
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        .hint-result-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            font-size: 0.85rem;
            color: #a78bfa;
        }
        
        .hint-result-text {
            color: var(--text-primary);
            font-size: 1.05rem;
            line-height: 1.5;
            white-space: pre-wrap;
        }
        
        .hint-actions {
            display: flex;
            gap: 12px;
            margin-top: 12px;
        }
        
        .hint-action-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        
        .hint-action-btn.still-stuck {
            background: #f59e0b;
            color: white;
        }
        
        .hint-action-btn.got-it {
            background: #10b981;
            color: white;
        }
        
        .hint-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .hint-other-games {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border);
        }
        
        .hint-other-games-title {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 12px;
        }
        
        .hint-game-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            max-height: 300px;
            overflow-y: auto;
            padding-right: 8px;
        }
        
        .hint-chip-category {
            width: 100%;
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 8px;
            padding-bottom: 4px;
            border-bottom: 1px solid var(--border);
        }
        
        .hint-chip-category:first-child {
            margin-top: 0;
        }
        
        .hint-game-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 20px;
            font-size: 0.85rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .hint-game-chip:hover {
            background: var(--bg-secondary);
            border-color: var(--accent-purple);
        }
        
        .hint-game-chip.active {
            background: rgba(139, 92, 246, 0.2);
            border-color: var(--accent-purple);
            color: var(--accent-purple);
        }
        
        .hint-input-section {
            margin-bottom: 16px;
        }
        
        .hint-input-label {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 8px;
        }
        
        .hint-input {
            width: 100%;
            padding: 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.95rem;
        }
        
        .hint-input:focus {
            outline: none;
            border-color: var(--accent-purple);
        }
        
        .hint-history {
            margin-top: 12px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }
        
        .hint-history-title {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .hint-history-item {
            font-size: 0.8rem;
            color: var(--text-secondary);
            padding: 4px 0;
            border-bottom: 1px solid var(--border);
        }
        
        .hint-history-item:last-child {
            border-bottom: none;
        }
        
        .hint-error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #f87171;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            font-size: 0.9rem;
        }
        
        /* Quick Capture Sheet */
        .quick-capture-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 16px;
        }
        
        .quick-capture-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            padding: 14px 8px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .quick-capture-btn:active {
            transform: scale(0.95);
            border-color: var(--accent-purple);
        }
        
        .quick-capture-btn.done {
            opacity: 0.5;
            border-color: var(--accent-green);
            background: rgba(72, 187, 120, 0.1);
        }
        
        .quick-capture-icon {
            font-size: 1.5rem;
        }
        
        .quick-capture-name {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-align: center;
            line-height: 1.2;
        }
        
        .quick-capture-status {
            font-size: 0.6rem;
            color: var(--accent-green);
        }
        
        /* Clipboard++ indicator */
        .clipboard-monitor-badge {
            position: fixed;
            bottom: calc(140px + var(--safe-bottom));
            right: 16px;
            background: var(--accent-purple);
            color: white;
            font-size: 0.7rem;
            padding: 4px 10px;
            border-radius: 12px;
            display: none;
            align-items: center;
            gap: 6px;
            z-index: 140;
            animation: clipboardPulse 2s ease-in-out infinite;
        }
        
        .clipboard-monitor-badge.active {
            display: flex;
        }
        
        @keyframes clipboardPulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        /* Pre-Launch Reminder */
        .prelaunch-reminder {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10002;
            display: none;
            align-items: center;
            justify-content: center;
            animation: prelaunchFadeIn 0.2s ease-out;
        }
        
        .prelaunch-reminder.active {
            display: flex;
        }
        
        @keyframes prelaunchFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .prelaunch-content {
            text-align: center;
            padding: 32px;
        }
        
        .prelaunch-icon {
            font-size: 3rem;
            margin-bottom: 16px;
            animation: prelaunchBounce 0.6s ease infinite;
        }
        
        @keyframes prelaunchBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }
        
        .prelaunch-text {
            font-size: 1.3rem;
            color: white;
            margin-bottom: 8px;
        }
        
        .prelaunch-text strong {
            color: var(--accent-purple);
        }
        
        .prelaunch-subtext {
            color: var(--text-muted);
            font-size: 0.95rem;
            margin-bottom: 20px;
        }
        
        .prelaunch-progress {
            width: 120px;
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            margin: 0 auto;
            overflow: hidden;
        }
        
        .prelaunch-progress::after {
            content: '';
            display: block;
            width: 100%;
            height: 100%;
            background: var(--accent-purple);
            animation: prelaunchProgress 1.5s ease-out forwards;
        }
        
        @keyframes prelaunchProgress {
            from { transform: translateX(-100%); }
            to { transform: translateX(0); }
        }
        
        /* Toast */
        .toast {
            position: fixed;
            top: calc(var(--safe-top) + 70px);
            left: 50%;
            transform: translateX(-50%) translateY(-200px);
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            padding: 12px 24px;
            border-radius: 12px;
            font-size: 0.9rem;
            z-index: 500;
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            opacity: 0;
            pointer-events: none;
        }
        
        .toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
            pointer-events: auto;
        }
        
        .toast.success { border-color: var(--accent-green); }
        .toast.error { border-color: var(--accent-red); }
        
        /* Games Tab */
        .games-list {
            padding: 16px;
            overflow: hidden;
        }
        
        .games-category {
            margin-bottom: 24px;
            overflow: hidden;
        }
        
        .category-title {
            font-size: 0.8rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            padding-left: 4px;
        }
        
        /* Social Tab */
        .social-section {
            padding: 16px;
        }
        
        .leaderboard-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px;
            background: var(--bg-secondary);
            border-radius: 12px;
            margin-bottom: 10px;
            border: 1px solid var(--border);
        }
        
        .leaderboard-rank {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--bg-tertiary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.9rem;
        }
        
        .leaderboard-rank.gold { background: linear-gradient(135deg, #ffd700, #ffb700); color: #000; }
        .leaderboard-rank.silver { background: linear-gradient(135deg, #c0c0c0, #a0a0a0); color: #000; }
        .leaderboard-rank.bronze { background: linear-gradient(135deg, #cd7f32, #b5651d); color: #fff; }
        
        .leaderboard-info { flex: 1; }
        .leaderboard-name { font-weight: 600; font-size: 0.95rem; }
        .leaderboard-streak { font-size: 0.8rem; color: var(--text-secondary); }
        .leaderboard-score { font-weight: 700; color: var(--accent-purple); }
        
        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-muted);
        }
        
        .empty-icon { font-size: 3rem; margin-bottom: 12px; }
        .empty-title { font-size: 1.1rem; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px; }
        .empty-desc { font-size: 0.9rem; }
        
        /* Account Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 250;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .modal-overlay.active { display: flex; }
        
        .modal-content {
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 24px;
            width: 100%;
            max-width: 340px;
            border: 1px solid var(--border);
        }
        
        .modal-header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .modal-title { font-size: 1.2rem; font-weight: 700; margin-bottom: 8px; }
        .modal-desc { font-size: 0.9rem; color: var(--text-secondary); }
        
        .google-btn {
            width: 100%;
            padding: 14px;
            background: white;
            color: #333;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .modal-close {
            width: 100%;
            padding: 12px;
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 0.9rem;
            cursor: pointer;
            margin-top: 12px;
        }
        
        /* Confirmation Modal */
        .confirm-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1100;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .confirm-modal-overlay.active { display: flex; }
        
        .confirm-modal {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 24px;
            width: 100%;
            max-width: 320px;
            border: 1px solid var(--border);
            text-align: center;
        }
        
        .confirm-modal-icon {
            font-size: 2.5rem;
            margin-bottom: 12px;
        }
        
        .confirm-modal-title {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 8px;
            color: var(--text-primary);
        }
        
        .confirm-modal-message {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 20px;
            line-height: 1.4;
        }
        
        .confirm-modal-buttons {
            display: flex;
            gap: 10px;
        }
        
        .confirm-modal-btn {
            flex: 1;
            padding: 12px 16px;
            border-radius: 10px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: all 0.15s;
        }
        
        .confirm-modal-btn:active {
            transform: scale(0.98);
        }
        
        .confirm-modal-btn.cancel {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .confirm-modal-btn.danger {
            background: var(--accent-red);
            color: white;
        }
        
        .confirm-modal-btn.primary {
            background: var(--accent-purple);
            color: white;
        }
        
        .confirm-modal-btn.secondary {
            background: var(--accent-orange);
            color: white;
        }
        
        /* Signed In Account */
        .account-info {
            text-align: center;
        }
        
        .account-avatar {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: 700;
            margin: 0 auto 12px;
        }
        
        .account-name { font-size: 1.1rem; font-weight: 600; margin-bottom: 4px; }
        .account-email { font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 4px; }
        .sync-status { font-size: 0.8rem; color: var(--accent-green); margin-bottom: 16px; }
        
        .signout-btn {
            width: 100%;
            padding: 12px;
            background: var(--bg-tertiary);
            border: none;
            border-radius: 12px;
            color: var(--accent-red);
            font-size: 0.95rem;
            cursor: pointer;
        }
        
        /* Success Modal */
        .success-modal-content {
            background: var(--bg-secondary);
            border-radius: 24px;
            padding: 32px 24px;
            width: 100%;
            max-width: 320px;
            border: 1px solid var(--border);
            text-align: center;
            animation: successPop 0.4s ease-out;
        }
        
        @keyframes successPop {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .success-celebration {
            font-size: 3rem;
            animation: bounce 0.6s ease infinite;
            margin-bottom: 8px;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        .success-icon {
            font-size: 2.5rem;
            margin-bottom: 8px;
        }
        
        .success-game {
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 4px;
        }
        
        .success-score {
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--accent-green);
            margin-bottom: 8px;
        }
        
        .success-points {
            font-size: 1rem;
            color: var(--accent-purple);
            font-weight: 600;
            margin-bottom: 12px;
        }
        
        .success-streak {
            font-size: 0.95rem;
            color: var(--accent-orange);
            margin-bottom: 20px;
        }
        
        .success-close-btn {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 14px;
            color: white;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .success-btn-row {
            display: flex;
            gap: 10px;
            margin-top: 8px;
        }
        
        .success-share-btn {
            flex: 1;
            padding: 14px 16px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            touch-action: manipulation;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        .success-done-btn {
            flex: 0 0 auto;
            padding: 14px 20px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            touch-action: manipulation;
        }
        
        .success-context {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 16px;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border-radius: 10px;
        }
        
        .success-context-item {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        .success-context-item + .success-context-item {
            margin-top: 4px;
        }
        
        /* Battle Impact Card in Success Modal */
        .battle-impact-card {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.15), rgba(118, 75, 162, 0.15));
            border: 1px solid var(--accent-purple);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 16px;
            text-align: left;
        }
        
        .battle-impact-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 8px;
            color: var(--accent-purple);
        }
        
        .battle-impact-name {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }
        
        .battle-impact-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 0.85rem;
        }
        
        .battle-impact-stat {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .battle-impact-stat-label {
            color: var(--text-muted);
            font-size: 0.7rem;
            text-transform: uppercase;
        }
        
        .battle-impact-stat-value {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .battle-impact-position {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .battle-impact-position.leading {
            color: #fbbf24;
        }
        
        .battle-impact-position.trailing {
            color: var(--text-secondary);
        }
        
        .battle-impact-tip {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid var(--border);
            font-size: 0.75rem;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .battle-impact-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        
        .battle-impact-btn {
            flex: 1;
            padding: 8px 12px;
            border-radius: 8px;
            border: none;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .battle-impact-btn.primary {
            background: var(--accent-purple);
            color: white;
        }
        
        /* Instant Share Sheet */
        .instant-share-sheet {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border-radius: 20px 20px 0 0;
            padding: 20px;
            padding-bottom: calc(20px + env(safe-area-inset-bottom, 0px));
            transform: translateY(100%);
            transition: transform 0.3s ease;
            z-index: 2100;
            max-height: 70vh;
            overflow-y: auto;
        }
        
        .instant-share-sheet.active {
            transform: translateY(0);
        }
        
        .instant-share-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.6);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease;
            z-index: 2050;
        }
        
        .instant-share-backdrop.active {
            opacity: 1;
            visibility: visible;
        }
        
        .instant-share-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }
        
        .instant-share-header h3 {
            margin: 0;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .instant-share-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--text-muted);
            cursor: pointer;
            padding: 4px;
        }
        
        .instant-share-preview {
            margin-bottom: 16px;
        }
        
        .instant-share-textarea {
            width: 100%;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 14px;
            font-family: -apple-system, BlinkMacSystemFont, monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            color: var(--text-primary);
            resize: none;
            box-sizing: border-box;
        }
        
        .instant-share-textarea:focus {
            outline: none;
            border-color: var(--accent-purple);
        }
        
        .instant-share-platforms {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 16px;
        }
        
        .instant-platform-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 12px 8px;
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            touch-action: manipulation;
        }
        
        .instant-platform-btn .icon {
            font-size: 1.3rem;
        }
        
        .instant-share-actions {
            display: flex;
            gap: 10px;
        }
        
        .instant-copy-btn {
            flex: 1;
            padding: 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        .instant-native-btn {
            flex: 1;
            padding: 14px;
            background: var(--accent-green);
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        /* Image Card Generator */
        .image-card-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border);
        }
        
        .image-card-section h4 {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .image-card-preview {
            background: var(--bg-primary);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 12px;
            display: flex;
            justify-content: center;
        }
        
        .image-card-preview canvas {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
        }
        
        .image-format-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .image-format-btn {
            flex: 1;
            padding: 10px 14px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        .image-format-btn.active {
            border-color: var(--accent-purple);
            background: rgba(102, 126, 234, 0.15);
        }
        
        .image-card-preview.story-mode {
            max-width: 200px;
            margin: 0 auto;
        }
        
        .image-card-styles {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            overflow-x: auto;
            padding-bottom: 4px;
        }
        
        .image-style-btn {
            flex: 0 0 auto;
            padding: 8px 14px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            white-space: nowrap;
        }
        
        .image-style-btn.active {
            border-color: var(--accent-purple);
            background: rgba(102, 126, 234, 0.15);
        }
        
        .image-card-actions {
            display: flex;
            gap: 10px;
        }
        
        .image-download-btn {
            flex: 1;
            padding: 12px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        .image-share-btn {
            flex: 1;
            padding: 12px;
            background: var(--accent-green);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        /* Streak Milestone Celebration */
        .milestone-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2200;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .milestone-overlay.active {
            display: flex;
        }
        
        .milestone-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 24px;
            padding: 40px 30px;
            width: 100%;
            max-width: 340px;
            text-align: center;
            border: 2px solid var(--accent-orange);
            box-shadow: 0 0 60px rgba(245, 158, 11, 0.3);
            animation: milestoneAppear 0.5s ease-out;
        }
        
        @keyframes milestoneAppear {
            0% { transform: scale(0.5) rotate(-10deg); opacity: 0; }
            50% { transform: scale(1.1) rotate(2deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        
        .milestone-flames {
            font-size: 4rem;
            animation: flameDance 0.5s ease-in-out infinite alternate;
        }
        
        @keyframes flameDance {
            0% { transform: scale(1) translateY(0); }
            100% { transform: scale(1.1) translateY(-5px); }
        }
        
        .milestone-number {
            font-size: 5rem;
            font-weight: 900;
            background: linear-gradient(135deg, #f59e0b, #ef4444);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1;
            margin: 10px 0;
        }
        
        .milestone-label {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 8px;
        }
        
        .milestone-game {
            font-size: 1rem;
            color: var(--text-secondary);
            margin-bottom: 20px;
        }
        
        .milestone-message {
            font-size: 0.95rem;
            color: var(--accent-orange);
            margin-bottom: 24px;
            font-style: italic;
        }
        
        .milestone-btn-row {
            display: flex;
            gap: 10px;
        }
        
        .milestone-share-btn {
            flex: 1;
            padding: 14px;
            background: linear-gradient(135deg, #f59e0b, #ef4444);
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        .milestone-close-btn {
            padding: 14px 20px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
        }
        
        /* Confetti animation */
        .confetti-container {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 2250;
            overflow: hidden;
        }
        
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            opacity: 0;
        }
        
        @keyframes confettiFall {
            0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }
        
        /* Share Hub */
        .share-hub-modal {
            background: var(--bg-secondary);
            border-radius: 20px 20px 0 0;
            padding: 20px;
            width: 100%;
            max-height: 85vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .share-hub-header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .share-hub-header h2 {
            font-size: 1.3rem;
            margin: 8px 0 4px;
        }
        
        .share-hub-header p {
            color: var(--text-muted);
            font-size: 0.85rem;
        }
        
        .share-results-section {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 14px;
            margin-bottom: 16px;
        }
        
        .share-results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .share-results-header h4 {
            margin: 0;
            font-size: 0.95rem;
        }
        
        .share-results-date {
            color: var(--text-muted);
            font-size: 0.8rem;
        }
        
        .share-result-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .share-result-tag {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: var(--bg-secondary);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
        }
        
        .share-result-tag .score {
            color: var(--accent-green);
            font-weight: 600;
        }
        
        .share-composer {
            margin-bottom: 16px;
        }
        
        .share-composer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .share-composer-header label {
            font-weight: 600;
            font-size: 0.95rem;
        }
        
        .share-template-select {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 6px 10px;
            font-size: 0.85rem;
        }
        
        .share-textarea {
            width: 100%;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px;
            font-size: 0.95rem;
            font-family: inherit;
            resize: vertical;
            min-height: 100px;
        }
        
        .share-emoji-bar {
            display: flex;
            gap: 6px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .share-emoji-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 6px 10px;
            font-size: 1rem;
            cursor: pointer;
            touch-action: manipulation;
        }
        
        .share-options-row {
            display: flex;
            gap: 16px;
            margin-top: 12px;
            flex-wrap: wrap;
        }
        
        .share-option-checkbox {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
            color: var(--text-muted);
            cursor: pointer;
        }
        
        .share-option-checkbox input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: var(--accent-purple);
        }
        
        .share-history-section {
            background: var(--bg-tertiary);
            border-radius: 12px;
            margin-bottom: 16px;
            overflow: hidden;
        }
        
        .share-history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 14px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
        }
        
        .share-history-header:active {
            background: var(--bg-secondary);
        }
        
        .share-history-chevron {
            font-size: 0.7rem;
            transition: transform 0.2s;
        }
        
        .share-history-section.expanded .share-history-chevron {
            transform: rotate(180deg);
        }
        
        .share-history-list {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .share-history-section.expanded .share-history-list {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .share-history-item {
            padding: 10px 14px;
            border-top: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.15s;
        }
        
        .share-history-item:hover, .share-history-item:active {
            background: var(--bg-secondary);
        }
        
        .share-history-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }
        
        .share-history-item-platform {
            font-size: 0.8rem;
            color: var(--text-muted);
        }
        
        .share-history-item-date {
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        
        .share-history-item-preview {
            font-size: 0.85rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }
        
        .share-history-empty {
            padding: 16px;
            text-align: center;
            color: var(--text-muted);
            font-size: 0.85rem;
        }
        
        .share-platforms {
            margin-bottom: 16px;
        }
        
        .share-platforms h4 {
            margin: 0 0 12px;
            font-size: 0.95rem;
        }
        
        .share-platforms-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 12px;
        }
        
        .share-platform-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: none;
            border-radius: 12px;
            padding: 12px 8px;
            cursor: pointer;
            touch-action: manipulation;
            transition: transform 0.2s, opacity 0.2s;
        }
        
        .share-platform-btn:active {
            transform: scale(0.95);
            opacity: 0.9;
        }
        
        .share-platform-btn .icon {
            font-size: 1.4rem;
            margin-bottom: 4px;
        }
        
        .share-platform-btn .label {
            font-size: 0.7rem;
            color: white;
        }
        
        .share-utility-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .share-close-btn {
            width: 100%;
            padding: 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            touch-action: manipulation;
        }
        
        .share-close-btn.btn-disabled {
            opacity: 0.5 !important;
            pointer-events: none !important;
            cursor: not-allowed !important;
        }
        
        /* Merch Store */
        .merch-balance-bar {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 15px;
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.15) 0%, rgba(255, 152, 0, 0.1) 100%);
            border-radius: 10px;
            margin-bottom: 15px;
            font-size: 0.9rem;
        }
        
        .merch-balance-amount {
            font-weight: 700;
            color: var(--accent-gold);
            flex: 1;
        }
        
        .merch-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        .merch-tab {
            padding: 8px 14px;
            background: var(--bg-tertiary);
            border: none;
            border-radius: 20px;
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            white-space: nowrap;
            touch-action: manipulation;
        }
        
        .merch-tab.active {
            background: var(--accent-gold);
            color: #000;
            font-weight: 600;
        }
        
        .merch-catalog {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            padding-bottom: 10px;
        }
        
        .merch-card {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 12px;
            border: 1px solid var(--border);
            cursor: pointer;
            touch-action: manipulation;
        }
        
        .merch-card.owned {
            border-color: var(--accent-green);
            background: rgba(76, 175, 80, 0.1);
        }
        
        .merch-card.unaffordable {
            opacity: 0.6;
        }
        
        .merch-image {
            font-size: 2.2rem;
            text-align: center;
            margin-bottom: 8px;
        }
        
        .merch-info { text-align: center; }
        
        .merch-name {
            font-weight: 600;
            font-size: 0.85rem;
            margin-bottom: 4px;
        }
        
        .merch-desc {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-bottom: 8px;
            line-height: 1.3;
        }
        
        .merch-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .merch-price {
            font-weight: 700;
            color: var(--accent-gold);
            font-size: 0.85rem;
        }
        
        .merch-owned {
            color: var(--accent-green);
            font-size: 0.8rem;
            font-weight: 600;
        }
        
        .merch-section-header {
            grid-column: 1 / -1;
            padding: 10px 0;
            font-weight: 700;
            font-size: 0.95rem;
        }
        
        .merch-earn-hint {
            font-size: 0.7rem;
            color: var(--accent-gold);
            font-weight: 500;
        }
        
        /* Battles */
        .battle-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 16px;
        }
        
        .battle-action-btn {
            flex: 1;
            padding: 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 12px;
            text-align: center;
            cursor: pointer;
            touch-action: manipulation;
        }
        
        .battle-action-btn .action-icon {
            font-size: 1.5rem;
            display: block;
            margin-bottom: 4px;
        }
        
        .battle-action-btn .action-text {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        .battle-card {
            background: var(--bg-tertiary);
            border-radius: 12px;
            margin-bottom: 12px;
            overflow: hidden;
            cursor: pointer;
            touch-action: manipulation;
        }
        
        .battle-card-header {
            padding: 10px 14px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
        }
        
        .battle-badge {
            background: rgba(255,255,255,0.2);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            margin-left: auto;
        }
        
        .battle-badge.live {
            background: #f44336;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .battle-card-content {
            padding: 14px;
        }
        
        .battle-card-title {
            font-weight: 700;
            font-size: 1rem;
            margin-bottom: 4px;
        }
        
        .battle-card-desc {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 10px;
        }
        
        .battle-stats {
            display: flex;
            gap: 15px;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        .battle-leaderboard {
            margin-top: 10px;
        }
        
        .battle-leaderboard-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            border-bottom: 1px solid var(--border);
        }
        
        .battle-leaderboard-row:last-child {
            border-bottom: none;
        }
        
        .battle-rank {
            width: 24px;
            text-align: center;
            font-weight: 700;
        }
        
        .battle-participant-avatar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: var(--accent-purple);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .battle-participant-name {
            flex: 1;
            font-size: 0.9rem;
        }
        
        .battle-participant-score {
            font-weight: 700;
            color: var(--accent-green);
        }
        
        .battle-empty {
            text-align: center;
            padding: 30px 20px;
            color: var(--text-muted);
        }
        
        .battle-empty .empty-icon {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .battle-form-group {
            margin-bottom: 16px;
        }
        
        .battle-form-label {
            display: block;
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .battle-input {
            width: 100%;
            padding: 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 1rem;
        }
        
        .battle-game-select {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .battle-game-chip {
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 20px;
            font-size: 0.85rem;
            cursor: pointer;
            touch-action: manipulation;
        }
        
        .battle-game-chip.selected {
            background: var(--accent-purple);
            border-color: var(--accent-purple);
            color: white;
        }
        
        /* Battle Results Modal */
        .battle-results-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2500;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .battle-results-modal.active {
            display: flex;
        }
        
        .battle-results-content {
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 24px;
            max-width: 400px;
            width: 100%;
            max-height: 85vh;
            overflow-y: auto;
            text-align: center;
            animation: resultsPop 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        @keyframes resultsPop {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .battle-results-trophy {
            font-size: 72px;
            margin-bottom: 8px;
            animation: trophyBounce 0.5s ease-out 0.3s both;
        }
        
        @keyframes trophyBounce {
            0% { transform: scale(0); }
            60% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .battle-results-title {
            font-size: 1.8rem;
            font-weight: 800;
            margin-bottom: 4px;
        }
        
        .battle-results-title.winner {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .battle-results-title.runner-up {
            color: #c0c0c0;
        }
        
        .battle-results-title.participant {
            color: var(--text-secondary);
        }
        
        .battle-results-name {
            font-size: 1rem;
            color: var(--text-secondary);
            margin-bottom: 20px;
        }
        
        .battle-results-stats {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        .battle-results-stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid var(--border);
        }
        
        .battle-results-stat-row:last-child {
            border-bottom: none;
        }
        
        .battle-results-stat-label {
            color: var(--text-muted);
        }
        
        .battle-results-stat-value {
            font-weight: 600;
        }
        
        .battle-results-prize {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            color: #000;
        }
        
        .battle-results-prize-label {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-bottom: 4px;
        }
        
        .battle-results-prize-amount {
            font-size: 1.8rem;
            font-weight: 800;
        }
        
        .battle-results-standings {
            text-align: left;
            margin-bottom: 16px;
        }
        
        .battle-results-standings h4 {
            font-size: 0.9rem;
            color: var(--text-muted);
            margin-bottom: 8px;
        }
        
        .battle-results-standing-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            border-radius: 8px;
            margin-bottom: 4px;
        }
        
        .battle-results-standing-row.winner-row {
            background: rgba(251, 191, 36, 0.1);
        }
        
        .battle-results-standing-row.you-row {
            background: rgba(102, 126, 234, 0.1);
        }
        
        .battle-results-rank {
            font-size: 1.2rem;
            width: 30px;
        }
        
        .battle-results-player {
            flex: 1;
        }
        
        .battle-results-player-name {
            font-weight: 500;
        }
        
        .battle-results-player-score {
            font-size: 0.8rem;
            color: var(--text-muted);
        }
        
        .battle-results-tips {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 16px;
            text-align: left;
        }
        
        .battle-results-tips h4 {
            font-size: 0.85rem;
            margin-bottom: 8px;
            color: var(--text-secondary);
        }
        
        .battle-results-tip-item {
            font-size: 0.8rem;
            color: var(--text-muted);
            padding: 4px 0;
        }
        
        .battle-results-actions {
            display: flex;
            gap: 10px;
        }
        
        .battle-results-btn {
            flex: 1;
            padding: 14px 16px;
            border-radius: 12px;
            border: none;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
        }
        
        .battle-results-btn.primary {
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-pink));
            color: white;
        }
        
        .battle-results-btn.secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        /* Game Selector Modal */
        .game-selector-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: none;
            align-items: flex-end;
            justify-content: center;
        }
        
        .game-selector-overlay.active {
            display: flex;
        }
        
        .game-selector-modal {
            background: var(--bg-secondary);
            border-radius: 20px 20px 0 0;
            width: 100%;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            animation: slideUp 0.3s ease-out;
        }
        
        @keyframes slideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }
        
        .game-selector-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .game-selector-header h3 {
            margin: 0;
            font-size: 1.1rem;
        }
        
        .game-selector-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--text-muted);
            cursor: pointer;
            padding: 4px;
        }
        
        .game-selector-body {
            flex: 1;
            overflow-y: auto;
            padding: 16px 20px;
        }
        
        .game-category {
            margin-bottom: 20px;
        }
        
        .game-category-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .game-category-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        .game-select-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .game-select-item:active {
            transform: scale(0.98);
        }
        
        .game-select-item.selected {
            border-color: var(--accent-purple);
            background: rgba(102, 126, 234, 0.15);
        }
        
        .game-select-icon {
            font-size: 1.3rem;
        }
        
        .game-select-name {
            font-size: 0.9rem;
            font-weight: 500;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .game-select-check {
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            color: transparent;
        }
        
        .game-select-item.selected .game-select-check {
            background: var(--accent-purple);
            border-color: var(--accent-purple);
            color: white;
        }
        
        .game-selector-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 10px;
        }
        
        .game-selector-count {
            flex: 1;
            display: flex;
            align-items: center;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        
        .game-selector-done {
            padding: 12px 24px;
            background: var(--accent-purple);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
        }
        
        /* Selected games preview */
        .selected-games-preview {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 10px;
        }
        
        .selected-game-tag {
            padding: 4px 10px;
            background: var(--accent-purple);
            border-radius: 12px;
            font-size: 0.8rem;
            color: white;
        }
        
        .select-games-btn {
            width: 100%;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border: 2px dashed var(--border);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .select-games-btn:active {
            transform: scale(0.98);
        }
        
        /* Battle Type Selector */
        .battle-type-select {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .battle-type-option {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .battle-type-option:active {
            transform: scale(0.98);
        }
        
        .battle-type-option.selected {
            background: rgba(102, 126, 234, 0.1);
            border-color: var(--accent-purple);
        }
        
        .battle-type-icon {
            font-size: 1.5rem;
            width: 40px;
            text-align: center;
        }
        
        .battle-type-info {
            flex: 1;
        }
        
        .battle-type-name {
            font-weight: 700;
            font-size: 0.95rem;
            color: var(--text-primary);
        }
        
        .battle-type-desc {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-top: 2px;
        }
        
        .battle-type-option.selected .battle-type-name {
            color: var(--accent-purple);
        }
        
        /* Public/Private Toggle */
        .battle-visibility-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 16px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            margin-bottom: 16px;
        }
        
        .battle-visibility-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .battle-visibility-icon {
            font-size: 1.3rem;
        }
        
        .battle-visibility-text {
            font-weight: 600;
            font-size: 0.9rem;
        }
        
        .battle-visibility-desc {
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        
        /* Battle Lobby Section */
        .battle-lobby-section {
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid var(--border);
        }
        
        .battle-lobby-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }
        
        .battle-lobby-title {
            font-weight: 700;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .battle-lobby-refresh {
            background: none;
            border: none;
            color: var(--accent-purple);
            font-size: 1.1rem;
            cursor: pointer;
            padding: 4px;
        }
        
        .battle-lobby-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .public-battle-card {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 14px;
            border: 1px solid var(--border);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .public-battle-card:active {
            transform: scale(0.98);
        }
        
        .public-battle-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .public-battle-name {
            font-weight: 600;
            font-size: 0.95rem;
        }
        
        .public-battle-badge {
            font-size: 0.7rem;
            padding: 3px 8px;
            border-radius: 10px;
            font-weight: 600;
        }
        
        .public-battle-badge.open {
            background: rgba(72, 187, 120, 0.2);
            color: var(--accent-green);
        }
        
        .public-battle-badge.starting-soon {
            background: rgba(237, 137, 54, 0.2);
            color: var(--accent-orange);
        }
        
        .public-battle-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-bottom: 10px;
        }
        
        .public-battle-meta span {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .public-battle-games {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }
        
        .public-battle-game-icon {
            font-size: 1.1rem;
            width: 28px;
            height: 28px;
            background: var(--bg-secondary);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .public-battle-join-btn {
            width: 100%;
            padding: 10px;
            background: var(--accent-purple);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 0.85rem;
            cursor: pointer;
        }
        
        .public-battle-join-btn:active {
            opacity: 0.8;
        }
        
        .public-battle-join-btn.joined {
            background: var(--bg-secondary);
            color: var(--accent-green);
        }
        
        .battle-lobby-empty {
            text-align: center;
            padding: 24px 16px;
            color: var(--text-muted);
        }
        
        .battle-lobby-empty .empty-icon {
            font-size: 2rem;
            margin-bottom: 8px;
        }
        
        .battle-lobby-create-prompt {
            margin-top: 12px;
            color: var(--accent-purple);
            font-weight: 600;
            cursor: pointer;
        }
        
        /* Battle Rules Preview */
        .battle-rules-preview {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 14px;
            margin-top: 12px;
            /* Removed max-height and overflow to prevent nested scroll trap */
        }
        
        .battle-rules-title {
            font-weight: 700;
            font-size: 0.9rem;
            margin-bottom: 8px;
            color: var(--text-primary);
        }
        
        .battle-rules-content {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.5;
        }
        
        /* Detailed Rules Styles */
        .rules-section-title {
            font-weight: 700;
            font-size: 0.9rem;
            margin: 12px 0 8px 0;
            color: var(--text-primary);
        }
        
        .rules-section-title:first-child {
            margin-top: 0;
        }
        
        .rules-list {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.6;
            padding-left: 4px;
        }
        
        .rules-item {
            margin-bottom: 4px;
        }
        
        .rules-list.rules-warning {
            background: rgba(239, 68, 68, 0.1);
            border-left: 3px solid var(--accent-red);
            padding: 10px;
            border-radius: 0 8px 8px 0;
            margin-top: 8px;
        }
        
        .rules-game {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
        }
        
        .rules-game-header {
            font-weight: 700;
            font-size: 0.9rem;
            margin-bottom: 6px;
        }
        
        .rules-game-detail {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-bottom: 2px;
        }
        
        .rules-agreement {
            margin-top: 16px;
            padding: 12px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 10px;
            border: 1px solid var(--accent-purple);
        }
        
        .rules-checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
        }
        
        .rules-checkbox-label input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: var(--accent-purple);
        }
        
        /* Full Rules Modal */
        .rules-modal-content {
            /* No max-height or scroll - let parent container handle scrolling */
            padding: 5px;
        }
        
        /* Referral System */
        .referral-earnings {
            background: linear-gradient(135deg, var(--accent-purple), #764ba2);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 16px;
            color: white;
            text-align: center;
        }
        
        .referral-earnings-total {
            margin-bottom: 16px;
        }
        
        .referral-earnings-value {
            font-size: 2.5rem;
            font-weight: 800;
            display: block;
        }
        
        .referral-earnings-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }
        
        .referral-stats {
            display: flex;
            gap: 10px;
        }
        
        .referral-stat {
            flex: 1;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            padding: 10px 8px;
        }
        
        .referral-stat-value {
            font-size: 1.3rem;
            font-weight: 700;
            display: block;
        }
        
        .referral-stat-label {
            font-size: 0.7rem;
            opacity: 0.8;
        }
        
        .referral-code-section {
            margin-bottom: 16px;
        }
        
        .referral-code-label {
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text-secondary);
        }
        
        .referral-code-box {
            display: flex;
            align-items: center;
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 12px 16px;
            gap: 10px;
        }
        
        .referral-code-box span {
            flex: 1;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-primary);
            word-break: break-all;
        }
        
        .referral-copy-btn {
            background: var(--accent-purple);
            border: none;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 1rem;
            cursor: pointer;
        }
        
        .referral-share-section {
            margin-bottom: 16px;
        }
        
        .referral-share-label {
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text-secondary);
        }
        
        .referral-share-buttons {
            display: flex;
            gap: 8px;
        }
        
        .referral-share-btn {
            flex: 1;
            padding: 12px 8px;
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: 600;
            font-size: 0.85rem;
            cursor: pointer;
        }
        
        .referral-tiers {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 16px;
        }
        
        .referral-tiers-title {
            font-weight: 700;
            font-size: 0.9rem;
            margin-bottom: 12px;
            color: var(--text-primary);
        }
        
        .referral-tier {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 0;
            border-bottom: 1px solid var(--border);
        }
        
        .referral-tier:last-of-type {
            border-bottom: none;
        }
        
        .referral-tier-icon {
            font-size: 1.5rem;
            width: 40px;
            text-align: center;
        }
        
        .referral-tier-info {
            flex: 1;
        }
        
        .referral-tier-name {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-primary);
        }
        
        .referral-tier-desc {
            font-size: 0.8rem;
            color: var(--text-muted);
        }
        
        .referral-tier-reward {
            font-weight: 700;
            font-size: 0.9rem;
            color: var(--accent-purple);
        }
        
        .referral-tier-total {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 12px;
            margin-top: 8px;
            border-top: 2px solid var(--accent-purple);
            font-weight: 700;
        }
        
        /* Activity Summary */
        .summary-header {
            text-align: center;
            font-size: 1rem;
            color: var(--text-muted);
            margin-bottom: 16px;
        }
        
        .summary-section {
            margin-bottom: 16px;
        }
        
        .summary-section-title {
            font-weight: 700;
            font-size: 0.9rem;
            margin-bottom: 10px;
            color: var(--text-primary);
        }
        
        .summary-stats {
            display: flex;
            gap: 12px;
        }
        
        .summary-stat {
            flex: 1;
            text-align: center;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 12px;
        }
        
        .summary-stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-purple);
        }
        
        .summary-stat-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 2px;
        }
        
        .summary-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .summary-list-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border-radius: 10px;
            font-size: 0.9rem;
        }
        
        .summary-list-item.suggestion {
            background: rgba(102, 126, 234, 0.1);
            border-left: 3px solid var(--accent-purple);
        }
        
        .summary-item-icon {
            font-size: 1.2rem;
            width: 28px;
            text-align: center;
        }
        
        /* Achievements */
        .achievements-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .achievements-progress {
            font-size: 0.85rem;
            color: var(--text-muted);
        }
        
        .achievements-progress-bar {
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            margin-bottom: 16px;
            overflow: hidden;
        }
        
        .achievements-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-gold), var(--accent-orange));
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        
        .achievements-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        
        .achievement-card {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 12px 8px;
            text-align: center;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .achievement-card.unlocked {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(255, 165, 0, 0.1));
            border: 1px solid var(--accent-gold);
        }
        
        .achievement-card.locked {
            opacity: 0.5;
        }
        
        .achievement-icon {
            font-size: 1.8rem;
            display: block;
            margin-bottom: 6px;
        }
        
        .achievement-card.locked .achievement-icon {
            filter: grayscale(100%);
        }
        
        .achievement-name {
            font-size: 0.75rem;
            font-weight: 600;
            margin-bottom: 2px;
            line-height: 1.2;
        }
        
        .achievement-desc {
            font-size: 0.65rem;
            color: var(--text-muted);
            line-height: 1.2;
        }
        
        .achievement-card.unlocked .achievement-desc {
            color: var(--accent-green);
        }
        
        /* Achievement unlock animation */
        @keyframes achievementPop {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .achievement-card.just-unlocked {
            animation: achievementPop 0.5s ease-out;
        }
        
        /* Install Banner */
        .install-banner {
            position: fixed;
            bottom: calc(70px + var(--safe-bottom));
            left: 12px;
            right: 12px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 16px;
            padding: 16px;
            z-index: 180;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
            display: none;
            animation: slideUp 0.3s ease-out;
            cursor: pointer;
            transition: transform 0.15s ease;
        }
        
        .install-banner:active {
            transform: scale(0.98);
        }
        
        @keyframes slideUp {
            from { transform: translateY(100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .install-banner.visible {
            display: block;
        }
        
        .install-banner-content {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .install-banner-icon {
            width: 40px;
            height: 40px;
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            font-size: 1.8rem;
            font-weight: 300;
            color: white;
        }
        
        .install-banner-text {
            flex: 1;
        }
        
        .install-banner-title {
            font-size: 1rem;
            font-weight: 700;
            color: white;
            margin-bottom: 4px;
        }
        
        .install-banner-desc {
            font-size: 0.85rem;
            color: rgba(255,255,255,0.85);
            line-height: 1.3;
        }
        
        .install-banner-desc .share-icon {
            display: inline-block;
            vertical-align: middle;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 4px;
            text-align: center;
            line-height: 18px;
            font-size: 12px;
            margin: 0 2px;
        }
        
        .install-banner-close {
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            color: white;
            font-size: 1rem;
            cursor: pointer;
            flex-shrink: 0;
        }
        
        .install-arrow-hint {
            display: none;
            align-items: center;
            justify-content: center;
            padding: 8px 0 4px 0;
            color: white;
            font-weight: 600;
            animation: bounce 1s ease-in-out infinite;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(4px); }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }
        
        /* ============ SETUP FLOW STYLES ============ */
        .setup-container {
            position: fixed;
            inset: 0;
            background: var(--bg-primary);
            z-index: 2000;
            display: none;
            flex-direction: column;
            --setup-surface: var(--bg-secondary);
            --setup-surface-2: var(--bg-tertiary);
            --setup-primary: #6366f1;
            --setup-primary-glow: rgba(99, 102, 241, 0.15);
            --setup-success: #22c55e;
            --setup-success-glow: rgba(34, 197, 94, 0.15);
            --setup-warning: #f59e0b;
            --setup-error: #ef4444;
            --setup-radius: 16px;
            --setup-radius-sm: 10px;
        }
        
        .setup-container.active {
            display: flex;
        }
        
        .setup-screen {
            display: none;
            flex-direction: column;
            flex: 1;
            min-height: 100vh;
            min-height: 100dvh;
            padding: 20px;
            padding-top: calc(var(--safe-top) + 20px);
            padding-bottom: calc(var(--safe-bottom) + 40px);
            overflow-y: auto;
            animation: setupFadeIn 0.3s ease;
        }
        
        .setup-screen.active {
            display: flex;
        }
        
        @keyframes setupFadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .setup-header {
            text-align: center;
            padding: 16px 0;
        }
        
        .setup-header-icon {
            font-size: 48px;
            margin-bottom: 12px;
        }
        
        .setup-header h1 {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 8px;
        }
        
        .setup-header p {
            color: var(--text-muted);
            font-size: 0.95rem;
            line-height: 1.4;
        }
        
        .setup-progress {
            display: flex;
            gap: 6px;
            padding: 12px 0;
        }
        
        .setup-progress-step {
            flex: 1;
            height: 4px;
            background: var(--border);
            border-radius: 2px;
            transition: background 0.3s;
        }
        
        .setup-progress-step.active {
            background: var(--setup-primary);
        }
        
        .setup-progress-step.complete {
            background: var(--setup-success);
        }
        
        .setup-spacer {
            flex: 1;
        }
        
        .setup-actions {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: auto;
            padding-top: 20px;
        }
        
        .setup-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 16px 24px;
            border: none;
            border-radius: var(--setup-radius);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
            touch-action: manipulation;
        }
        
        .setup-btn-primary {
            background: var(--setup-primary);
            color: white;
        }
        
        .setup-btn-primary:active {
            transform: scale(0.98);
        }
        
        .setup-btn-secondary {
            background: var(--setup-surface-2);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }
        
        .setup-btn-ghost {
            background: transparent;
            color: var(--text-muted);
        }
        
        .setup-btn-success {
            background: var(--setup-success);
            color: white;
        }
        
        .setup-btn-outline {
            background: transparent;
            border: 2px solid var(--border);
            color: var(--text-primary);
        }
        
        .setup-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .setup-back-link {
            color: var(--text-muted);
            font-size: 0.9rem;
            text-align: center;
            padding: 12px;
            cursor: pointer;
        }
        
        /* Game Selection Grid */
        .setup-game-grid-inner {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 16px;
        }
        
        #setup-game-grid .setup-section-header {
            margin-top: 16px;
        }
        
        #setup-game-grid .setup-section-header:first-child {
            margin-top: 0;
        }
        
        .setup-game-btn {
            background: var(--setup-surface);
            border: 2px solid var(--border);
            border-radius: var(--setup-radius-sm);
            padding: 14px 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            touch-action: manipulation;
        }
        
        .setup-game-btn:active,
        .setup-game-btn.selected {
            border-color: var(--setup-primary);
            background: var(--setup-primary-glow);
        }
        
        .setup-game-btn .icon {
            font-size: 1.8rem;
            margin-bottom: 6px;
        }
        
        .setup-game-btn .name {
            font-size: 0.8rem;
            font-weight: 500;
        }
        
        .setup-game-btn .publisher {
            font-size: 0.65rem;
            color: var(--text-muted);
            margin-top: 2px;
        }
        
        .setup-game-btn .check {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 18px;
            height: 18px;
            background: var(--setup-success);
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
        }
        
        .setup-game-btn.selected .check {
            display: flex;
        }
        
        .setup-section-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 20px 0 12px;
        }
        
        .setup-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px 0 12px;
        }
        
        .setup-section-header:first-child {
            margin-top: 0;
        }
        
        .setup-section-header .setup-section-title {
            margin: 0;
        }
        
        .setup-select-all {
            font-size: 0.75rem;
            color: var(--setup-primary);
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }
        
        .setup-select-all:hover {
            background: var(--setup-primary-glow);
        }
        
        .setup-select-all:active {
            opacity: 0.7;
        }
        
        /* Publisher Config */
        .setup-publisher-card {
            background: var(--setup-surface);
            border-radius: var(--setup-radius);
            padding: 16px;
            margin-bottom: 14px;
            border: 1px solid var(--border);
        }
        
        .setup-publisher-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 14px;
        }
        
        .setup-publisher-header .icon {
            font-size: 1.5rem;
        }
        
        .setup-publisher-header .name {
            font-weight: 600;
            flex: 1;
        }
        
        .setup-publisher-header .count {
            font-size: 0.8rem;
            color: var(--text-muted);
        }
        
        .setup-config-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .setup-config-option {
            flex: 1;
            padding: 12px;
            background: var(--setup-surface-2);
            border: 2px solid var(--border);
            border-radius: var(--setup-radius-sm);
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85rem;
        }
        
        .setup-config-option:active,
        .setup-config-option.selected {
            border-color: var(--setup-primary);
            background: var(--setup-primary-glow);
        }
        
        /* Enhance Card */
        .setup-enhance-card {
            background: var(--setup-surface);
            border-radius: var(--setup-radius);
            padding: 20px;
            margin: 16px 0;
            border: 1px solid var(--border);
        }
        
        .setup-enhance-card h3 {
            font-size: 1.1rem;
            margin-bottom: 10px;
        }
        
        .setup-enhance-card p {
            color: var(--text-muted);
            font-size: 0.9rem;
            line-height: 1.5;
            margin-bottom: 16px;
        }
        
        .setup-enhance-benefits {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .setup-benefit {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
        }
        
        .setup-benefit .icon {
            color: var(--setup-success);
            font-weight: bold;
        }
        
        /* Screenshot Card */
        .setup-screenshot-card {
            background: var(--setup-surface);
            border-radius: var(--setup-radius);
            padding: 16px;
            margin-bottom: 14px;
            border: 1px solid var(--border);
        }
        
        .setup-screenshot-card-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 10px;
        }
        
        .setup-screenshot-card-header .icon {
            font-size: 2rem;
        }
        
        .setup-screenshot-card-header h3 {
            font-size: 1rem;
            flex: 1;
        }
        
        .setup-screenshot-card-header .status {
            font-size: 0.75rem;
            padding: 4px 10px;
            border-radius: 12px;
            background: var(--setup-surface-2);
            color: var(--text-muted);
        }
        
        .setup-screenshot-card-header .status.done {
            background: var(--setup-success-glow);
            color: var(--setup-success);
        }
        
        .setup-screenshot-instructions {
            background: var(--setup-surface-2);
            border-radius: var(--setup-radius-sm);
            padding: 12px;
            margin-bottom: 12px;
        }
        
        .setup-screenshot-instructions p {
            font-size: 0.85rem;
            color: var(--text-muted);
            line-height: 1.4;
        }
        
        .setup-screenshot-actions {
            display: flex;
            gap: 10px;
        }
        
        .setup-screenshot-actions .setup-btn {
            flex: 1;
            padding: 12px;
            font-size: 0.9rem;
        }
        
        /* Launch Feedback */
        .setup-launch-feedback {
            text-align: center;
            padding: 20px 0;
        }
        
        .setup-launch-feedback h3 {
            font-size: 1.3rem;
            margin-bottom: 8px;
        }
        
        .setup-launch-feedback > p {
            color: var(--text-muted);
            font-size: 0.9rem;
            margin-bottom: 24px;
        }
        
        .setup-feedback-options {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .setup-feedback-btn {
            display: flex;
            align-items: center;
            gap: 14px;
            background: var(--setup-surface);
            border: 2px solid var(--border);
            border-radius: var(--setup-radius);
            padding: 16px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }
        
        .setup-feedback-btn:active {
            border-color: var(--setup-primary);
            background: var(--setup-primary-glow);
        }
        
        .setup-feedback-btn .icon {
            font-size: 1.8rem;
        }
        
        .setup-feedback-btn .text h4 {
            font-size: 1rem;
            margin-bottom: 2px;
        }
        
        .setup-feedback-btn .text p {
            font-size: 0.8rem;
            color: var(--text-muted);
        }
        
        /* Fix Options */
        .setup-fix-option {
            display: flex;
            align-items: center;
            gap: 14px;
            background: var(--setup-surface);
            border: 2px solid var(--border);
            border-radius: var(--setup-radius);
            padding: 16px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .setup-fix-option:active {
            border-color: var(--setup-primary);
            background: var(--setup-primary-glow);
        }
        
        .setup-fix-option .icon {
            font-size: 1.8rem;
        }
        
        .setup-fix-option .text {
            flex: 1;
        }
        
        .setup-fix-option .text h4 {
            font-size: 0.95rem;
            margin-bottom: 2px;
        }
        
        .setup-fix-option .text p {
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        
        .setup-fix-option .arrow {
            font-size: 1.1rem;
            opacity: 0.5;
        }
        
        /* Custom URL Input */
        .setup-custom-url-card {
            background: var(--setup-surface);
            border-radius: var(--setup-radius);
            padding: 20px;
            margin: 16px 0;
        }
        
        .setup-input-label {
            display: block;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            margin-bottom: 8px;
            text-transform: uppercase;
        }
        
        .setup-text-input {
            width: 100%;
            padding: 14px 16px;
            background: var(--setup-surface-2);
            border: 2px solid var(--border);
            border-radius: var(--setup-radius-sm);
            color: var(--text-primary);
            font-size: 1rem;
            outline: none;
            transition: border-color 0.2s;
        }
        
        .setup-text-input:focus {
            border-color: var(--setup-primary);
        }
        
        .setup-text-input::placeholder {
            color: var(--text-muted);
            opacity: 0.6;
        }
        
        .setup-input-hint {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 10px;
            line-height: 1.4;
        }
        
        /* Upload Area */
        .setup-upload-area {
            border: 2px dashed var(--border);
            border-radius: var(--setup-radius);
            padding: 24px 16px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .setup-upload-area:active {
            border-color: var(--setup-primary);
            background: var(--setup-primary-glow);
        }
        
        .setup-upload-area.has-image {
            padding: 10px;
            border-style: solid;
            border-color: var(--setup-success);
        }
        
        .setup-upload-area .icon {
            font-size: 2rem;
            margin-bottom: 8px;
        }
        
        .setup-upload-area p {
            font-size: 0.9rem;
            color: var(--text-muted);
        }
        
        .setup-upload-preview {
            max-width: 100%;
            max-height: 180px;
            border-radius: var(--setup-radius-sm);
            object-fit: contain;
        }
        
        #setup-file-input {
            display: none;
        }
        
        /* Stats Preview */
        .setup-stats-preview {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 16px 0;
        }
        
        .setup-stat-box {
            background: var(--setup-surface-2);
            padding: 12px;
            border-radius: var(--setup-radius-sm);
            text-align: center;
        }
        
        .setup-stat-box .value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--setup-primary);
        }
        
        .setup-stat-box .label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }
        
        /* Sharing Options */
        .setup-sharing-option {
            display: flex;
            align-items: center;
            gap: 14px;
            background: var(--setup-surface);
            border: 2px solid var(--border);
            border-radius: var(--setup-radius);
            padding: 14px 16px;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 10px;
        }
        
        .setup-sharing-option:active,
        .setup-sharing-option.selected {
            border-color: var(--setup-primary);
            background: var(--setup-primary-glow);
        }
        
        .setup-sharing-option .icon {
            font-size: 1.5rem;
        }
        
        .setup-sharing-option .text {
            flex: 1;
        }
        
        .setup-sharing-option .text h4 {
            font-size: 0.95rem;
        }
        
        .setup-sharing-option .text p {
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        
        .setup-sharing-option .check {
            width: 22px;
            height: 22px;
            border: 2px solid var(--border);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
        }
        
        .setup-sharing-option.selected .check {
            background: var(--setup-primary);
            border-color: var(--setup-primary);
            color: white;
        }
        
        .setup-social-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin: 16px 0;
        }
        
        .setup-social-btn {
            background: var(--setup-surface);
            border: 2px solid var(--border);
            border-radius: var(--setup-radius-sm);
            padding: 12px 6px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .setup-social-btn:active,
        .setup-social-btn.selected {
            border-color: var(--setup-primary);
            background: var(--setup-primary-glow);
        }
        
        .setup-social-btn .icon {
            font-size: 1.5rem;
            margin-bottom: 2px;
        }
        
        .setup-social-btn .name {
            font-size: 0.65rem;
        }
        
        /* Final List */
        .setup-final-game {
            display: flex;
            align-items: center;
            gap: 12px;
            background: var(--setup-surface);
            border-radius: var(--setup-radius-sm);
            padding: 12px;
            margin-bottom: 8px;
        }
        
        .setup-final-game .icon {
            font-size: 1.8rem;
        }
        
        .setup-final-game .info {
            flex: 1;
        }
        
        .setup-final-game .name {
            font-size: 0.95rem;
            font-weight: 500;
        }
        
        .setup-final-game .meta {
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        
        .setup-final-game .launch {
            font-size: 1.3rem;
            opacity: 0.6;
            cursor: pointer;
            padding: 8px;
        }
        
        /* Success Icon */
        .setup-success-icon {
            width: 80px;
            height: 80px;
            background: var(--setup-success);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            margin: 20px auto;
            animation: setupPopIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        @keyframes setupPopIn {
            0% { transform: scale(0); }
            100% { transform: scale(1); }
        }
        
        /* Loading */
        .setup-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
        }
        
        .setup-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--setup-primary);
            border-radius: 50%;
            animation: setupSpin 1s linear infinite;
        }
        
        @keyframes setupSpin {
            to { transform: rotate(360deg); }
        }
        
        .setup-loading p {
            margin-top: 14px;
            color: var(--text-muted);
        }
        
        .setup-scroll-content {
            flex: 1;
            overflow-y: auto;
            margin: 0 -20px;
            padding: 0 20px;
        }
        
        .setup-mini-chip {
            display: inline-block;
            background: var(--setup-surface-2);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            margin: 4px;
        }
        
        /* ============ TUTORIAL SYSTEM ============ */
        .tutorial-overlay {
            position: fixed;
            inset: 0;
            background: transparent;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .tutorial-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .tutorial-spotlight {
            position: absolute;
            border-radius: 12px;
            background: transparent;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.85);
            transition: all 0.4s ease;
            pointer-events: none;
            /* Add visible border for dark mode */
            border: 3px solid var(--accent-purple);
            outline: 2px solid rgba(102, 126, 234, 0.5);
        }
        
        .tutorial-spotlight.pulse {
            animation: tutorialPulse 2s ease-in-out infinite;
        }
        
        @keyframes tutorialPulse {
            0%, 100% { 
                box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.85), 0 0 15px 5px rgba(102, 126, 234, 0.6); 
                border-color: var(--accent-purple);
            }
            50% { 
                box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.85), 0 0 25px 10px rgba(102, 126, 234, 0.8); 
                border-color: #8b9cf4;
            }
        }
        
        .tutorial-card {
            position: absolute;
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 20px;
            max-width: 320px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border);
            z-index: 2001;
            animation: tutorialSlideIn 0.3s ease;
        }
        
        @keyframes tutorialSlideIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .tutorial-card-arrow {
            position: absolute;
            width: 0;
            height: 0;
            border: 10px solid transparent;
        }
        
        .tutorial-card-arrow.top {
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            border-bottom-color: var(--bg-secondary);
        }
        
        .tutorial-card-arrow.bottom {
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            border-top-color: var(--bg-secondary);
        }
        
        .tutorial-card-arrow.left {
            left: -20px;
            top: 50%;
            transform: translateY(-50%);
            border-right-color: var(--bg-secondary);
        }
        
        .tutorial-card-arrow.right {
            right: -20px;
            top: 50%;
            transform: translateY(-50%);
            border-left-color: var(--bg-secondary);
        }
        
        .tutorial-step-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 12px;
        }
        
        .tutorial-step-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--border);
            transition: all 0.2s;
        }
        
        .tutorial-step-dot.active {
            background: var(--accent-purple);
            width: 20px;
            border-radius: 4px;
        }
        
        .tutorial-step-dot.complete {
            background: var(--accent-green);
        }
        
        .tutorial-title {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .tutorial-title .icon {
            font-size: 1.3rem;
        }
        
        .tutorial-content {
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.5;
            margin-bottom: 16px;
        }
        
        .tutorial-content strong {
            color: var(--text-primary);
        }
        
        .tutorial-tip {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 10px 12px;
            margin: 12px 0;
            font-size: 0.85rem;
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }
        
        .tutorial-tip .tip-icon {
            flex-shrink: 0;
        }
        
        .tutorial-actions {
            display: flex;
            gap: 10px;
            margin-top: 16px;
        }
        
        .tutorial-btn {
            flex: 1;
            padding: 12px 16px;
            border-radius: 10px;
            border: none;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .tutorial-btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .tutorial-btn-secondary:active {
            background: var(--bg-hover);
        }
        
        .tutorial-btn-primary {
            background: var(--accent-purple);
            color: white;
        }
        
        .tutorial-btn-primary:active {
            opacity: 0.8;
        }
        
        .tutorial-skip {
            text-align: center;
            margin-top: 12px;
        }
        
        .tutorial-skip-link {
            color: var(--text-muted);
            font-size: 0.85rem;
            cursor: pointer;
            text-decoration: underline;
        }
        
        /* Tutorial Welcome Modal */
        .tutorial-welcome {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 28px 24px;
            max-width: 340px;
            width: 90%;
            text-align: center;
            z-index: 2001;
            box-shadow: 0 16px 48px rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border);
        }
        
        .tutorial-welcome-icon {
            font-size: 3rem;
            margin-bottom: 16px;
        }
        
        .tutorial-welcome h2 {
            font-size: 1.3rem;
            margin-bottom: 12px;
        }
        
        .tutorial-welcome p {
            color: var(--text-secondary);
            font-size: 0.95rem;
            line-height: 1.5;
            margin-bottom: 20px;
        }
        
        .tutorial-welcome-features {
            text-align: left;
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 14px 16px;
            margin-bottom: 20px;
        }
        
        .tutorial-welcome-feature {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            font-size: 0.9rem;
        }
        
        .tutorial-welcome-feature:not(:last-child) {
            border-bottom: 1px solid var(--border);
        }
        
        .tutorial-time {
            color: var(--text-muted);
            font-size: 0.85rem;
            margin-bottom: 16px;
        }
        /* Floating Help Button (was Feedback Button) */
        .uat-feedback-btn {
            position: fixed;
            bottom: 80px;
            left: 12px;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            z-index: 999;
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .uat-feedback-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(99, 102, 241, 0.5);
        }
        .uat-feedback-btn:active {
            transform: scale(0.95);
        }
        .uat-feedback-btn.hidden {
            display: none;
        }
        
        /* Feedback Mode Indicator - v1.2.77: Hidden permanently */
        .uat-mode-badge {
            display: none !important;
        }
        
        /* Debug Log Panel */
        .debug-log-preview {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            max-height: 150px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        .debug-log-preview .log-entry {
            padding: 2px 0;
            border-bottom: 1px solid var(--border-color);
        }
        .debug-log-preview .log-entry:last-child {
            border-bottom: none;
        }
        .debug-log-preview .log-time {
            color: var(--text-muted);
            margin-right: 8px;
        }
        .debug-log-preview .log-action {
            color: var(--text-primary);
        }

        /* Clipboard Nudge Banner (iOS gesture-deferred) */
        .clipboard-nudge {
            position: fixed;
            bottom: calc(70px + var(--safe-bottom));
            left: 16px;
            right: 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--accent-purple);
            border-radius: 12px;
            padding: 12px 16px;
            display: none;
            align-items: center;
            gap: 12px;
            z-index: 500;
            animation: slideUpNudge 0.3s ease;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        
        .clipboard-nudge-text {
            flex: 1;
            font-size: 0.9rem;
            color: var(--text-primary);
        }
        
        .clipboard-nudge-record {
            background: var(--accent-purple);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 0.85rem;
            cursor: pointer;
            white-space: nowrap;
        }
        
        .clipboard-nudge-dismiss {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.2rem;
            padding: 4px 8px;
            cursor: pointer;
            line-height: 1;
        }
        
        @keyframes slideUpNudge {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        /* ============ HELP SYSTEM ============ */
        .help-sheet-content {
            display: flex;
            flex-direction: column;
            height: 85vh;
            max-height: 85vh;
        }

        .help-search-container {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
            position: relative;
        }

        .help-search-input {
            width: 100%;
            padding: 10px 12px 10px 36px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--surface);
            color: var(--text);
            font-size: 14px;
            outline: none;
            box-sizing: border-box;
        }

        .help-search-input:focus {
            border-color: var(--primary);
        }

        .help-search-input::placeholder {
            color: var(--text-secondary);
        }

        .help-search-icon {
            position: absolute;
            left: 28px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
            pointer-events: none;
            font-size: 14px;
        }

        .help-content {
            flex: 1;
            overflow-y: auto;
            padding: 8px 0;
        }

        /* Category Accordion */
        .help-category {
            border-bottom: 1px solid var(--border);
        }

        .help-category-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 16px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .help-category-header:hover {
            background: var(--surface-hover);
        }

        .help-category-header:active {
            background: rgba(139, 92, 246, 0.1);
        }

        .help-category-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 500;
        }

        .help-category-icon {
            font-size: 18px;
        }

        .help-category-arrow {
            color: var(--text-secondary);
            transition: transform 0.2s;
            font-size: 12px;
        }

        .help-category.expanded .help-category-arrow {
            transform: rotate(90deg);
        }

        .help-category-questions {
            display: none;
            padding: 0 16px 12px 44px;
        }

        .help-category.expanded .help-category-questions {
            display: block;
        }

        /* FAQ Item */
        .help-faq-item {
            border-radius: 8px;
            margin-bottom: 6px;
            overflow: hidden;
        }

        .help-faq-question {
            padding: 10px 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 14px;
            color: var(--text);
            background: var(--surface);
            border-radius: 8px;
            transition: background 0.15s;
            gap: 8px;
        }

        .help-faq-question:hover {
            background: var(--surface-hover);
        }

        .help-faq-question span:first-child {
            flex: 1;
        }

        .help-faq-item.expanded .help-faq-question {
            border-radius: 8px 8px 0 0;
            background: var(--primary);
            color: white;
        }

        .help-faq-answer {
            display: none;
            padding: 12px;
            background: var(--surface);
            border-radius: 0 0 8px 8px;
            font-size: 14px;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .help-faq-item.expanded .help-faq-answer {
            display: block;
        }

        .help-faq-answer strong {
            color: var(--text);
            font-weight: 600;
        }

        .help-faq-answer code {
            background: var(--surface-hover);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 13px;
        }

        .help-faq-answer a {
            color: var(--primary);
            text-decoration: none;
        }

        .help-faq-answer p {
            margin: 0 0 12px 0;
        }

        .help-faq-answer p:last-child {
            margin-bottom: 0;
        }

        /* Search Results */
        .help-search-results {
            padding: 8px 16px;
        }

        .help-search-results-header {
            font-size: 12px;
            color: var(--text-secondary);
            padding: 8px 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .help-no-results {
            text-align: center;
            padding: 32px 16px;
            color: var(--text-secondary);
        }

        .help-no-results-icon {
            font-size: 48px;
            margin-bottom: 12px;
        }

        /* Ask AI Section */
        .help-ask-ai {
            margin: 16px;
            padding: 16px;
            background: linear-gradient(135deg, var(--primary) 0%, #7c3aed 100%);
            border-radius: 12px;
            text-align: center;
            flex-shrink: 0;
        }

        .help-ask-ai-title {
            color: white;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .help-ask-ai-btn {
            background: white;
            color: var(--primary);
            border: none;
            padding: 10px 24px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: transform 0.15s, box-shadow 0.15s;
        }

        .help-ask-ai-btn:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        /* AI Help Sheet */
        .ai-help-sheet-content {
            display: flex;
            flex-direction: column;
            height: 70vh;
            max-height: 70vh;
        }

        .ai-help-body {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 16px;
            overflow: hidden;
        }

        .ai-help-intro {
            text-align: center;
            padding: 12px;
            background: var(--surface);
            border-radius: 12px;
            margin-bottom: 16px;
        }

        .ai-help-intro-icon {
            font-size: 32px;
            margin-bottom: 8px;
        }

        .ai-help-intro-text {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .ai-help-input-area {
            margin-bottom: 16px;
        }

        .ai-help-input {
            width: 100%;
            padding: 12px 14px;
            border: 1px solid var(--border);
            border-radius: 12px;
            background: var(--surface);
            color: var(--text);
            font-size: 15px;
            resize: none;
            min-height: 60px;
            max-height: 100px;
            font-family: inherit;
        }

        .ai-help-input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .ai-help-input::placeholder {
            color: var(--text-muted);
        }

        .ai-help-submit-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 10px;
        }

        .ai-help-cost {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .ai-help-ask-btn {
            background: linear-gradient(135deg, var(--primary) 0%, #7c3aed 100%);
            color: white;
            border: none;
            padding: 10px 24px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: transform 0.15s, opacity 0.15s;
        }

        .ai-help-ask-btn:hover:not(:disabled) {
            transform: scale(1.02);
        }

        .ai-help-ask-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .ai-help-response-area {
            flex: 1;
            overflow-y: auto;
            display: none;
        }

        .ai-help-response-area.visible {
            display: block;
        }

        .ai-help-response {
            background: var(--surface);
            border-radius: 12px;
            padding: 16px;
            font-size: 14px;
            line-height: 1.6;
            color: var(--text);
        }

        .ai-help-response-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            font-weight: 600;
            color: var(--primary);
        }

        .ai-help-response-text {
            white-space: pre-wrap;
        }

        .ai-help-response-text strong {
            color: var(--text);
            font-weight: 600;
        }

        .ai-help-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 24px;
            color: var(--text-secondary);
        }

        .ai-help-error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 12px;
            padding: 12px 16px;
            color: #ef4444;
            font-size: 14px;
        }

        .ai-help-footer {
            padding: 12px 16px;
            border-top: 1px solid var(--border);
            text-align: center;
        }

        .ai-help-footer-text {
            font-size: 12px;
            color: var(--text-muted);
        }

        .ai-help-ask-another {
            margin-top: 12px;
            text-align: center;
        }

        .ai-help-another-btn {
            background: var(--surface);
            color: var(--primary);
            border: 1px solid var(--primary);
            padding: 8px 16px;
            border-radius: 16px;
            font-size: 13px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .ai-help-another-btn:hover {
            background: var(--surface-hover);
        }

        /* Bottom Actions */
        .help-bottom-actions {
            border-top: 1px solid var(--border);
            padding: 8px 0;
            flex-shrink: 0;
        }

        .help-action-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .help-action-item:hover {
            background: var(--surface-hover);
        }

        .help-action-icon {
            font-size: 18px;
            width: 24px;
            text-align: center;
        }

        .help-action-text {
            flex: 1;
            font-size: 14px;
        }

        .help-action-badge {
            background: var(--accent-red);
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: 600;
        }

        /* Menu badge for Help */
        .help-menu-badge {
            width: 8px;
            height: 8px;
            background: var(--accent-red);
            border-radius: 50%;
            display: inline-block;
            margin-left: 6px;
        }

    </style>
</head>
<body>
    <!-- Floating Help Button Badge - Hidden, no longer needed -->
    <div class="uat-mode-badge" id="feedback-mode-badge" style="display:none;">â“ Help</div>
    
    <!-- Test Game Shelf Badge (auto-shows when on test repo) -->
    <div class="uat-mode-badge" id="test-gameshelf-badge" style="display:none; left:10px; right:auto; background: linear-gradient(135deg, #f90, #f60);">ðŸ”§ TEST BUILD</div>
    
    <!-- Floating Help Button -->
    <button class="uat-feedback-btn hidden" id="floating-help-btn" onclick="showHelp()" title="Help">
        â“
    </button>
    
    <!-- Header -->
    <header class="header">
        <div class="logo">
            <svg viewBox="0 0 110 80" width="32" height="23" xmlns="http://www.w3.org/2000/svg" style="vertical-align: middle;">
                <defs><linearGradient id="gsLogoG" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#667eea"/><stop offset="100%" style="stop-color:#5568d8"/></linearGradient><linearGradient id="gsLogoS" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#9061f9"/><stop offset="100%" style="stop-color:#764ba2"/></linearGradient></defs>
                <g transform="rotate(10, 75, 40)"><rect x="55" y="10" width="48" height="55" rx="6" fill="url(#gsLogoS)"/><circle cx="55" cy="37" r="10" fill="var(--bg-primary, #1a1a2e)"/><text x="80" y="48" font-family="Arial" font-size="30" font-weight="bold" fill="white" text-anchor="middle">S</text></g>
                <g transform="rotate(-10, 35, 40)"><rect x="5" y="10" width="48" height="55" rx="6" fill="url(#gsLogoG)"/><circle cx="53" cy="37" r="10" fill="url(#gsLogoG)"/><text x="28" y="48" font-family="Arial" font-size="30" font-weight="bold" fill="white" text-anchor="middle">G</text></g>
            </svg>
            <div style="display: flex; flex-direction: column; line-height: 1.2;">
                <span>Game Shelf</span>
                <span style="font-size: 0.55rem; color: var(--accent-orange); font-weight: 600;">v1.3.2</span>
            </div>
        </div>
        <div class="header-right">
            <button class="header-btn" id="header-share-btn" onclick="quickShareRecap()" title="Share Today's Results">ðŸ“¤</button>
            <button class="header-btn hint-btn" id="header-hint-btn" onclick="openHintSheet()" title="Get AI Hints">ðŸ’¡</button>
            <button class="menu-btn" onclick="toggleSettingsMenu()">â˜°</button>
        </div>
    </header>
    
    <!-- Settings Overlay -->
    <div class="settings-overlay" id="settings-overlay" onclick="toggleSettingsMenu()"></div>
    
    <!-- Slide-out Settings Menu -->
    <div class="settings-menu" id="settings-menu">
        <div class="settings-header">
            <h2>â˜° Menu</h2>
            <button class="settings-close" onclick="toggleSettingsMenu()">âœ•</button>
        </div>
        <div class="settings-body">
            <!-- Wallet Display - at top of menu (tappable) -->
            <div class="settings-section" style="padding: 16px; background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1)); border-radius: 12px; margin: 0 16px 16px; cursor: pointer;" onclick="showWalletOptionsSheet()">
                <div style="display: flex; justify-content: center; gap: 24px; font-size: 1.1rem;">
                    <span class="tokens" style="display: flex; align-items: center; gap: 6px;">ðŸ’Ž <span id="token-count" style="font-weight: 700;">0</span></span>
                    <span class="coins" style="display: flex; align-items: center; gap: 6px;">ðŸª™ <span id="coin-count" style="font-weight: 700;">0</span></span>
                </div>
                <div style="text-align: center; font-size: 0.75rem; color: var(--text-muted); margin-top: 8px;">Tap to manage wallet</div>
            </div>
            
            <!-- Settings Submenu Toggle - NOW AT TOP -->
            <div class="settings-section" style="padding-bottom: 0;">
                <div class="settings-submenu-toggle" id="settings-submenu-toggle" onclick="toggleSettingsSubmenu()">
                    <div class="toggle-left">
                        <span class="toggle-icon">âš™ï¸</span>
                        <span class="toggle-label">Settings & Data</span>
                    </div>
                    <span class="toggle-arrow">â–¼</span>
                </div>
                
                <!-- Settings Submenu Content -->
                <div class="settings-submenu-content" id="settings-submenu-content">
                    <!-- Theme -->
                    <div class="settings-section">
                        <div class="settings-section-title">ðŸŽ¨ Theme</div>
                        <div class="theme-options">
                            <div class="theme-option active" id="theme-dark" onclick="setTheme('dark')">
                                <div class="label">ðŸŒ™ Dark</div>
                            </div>
                            <div class="theme-option" id="theme-light" onclick="setTheme('light')">
                                <div class="label">â˜€ï¸ Light</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Sound -->
                    <div class="settings-section">
                        <div class="settings-section-title">ðŸ”Š Sound</div>
                        <div class="settings-toggle-row">
                            <label>
                                <span class="icon">ðŸ””</span>
                                <span>Sound Effects</span>
                            </label>
                            <input type="checkbox" id="sound-toggle" onchange="toggleSound(this.checked)">
                        </div>
                        <div class="volume-row">
                            <span class="icon">ðŸ”‰</span>
                            <input type="range" id="sound-volume" min="0" max="100" value="50" 
                                   oninput="setVolume(this.value)" onchange="setVolume(this.value)">
                            <span class="icon">ðŸ”Š</span>
                        </div>
                        <a class="settings-link" onclick="showSoundCustomizer()">
                            <span class="icon">ðŸŽµ</span>
                            Customize Sounds
                        </a>
                    </div>
                    
                    <!-- Logging Settings - NEW -->
                    <div class="settings-section">
                        <div class="settings-section-title">ðŸ“‹ Game Logging</div>
                        <div class="settings-toggle-row">
                            <label>
                                <span class="icon">âš¡</span>
                                <span>Auto-Log Results</span>
                            </label>
                            <input type="checkbox" id="autolog-toggle" onchange="toggleAutoLog(this.checked)" checked>
                        </div>
                        <p style="font-size: 0.75rem; color: var(--text-muted); margin: 4px 0 0 36px;">
                            Automatically log games when detected from clipboard
                        </p>
                    </div>
                    
                    <!-- Game Launch Preferences -->
                    <div class="settings-section">
                        <div class="settings-section-title">ðŸš€ Game Launch</div>
                        <a class="settings-link" onclick="showLaunchPrefsManager()">
                            <span class="icon">ðŸ“±</span>
                            Manage App vs Browser
                        </a>
                        <p style="font-size: 0.75rem; color: var(--text-muted); margin: 4px 0 0 36px;">
                            Change how games open (app or browser)
                        </p>
                    </div>
                    
                    <!-- Activity Summary -->
                    <div class="settings-section">
                        <div class="settings-section-title">ðŸ‘‹ Activity Summary</div>
                        <div class="settings-toggle-row">
                            <label>
                                <span class="icon">ðŸ“Š</span>
                                <span>Show on Return</span>
                            </label>
                            <input type="checkbox" id="activity-summary-toggle" onchange="toggleActivitySummary(this.checked)">
                        </div>
                    </div>
                    
                    <!-- Daily Goal -->
                    <div class="settings-section">
                        <div class="settings-section-title">ðŸŽ¯ Daily Goal</div>
                        <a class="settings-link" onclick="resetDailyGoal()">
                            <span class="icon">ðŸŽ¯</span>
                            Set Daily Goal
                        </a>
                    </div>
                    
                    <!-- Data -->
                    <div class="settings-section">
                        <div class="settings-section-title">ðŸ“¦ Data</div>
                        <!-- Export/Import hidden for now - using cloud sync instead
                        <a class="settings-link" onclick="exportData()">
                            <span class="icon">ðŸ“¤</span>
                            Export Data
                        </a>
                        <a class="settings-link" onclick="importData()">
                            <span class="icon">ðŸ“¥</span>
                            Import Data
                        </a>
                        -->
                        <a class="settings-link" onclick="forceAppUpdate()">
                            <span class="icon">ðŸ”„</span>
                            Force Update Check
                        </a>
                        <p class="settings-desc">Check for new version and reload</p>
                        <a class="settings-link" onclick="clearAllData()" style="color: var(--accent-red);">
                            <span class="icon">ðŸ—‘ï¸</span>
                            Reset All Data
                        </a>
                    </div>
                    
                    <!-- Developer -->
                    <div class="settings-section">
                        <div class="settings-section-title">ðŸ§ª Developer</div>
                        <div class="settings-toggle-row">
                            <label>
                                <span class="icon">ðŸ”¬</span>
                                <span>Test Mode</span>
                            </label>
                            <input type="checkbox" id="test-mode-toggle" onchange="toggleTestMode(this.checked)">
                        </div>
                        <p style="font-size: 0.75rem; color: var(--text-muted); margin: 4px 0 0 36px;">
                            Use test repos for GS Originals (Quotle, Slate, Rungs, Word Boxing)
                        </p>
                        
                        <div class="settings-toggle-row" style="margin-top: 12px;">
                            <label>
                                <span class="icon">â“</span>
                                <span>Help Button</span>
                            </label>
                            <input type="checkbox" id="feedback-mode-toggle" onchange="toggleHelpButton(this.checked)">
                        </div>
                        <p style="font-size: 0.75rem; color: var(--text-muted); margin: 4px 0 0 36px;">
                            Show floating help button for quick access
                        </p>
                        
                        <a class="settings-link" onclick="resetPurchaseLimits()" style="margin-top: 12px;">
                            <span class="icon">ðŸ§¹</span>
                            Reset Purchase Limits
                        </a>
                        <p class="settings-desc">Clear purchase history after data reset (for testing)</p>
                    </div>
                </div>
            </div>
            
            <!-- Account - Moved up for prominence -->
            <div class="settings-section">
                <div class="settings-section-title">â˜ï¸ Account</div>
                <div id="menu-account-section">
                    <a class="settings-link" onclick="signInWithGoogle()">
                        <span class="icon">ðŸ”</span>
                        <span id="auth-menu-text">Sign in with Google</span>
                    </a>
                    <p class="settings-desc">Save progress across devices</p>
                </div>
            </div>
            
            <!-- My Games -->
            <div class="settings-section">
                <div class="settings-section-title">ðŸŽ® My Games</div>
                <a class="settings-link" onclick="startSetupFlow(); toggleSettingsMenu()">
                    <span class="icon">âš™ï¸</span>
                    Reconfigure Games
                </a>
                <p class="settings-desc">Change your game selection & preferences</p>
            </div>
            
            <!-- Achievements -->
            <div class="settings-section">
                <div class="settings-section-title">ðŸ† Achievements</div>
                <a class="settings-link" onclick="showAchievements()">
                    <span class="icon">ðŸ†</span>
                    View Achievements
                </a>
                <p class="settings-desc">Track your progress & unlock badges</p>
            </div>
            
            <!-- Invite Friends -->
            <div class="settings-section">
                <div class="settings-section-title">ðŸŽ Invite Friends</div>
                <a class="settings-link" onclick="showReferralSheet()">
                    <span class="icon">ðŸ“¨</span>
                    Share & Earn Tokens
                </a>
                <p class="settings-desc">Get ðŸŽŸï¸ 110 tokens per friend + auto-connect!</p>
            </div>
            
            <!-- Rewards Shop -->
            <div class="settings-section">
                <div class="settings-section-title">ðŸ›ï¸ Rewards Shop</div>
                <a class="settings-link" onclick="showMerchStore()">
                    <span class="icon">ðŸ›ï¸</span>
                    Redeem Rewards
                </a>
                <p class="settings-desc">Use coins for rewards & gifts</p>
            </div>
            
            <!-- Help -->
            <div class="settings-section">
                <div class="settings-section-title">
                    â“ Help
                    <span class="help-menu-badge" id="help-menu-badge" style="display: none;"></span>
                </div>
                <a class="settings-link" onclick="showHelp()">
                    <span class="icon">â“</span>
                    FAQs & Support
                    <span id="faq-menu-badge" style="display: none; background: var(--accent-red); color: white; font-size: 0.65rem; padding: 2px 6px; border-radius: 10px; margin-left: auto;">NEW</span>
                </a>
                <p class="settings-desc">Answers, tutorials, feedback & more</p>
            </div>
        </div>
        <div class="settings-footer">
            <div class="settings-version">Game Shelf PWA v1.3.4</div>
        </div>
    </div>
    
    <!-- Tutorial Overlay -->
    <div class="tutorial-overlay" id="tutorial-overlay">
        <!-- Welcome Screen (shown first) -->
        <div class="tutorial-welcome" id="tutorial-welcome">
            <div class="tutorial-welcome-icon">
                <svg viewBox="0 0 100 100" width="64" height="64" xmlns="http://www.w3.org/2000/svg">
                    <defs><linearGradient id="gsTutBadge" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#667eea"/><stop offset="100%" style="stop-color:#764ba2"/></linearGradient></defs>
                    <rect x="5" y="5" width="90" height="90" rx="20" fill="url(#gsTutBadge)"/>
                    <g transform="rotate(-12, 35, 50)"><rect x="15" y="28" width="28" height="36" rx="4" fill="white"/><circle cx="43" cy="46" r="6" fill="white"/><text x="29" y="54" font-family="Arial" font-size="20" font-weight="bold" fill="#667eea" text-anchor="middle">G</text></g>
                    <g transform="rotate(12, 65, 50)"><rect x="57" y="28" width="28" height="36" rx="4" fill="rgba(255,255,255,0.9)"/><circle cx="57" cy="46" r="6" fill="url(#gsTutBadge)"/><text x="71" y="54" font-family="Arial" font-size="20" font-weight="bold" fill="#764ba2" text-anchor="middle">S</text></g>
                </svg>
            </div>
            <h2>Welcome to Game Shelf!</h2>
            <p>Let's take a quick tour of the app so you can get the most out of it.</p>
            
            <div class="tutorial-welcome-features">
                <div class="tutorial-welcome-feature">
                    <span>ðŸ </span>
                    <span>Track daily progress</span>
                </div>
                <div class="tutorial-welcome-feature">
                    <span>ðŸŽ®</span>
                    <span>Manage your games</span>
                </div>
                <div class="tutorial-welcome-feature">
                    <span>ðŸ‘¥</span>
                    <span>Compete with friends</span>
                </div>
                <div class="tutorial-welcome-feature">
                    <span>ðŸ“¤</span>
                    <span>Share your results</span>
                </div>
            </div>
            
            <div class="tutorial-time">â±ï¸ Takes about 1 minute</div>
            
            <div class="tutorial-actions">
                <button class="tutorial-btn tutorial-btn-secondary" onclick="skipTutorial()">Skip</button>
                <button class="tutorial-btn tutorial-btn-primary" onclick="startTutorialSteps()">Start Tour â†’</button>
            </div>
        </div>
        
        <!-- Tutorial Spotlight (moves around) -->
        <div class="tutorial-spotlight pulse" id="tutorial-spotlight" style="display: none;"></div>
        
        <!-- Tutorial Card (positioned dynamically) -->
        <div class="tutorial-card" id="tutorial-card" style="display: none;">
            <div class="tutorial-card-arrow top" id="tutorial-arrow"></div>
            <div class="tutorial-step-indicator" id="tutorial-step-indicator"></div>
            <div class="tutorial-title" id="tutorial-title"></div>
            <div class="tutorial-content" id="tutorial-content"></div>
            <div class="tutorial-actions">
                <button class="tutorial-btn tutorial-btn-secondary" id="tutorial-back-btn" onclick="tutorialBack()">Back</button>
                <button class="tutorial-btn tutorial-btn-primary" id="tutorial-next-btn" onclick="tutorialNext()">Next â†’</button>
            </div>
            <div class="tutorial-skip">
                <span class="tutorial-skip-link" onclick="skipTutorial()">Skip tutorial</span>
            </div>
        </div>
    </div>
    
    <!-- Main Content -->
    <main class="main-content">
        <!-- Home Screen -->
        <div class="screen active" id="screen-home">
            <div class="section-header">
                <span class="section-title">Your Games</span>
                <button class="see-all" onclick="switchTab('games')">See All <span id="total-games-count"></span></button>
            </div>
            <div class="games-grid" id="home-games-grid">
                <!-- Populated by JS -->
            </div>
            
            <div class="primary-action">
                <button class="big-log-button" 
                    onmousedown="handleRecordButtonDown(event)" 
                    onmouseup="handleRecordButtonUp(event)" 
                    onmouseleave="handleRecordButtonUp(event)"
                    ontouchstart="handleRecordButtonDown(event)" 
                    ontouchend="handleRecordButtonUp(event)"
                    ontouchcancel="handleRecordButtonUp(event)">
                    <span style="font-size: 1.3rem;">ðŸ“‹</span>
                    <span>Record Game</span>
                </button>
                <div style="font-size: 0.7rem; color: var(--text-muted); text-align: center; margin-top: 6px;">
                    Tap to paste from clipboard â€¢ Hold for manual entry
                </div>
                <div class="quick-games" id="quick-games">
                    <!-- Populated by JS -->
                </div>
            </div>
            
            <div class="progress-section">
                <div class="progress-header">
                    <span>Today's Progress</span>
                    <span id="goal-display">0/5 games</span>
                </div>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progress-bar" style="width: 0%"></div>
                </div>
                <div class="progress-stats">
                    <span id="games-today-text">Play your first game!</span>
                    <span class="streak-badge" id="streak-badge">ðŸ”¥ 0</span>
                </div>
                <button class="share-today-btn" id="share-today-btn" onclick="quickShareRecap()" style="display: none;">
                    <span>ðŸ“¤</span>
                    <span>Share Today's Recap</span>
                </button>
            </div>
            
            <div class="widget" id="friends-widget">
                <div class="widget-header">
                    <span class="widget-icon">ðŸ‘¥</span>
                    <span class="widget-title">Friends Today</span>
                </div>
                <div class="friends-row" id="friends-row">
                    <div class="empty-state" style="padding: 10px;">
                        <div style="font-size: 0.85rem; color: var(--text-muted);">Sign in to see friends</div>
                    </div>
                </div>
                <button class="widget-action" onclick="switchTab('social')">See All Friends â†’</button>
            </div>
            
            <div class="widget" id="battle-widget" style="display: none;">
                <div class="widget-header">
                    <span class="widget-icon">âš”ï¸</span>
                    <span class="widget-title">Active Battle</span>
                    <span class="widget-badge" id="battle-time-left">--</span>
                </div>
                <div class="battle-name" id="battle-name">--</div>
                <div class="battle-standings" id="battle-standings">
                    <!-- Populated by JS -->
                </div>
                <button class="widget-action" onclick="switchTab('social')">View Battle â†’</button>
            </div>
        </div>
        
        <!-- Games Screen -->
        <div class="screen" id="screen-games">
            <!-- Search Bar -->
            <div style="padding: 0 16px 12px;">
                <input type="text" id="games-search-input" placeholder="ðŸ” Search games..." 
                       oninput="filterGames(this.value)"
                       style="width: 100%; padding: 12px 16px; border: 2px solid var(--border); border-radius: 12px; font-size: 0.95rem; background: var(--bg-secondary); color: var(--text-primary); box-sizing: border-box;">
            </div>
            
            <!-- Recommendations Section -->
            <div class="recommendations-section" id="recommendations-section">
                <div class="recommendations-header" id="recommendations-header" onclick="toggleRecommendations('games')">
                    <div>
                        <div class="recommendations-title">
                            <span>âœ¨</span>
                            <span>Recommended for You</span>
                            <span class="recommendations-chevron">â–¼</span>
                        </div>
                        <div class="recommendations-subtitle">Based on your shelf and friends</div>
                    </div>
                    <button class="recommendations-refresh" onclick="event.stopPropagation(); refreshRecommendations()" title="Refresh">ðŸ”„</button>
                </div>
                <div class="recommendations-list" id="recommendations-list">
                    <!-- Populated by JS -->
                </div>
            </div>
            
            <div class="games-list" id="games-list-container">
                <!-- Your Shelf -->
                <div class="games-category">
                    <div class="category-title">Your Shelf <span id="shelf-count" style="color: var(--text-muted); font-weight: normal;">(0)</span></div>
                    <div style="font-size: 0.7rem; color: var(--text-muted); margin-bottom: 8px; padding-left: 4px;">Long-press any game to remove</div>
                    <div class="games-grid" id="shelf-games-grid">
                        <!-- Populated by JS -->
                    </div>
                </div>
                
                <!-- Browse All Games -->
                <div class="games-category">
                    <div class="category-title" style="margin-bottom: 8px;">Browse All Games</div>
                    <div id="browse-categories">
                        <!-- Populated by JS -->
                    </div>
                </div>
                
                <!-- Suggest a Game -->
                <div style="padding: 16px;">
                    <button onclick="showSuggestGame()" style="width: 100%; padding: 14px; background: var(--bg-secondary); border: 2px dashed var(--border); border-radius: 12px; color: var(--text-muted); font-size: 0.9rem; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                        <span>ðŸ’¡</span>
                        <span>Suggest a Game</span>
                    </button>
                </div>
            </div>
            
            <!-- Search Results (hidden by default) -->
            <div id="games-search-results" style="display: none; padding: 0 16px;">
                <div class="games-grid" id="search-results-grid">
                    <!-- Populated by JS -->
                </div>
            </div>
        </div>
        
        <!-- Stats Screen (v1.2.47) -->
        <div class="screen" id="screen-stats">
            <div class="section-header" style="margin-bottom: 16px;">
                <span class="section-title">ðŸ“Š Your Stats</span>
                <button class="see-all" onclick="handleRecordGame()" style="background: var(--accent-purple); color: white; border-radius: 8px; padding: 6px 12px;">
                    ðŸ“· Import Stats
                </button>
            </div>
            
            <!-- Stats Summary Cards -->
            <div id="stats-summary" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 20px;">
                <!-- Populated by JS -->
            </div>
            
            <!-- Per-Game Stats List -->
            <div class="section-header" style="margin-bottom: 12px;">
                <span class="section-title">Game Details</span>
            </div>
            <div id="stats-game-list" style="display: flex; flex-direction: column; gap: 12px;">
                <!-- Populated by JS -->
            </div>
        </div>
        
        <!-- Social Screen -->
        <div class="screen" id="screen-social">
            <!-- Social Tabs -->
            <div id="social-tabs-container" style="display: flex; border-bottom: 1px solid var(--border); margin-bottom: 16px;">
                <button class="social-tab active" data-social-tab="friends" onclick="switchSocialTab('friends')" style="flex: 1; padding: 12px; border: none; background: none; font-weight: 600; color: var(--text-primary); border-bottom: 2px solid var(--accent-purple);">
                    ðŸ‘¥ Friends
                </button>
                <button class="social-tab" data-social-tab="activity" onclick="switchSocialTab('activity')" style="flex: 1; padding: 12px; border: none; background: none; font-weight: 600; color: var(--text-muted); border-bottom: 2px solid transparent;">
                    ðŸ“° Activity
                </button>
                <button class="social-tab" data-social-tab="battles" onclick="switchSocialTab('battles')" style="flex: 1; padding: 12px; border: none; background: none; font-weight: 600; color: var(--text-muted); border-bottom: 2px solid transparent;">
                    âš”ï¸ Battles
                </button>
            </div>
            
            <!-- Friends Tab -->
            <div class="social-tab-content" id="social-tab-friends">
                <div class="friends-section">
                    <!-- Friends Header -->
                    <div class="friends-header">
                        <span class="section-title">My Friends</span>
                        <span class="friends-count" id="friends-count-badge">0</span>
                    </div>
                    
                    <!-- Invite Friends Button -->
                    <button onclick="showReferralSheet()" style="width: 100%; padding: 14px; background: linear-gradient(135deg, #667eea, #764ba2); border: none; border-radius: 12px; color: white; font-weight: 600; font-size: 0.95rem; cursor: pointer; margin-bottom: 16px; display: flex; align-items: center; justify-content: center; gap: 8px;">
                        <span>âž•</span>
                        <span>Invite Friends</span>
                    </button>
                    
                    <!-- Battle Recommendations Section for Social -->
                    <div class="recommendations-section" id="recommendations-section-social" style="margin: 0 0 16px 0;">
                        <div class="recommendations-header" onclick="toggleRecommendations('social')">
                            <div>
                                <div class="recommendations-title">
                                    <span>âš”ï¸</span>
                                    <span>Battle Suggestions</span>
                                    <span class="recommendations-chevron">â–¼</span>
                                </div>
                                <div class="recommendations-subtitle">Challenge friends or join public battles</div>
                            </div>
                        </div>
                        <div class="recommendations-list" id="recommendations-list-social">
                            <!-- Populated by JS -->
                        </div>
                    </div>
                    
                    <!-- Today's Leaderboard -->
                    <div style="margin-bottom: 16px;">
                        <div style="font-weight: 600; margin-bottom: 10px; font-size: 0.9rem; color: var(--text-muted);">ðŸ“Š Today's Leaderboard</div>
                        <div class="friends-leaderboard" id="friends-leaderboard">
                            <!-- Populated by JS -->
                        </div>
                    </div>
                    
                    <!-- Friends List -->
                    <div>
                        <div style="font-weight: 600; margin-bottom: 10px; font-size: 0.9rem; color: var(--text-muted);">ðŸ‘¥ All Friends</div>
                        <div class="friends-list" id="friends-list">
                            <!-- Populated by JS -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Activity Tab -->
            <div class="social-tab-content" id="social-tab-activity" style="display: none;">
                <div class="friends-section">
                    <div class="friends-header">
                        <span class="section-title">Recent Activity</span>
                    </div>
                    <div class="activity-feed" id="activity-feed">
                        <!-- Populated by JS -->
                    </div>
                </div>
            </div>
            
            <!-- Battles Tab -->
            <div class="social-tab-content" id="social-tab-battles" style="display: none;">
                <div class="social-section">
                    <div class="widget" style="margin: 0;">
                        <div class="widget-header">
                            <span class="widget-icon">âš”ï¸</span>
                            <span class="widget-title">Brain Battles</span>
                        </div>
                        
                        <div class="battle-actions">
                            <div class="battle-action-btn" onclick="showCreateBattle()">
                                <span class="action-icon">âš”ï¸</span>
                                <span class="action-text">Create</span>
                            </div>
                            <div class="battle-action-btn" onclick="showJoinBattle()">
                                <span class="action-icon">ðŸ”</span>
                                <span class="action-text">Join</span>
                            </div>
                        </div>
                        
                        <div id="battles-list">
                            <!-- Populated by JS -->
                        </div>
                        
                        <!-- Public Battle Lobby -->
                        <div class="battle-lobby-section" id="battle-lobby-section">
                            <div class="battle-lobby-header">
                                <div class="battle-lobby-title">
                                    <span>ðŸŒ</span>
                                    <span>Public Battles</span>
                                </div>
                                <button class="battle-lobby-refresh" onclick="loadPublicBattles()" title="Refresh">ðŸ”„</button>
                            </div>
                            <div class="battle-lobby-list" id="public-battles-list">
                                <!-- Populated by JS -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Share Screen -->
        <div class="screen" id="screen-share">
            <div class="share-hub-header">
                <div style="font-size: 2rem;">ðŸ“¢</div>
                <h2>Share Hub</h2>
                <p>Write once, share everywhere</p>
            </div>
            
            <!-- Friend Recommendations Section for Share -->
            <div class="recommendations-section" id="recommendations-section-share" style="margin: 0 16px 16px 16px;">
                <div class="recommendations-header" onclick="toggleRecommendations('share')">
                    <div>
                        <div class="recommendations-title">
                            <span>ðŸ‘¥</span>
                            <span>Share With Friends</span>
                            <span class="recommendations-chevron">â–¼</span>
                        </div>
                        <div class="recommendations-subtitle">Invite friends to compare scores</div>
                    </div>
                </div>
                <div class="recommendations-list" id="recommendations-list-share">
                    <!-- Populated by JS -->
                </div>
            </div>
            
            <!-- Today's Results -->
            <div class="share-results-section">
                <div class="share-results-header">
                    <h4>ðŸ“Š Today's Results</h4>
                    <span class="share-results-date" id="share-screen-date"></span>
                </div>
                <div class="share-result-tags" id="share-screen-results">
                    <!-- Filled dynamically -->
                </div>
                <button class="quick-recap-btn" onclick="quickShareRecap()" style="
                    width: 100%;
                    margin-top: 12px;
                    padding: 12px 16px;
                    background: linear-gradient(135deg, #667eea, #764ba2);
                    border: none;
                    border-radius: 10px;
                    color: white;
                    font-size: 0.95rem;
                    font-weight: 600;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    gap: 8px;
                ">
                    <span>ðŸ“¤</span>
                    <span>Quick Share All Results</span>
                </button>
                <button class="weekly-recap-btn" onclick="openWeeklyRecap()">
                    <span>ðŸ“Š</span>
                    <span>Share Weekly Recap</span>
                </button>
            </div>
            
            <!-- Message Composer -->
            <div class="share-composer">
                <div class="share-composer-header">
                    <label>âœï¸ Your Message</label>
                    <select class="share-template-select" id="share-screen-template" onchange="handleTemplateChange()">
                        <option value="default">Default</option>
                        <option value="brag">Bragging ðŸ†</option>
                        <option value="humble">Humble ðŸ˜…</option>
                        <option value="streak">Streak Focus ðŸ”¥</option>
                        <option value="challenge">Challenge âš”ï¸</option>
                        <option value="minimal">Minimal</option>
                        <option value="history">ðŸ“œ From History...</option>
                    </select>
                </div>
                <textarea class="share-textarea" id="share-screen-message" rows="4" placeholder="Write your message here..."></textarea>
                <div class="share-emoji-bar">
                    <button class="share-emoji-btn" onclick="insertShareEmoji('ðŸŽ®')">ðŸŽ®</button>
                    <button class="share-emoji-btn" onclick="insertShareEmoji('ðŸ§ ')">ðŸ§ </button>
                    <button class="share-emoji-btn" onclick="insertShareEmoji('ðŸ”¥')">ðŸ”¥</button>
                    <button class="share-emoji-btn" onclick="insertShareEmoji('ðŸ’ª')">ðŸ’ª</button>
                    <button class="share-emoji-btn" onclick="insertShareEmoji('ðŸŽ¯')">ðŸŽ¯</button>
                    <button class="share-emoji-btn" onclick="insertShareEmoji('âœ¨')">âœ¨</button>
                </div>
                <div class="share-options-row">
                    <label class="share-option-checkbox">
                        <input type="checkbox" id="share-include-link" checked onchange="applyShareTemplate()">
                        <span>Include invite link</span>
                    </label>
                    <label class="share-option-checkbox">
                        <input type="checkbox" id="share-save-history" checked>
                        <span>Save to history</span>
                    </label>
                </div>
            </div>
            
            <!-- Share History (collapsible) -->
            <div class="share-history-section" id="share-history-section" style="display: none;">
                <div class="share-history-header" onclick="toggleShareHistory()">
                    <span>ðŸ“œ Recent Shares</span>
                    <span class="share-history-chevron">â–¼</span>
                </div>
                <div class="share-history-list" id="share-history-list">
                    <!-- Populated by JS -->
                </div>
            </div>
            
            <!-- Share Platforms -->
            <div class="share-platforms">
                <h4>ðŸš€ Share To</h4>
                
                <!-- Primary Platforms -->
                <div class="share-platforms-grid">
                    <button class="share-platform-btn" style="background: #000;" onclick="shareToTwitter()">
                        <span class="icon">ð•</span>
                        <span class="label">Twitter/X</span>
                    </button>
                    <button class="share-platform-btn" style="background: #1877F2;" onclick="shareToFacebook()">
                        <span class="icon">ðŸ“˜</span>
                        <span class="label">Facebook</span>
                    </button>
                    <button class="share-platform-btn" style="background: #0A66C2;" onclick="shareToLinkedIn()">
                        <span class="icon">ðŸ’¼</span>
                        <span class="label">LinkedIn</span>
                    </button>
                    <button class="share-platform-btn" style="background: #000;" onclick="shareToThreads()">
                        <span class="icon">ðŸ§µ</span>
                        <span class="label">Threads</span>
                    </button>
                </div>
                
                <!-- Secondary Platforms -->
                <div class="share-platforms-grid">
                    <button class="share-platform-btn" style="background: #FF4500;" onclick="shareToReddit()">
                        <span class="icon">ðŸ”´</span>
                        <span class="label">Reddit</span>
                    </button>
                    <button class="share-platform-btn" style="background: #5865F2;" onclick="shareToDiscord()">
                        <span class="icon">ðŸ’¬</span>
                        <span class="label">Discord</span>
                    </button>
                    <button class="share-platform-btn" style="background: #0085FF;" onclick="shareToBlueSky()">
                        <span class="icon">ðŸ¦‹</span>
                        <span class="label">BlueSky</span>
                    </button>
                    <button class="share-platform-btn" style="background: #6364FF;" onclick="shareToMastodon()">
                        <span class="icon">ðŸ˜</span>
                        <span class="label">Mastodon</span>
                    </button>
                </div>
                
                <!-- Utility -->
                <div class="share-utility-grid">
                    <button class="share-platform-btn" style="background: var(--bg-tertiary); border: 1px solid var(--border);" onclick="copyShareMessage()">
                        <span class="icon">ðŸ“‹</span>
                        <span class="label" style="color: var(--text-primary);">Copy</span>
                    </button>
                    <button class="share-platform-btn" style="background: var(--accent-green);" onclick="shareNative()">
                        <span class="icon">ðŸ“¤</span>
                        <span class="label">More...</span>
                    </button>
                </div>
            </div>
        </div>
    </main>
    
    <!-- Floating Share Button -->
    <button class="share-fab" id="share-fab" onclick="quickShareRecap()" title="Share Today's Results">
        ðŸ“¤
        <span class="share-fab-badge" id="share-fab-badge">0</span>
    </button>
    
    <!-- Bottom Navigation -->
    <nav class="nav-bar">
        <button class="nav-tab active" data-tab="home" onclick="switchTab('home')">
            <span class="nav-icon">ðŸ </span>
            <span class="nav-label">Home</span>
        </button>
        <button class="nav-tab" data-tab="games" onclick="switchTab('games')">
            <span class="nav-icon">ðŸ§©</span>
            <span class="nav-label">Games</span>
        </button>
        <button class="nav-tab" data-tab="stats" onclick="switchTab('stats')">
            <span class="nav-icon">ðŸ“Š</span>
            <span class="nav-label">Stats</span>
        </button>
        <button class="nav-tab" data-tab="social" onclick="switchTab('social')">
            <span class="nav-icon">âš”ï¸</span>
            <span class="nav-label">Battles</span>
        </button>
        <button class="nav-tab" data-tab="share" onclick="switchTab('share')">
            <span class="nav-icon">ðŸ“¢</span>
            <span class="nav-label">Share</span>
        </button>
    </nav>
    
    <!-- ============ SETUP FLOW CONTAINER ============ -->
    <div class="setup-container" id="setup-container">
        
        <!-- SETUP SCREEN 1: WELCOME -->
        <div class="setup-screen active" id="setup-welcome">
            <div class="setup-progress">
                <div class="setup-progress-step active"></div>
                <div class="setup-progress-step"></div>
                <div class="setup-progress-step"></div>
            </div>
            
            <div class="setup-header">
                <div class="setup-header-icon">
                    <svg viewBox="0 0 100 100" width="80" height="80" xmlns="http://www.w3.org/2000/svg">
                        <defs><linearGradient id="gsBadgeGrad" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#667eea"/><stop offset="100%" style="stop-color:#764ba2"/></linearGradient></defs>
                        <rect x="5" y="5" width="90" height="90" rx="20" fill="url(#gsBadgeGrad)"/>
                        <g transform="rotate(-12, 35, 50)"><rect x="15" y="28" width="28" height="36" rx="4" fill="white"/><circle cx="43" cy="46" r="6" fill="white"/><text x="29" y="54" font-family="Arial" font-size="20" font-weight="bold" fill="#667eea" text-anchor="middle">G</text></g>
                        <g transform="rotate(12, 65, 50)"><rect x="57" y="28" width="28" height="36" rx="4" fill="rgba(255,255,255,0.9)"/><circle cx="57" cy="46" r="6" fill="url(#gsBadgeGrad)"/><text x="71" y="54" font-family="Arial" font-size="20" font-weight="bold" fill="#764ba2" text-anchor="middle">S</text></g>
                    </svg>
                </div>
                <h1>Welcome to Game Shelf</h1>
                <p>Track all your daily puzzles in one place</p>
            </div>
            
            <div class="setup-spacer"></div>
            
            <div class="setup-actions">
                <button class="setup-btn setup-btn-primary" onclick="setupQuickStart()">
                    âš¡ Quick Start
                </button>
                <p style="font-size: 0.75rem; color: var(--text-muted); margin: 8px 0 4px 0; text-align: center;">
                    Wordle, Connections, Strands + Game Shelf Originals
                </p>
                <button class="setup-btn setup-btn-secondary" onclick="setupGoToScreen('setup-select-games')" style="margin-top: 12px;">
                    Choose My Own Games
                </button>
            </div>
        </div>
        
        <!-- SETUP SCREEN 2: SELECT GAMES -->
        <div class="setup-screen" id="setup-select-games">
            <div class="setup-progress">
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step active"></div>
                <div class="setup-progress-step"></div>
            </div>
            
            <div class="setup-header">
                <h1>What do you play?</h1>
                <p>Select all the daily games you play</p>
            </div>
            
            <div class="setup-scroll-content">
                <div id="setup-game-grid"></div>
            </div>
            
            <div class="setup-actions">
                <button class="setup-btn setup-btn-primary" id="setup-btn-games-next" onclick="setupSkipToEnhance()" disabled>
                    Continue â†’
                </button>
                <button class="setup-btn setup-btn-ghost" onclick="setupSkipToComplete()" style="margin-top: 8px;">
                    Skip for now
                </button>
                <div class="setup-back-link" onclick="setupGoToScreen('setup-welcome')">â† Back</div>
            </div>
        </div>
        
        <!-- SETUP SCREEN 3: ACCESS CONFIG (HIDDEN - kept for backwards compat) -->
        <div class="setup-screen" id="setup-access-config">
            <div class="setup-progress">
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step active"></div>
                <div class="setup-progress-step"></div>
                <div class="setup-progress-step"></div>
            </div>
            
            <div class="setup-header">
                <h1>How do you play?</h1>
                <p>Tell us how you access each publisher's games</p>
            </div>
            
            <div class="setup-scroll-content" id="setup-publisher-config">
                <!-- Filled by JS -->
            </div>
            
            <div class="setup-actions">
                <button class="setup-btn setup-btn-primary" onclick="setupGoToEnhance()">
                    Next â†’
                </button>
                <div class="setup-back-link" onclick="setupGoToScreen('setup-select-games')">â† Back</div>
            </div>
        </div>
        
        <!-- SETUP SCREEN 4: ENHANCE OFFER -->
        <div class="setup-screen" id="setup-enhance">
            <div class="setup-progress">
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step active"></div>
                <div class="setup-progress-step"></div>
            </div>
            
            <div class="setup-header">
                <h1>Import Your Stats?</h1>
                <p>We can pull in your existing progress</p>
            </div>
            
            <div class="setup-enhance-card">
                <h3>ðŸ“Š Screenshot Import</h3>
                <p>We'll open each game's stats screen using your preferences. Just screenshot and upload to import:</p>
                <div class="setup-enhance-benefits">
                    <div class="setup-benefit"><span class="icon">âœ“</span> Current streak</div>
                    <div class="setup-benefit"><span class="icon">âœ“</span> Games played</div>
                    <div class="setup-benefit"><span class="icon">âœ“</span> Win percentage</div>
                    <div class="setup-benefit"><span class="icon">âœ“</span> Max streak</div>
                </div>
                <p style="font-size: 0.75rem; color: var(--text-muted); margin-top: 12px; margin-bottom: 0;">This also helps us verify your launch URLs work correctly.</p>
            </div>
            
            <div class="setup-spacer"></div>
            
            <div class="setup-actions">
                <button class="setup-btn setup-btn-primary" onclick="setupStartScreenshotFlow()">
                    Yes, Import Stats
                </button>
                <button class="setup-btn setup-btn-ghost" onclick="setupGoToSharing()">
                    Skip for now
                </button>
            </div>
        </div>
        
        <!-- SETUP SCREEN 5: SCREENSHOT FLOW -->
        <div class="setup-screen" id="setup-screenshot-flow">
            <div class="setup-progress">
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step active"></div>
                <div class="setup-progress-step"></div>
            </div>
            
            <div class="setup-header">
                <h1 id="setup-screenshot-flow-title">Import Stats</h1>
                <p id="setup-screenshot-flow-subtitle">Game 1 of 3</p>
            </div>
            
            <div class="setup-scroll-content" id="setup-screenshot-flow-content">
                <!-- Filled by JS based on current game -->
            </div>
            
            <div class="setup-actions" id="setup-screenshot-flow-actions">
                <!-- Dynamic buttons -->
            </div>
        </div>
        
        <!-- SETUP SCREEN 6: LAUNCH FEEDBACK -->
        <div class="setup-screen" id="setup-launch-feedback">
            <div class="setup-progress">
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step active"></div>
                <div class="setup-progress-step"></div>
            </div>
            
            <div class="setup-launch-feedback">
                <h3 id="setup-feedback-title">Did Wordle open?</h3>
                <p id="setup-feedback-subtitle">We tried to open your stats screen</p>
                
                <div class="setup-feedback-options">
                    <div class="setup-feedback-btn" onclick="setupLaunchFeedback('success')">
                        <span class="icon">âœ…</span>
                        <div class="text">
                            <h4>Yes, it opened!</h4>
                            <p>I can see my stats screen</p>
                        </div>
                    </div>
                    <div class="setup-feedback-btn" onclick="setupLaunchFeedback('wrong-screen')">
                        <span class="icon">ðŸ”€</span>
                        <div class="text">
                            <h4>Wrong screen</h4>
                            <p>It opened but not to stats</p>
                        </div>
                    </div>
                    <div class="setup-feedback-btn" onclick="setupLaunchFeedback('didnt-open')">
                        <span class="icon">âŒ</span>
                        <div class="text">
                            <h4>Didn't open</h4>
                            <p>Nothing happened or got an error</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="setup-spacer"></div>
            
            <div class="setup-actions">
                <div class="setup-back-link" onclick="setupSkipCurrentGame()">Skip this game</div>
            </div>
        </div>
        
        <!-- SETUP SCREEN 6B: LAUNCH FAILED -->
        <div class="setup-screen" id="setup-launch-failed">
            <div class="setup-progress">
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step active"></div>
                <div class="setup-progress-step"></div>
            </div>
            
            <div class="setup-header">
                <div class="setup-header-icon">ðŸ”§</div>
                <h1 id="setup-failed-title">Let's Fix That</h1>
                <p id="setup-failed-subtitle">We have a few options to try</p>
            </div>
            
            <div id="setup-failed-options">
                <!-- Filled by JS -->
            </div>
            
            <div class="setup-spacer"></div>
            
            <div class="setup-actions">
                <div class="setup-back-link" onclick="setupSkipCurrentGame()">Skip this game for now</div>
            </div>
        </div>
        
        <!-- SETUP SCREEN 6C: CUSTOM URL INPUT -->
        <div class="setup-screen" id="setup-custom-url">
            <div class="setup-progress">
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step active"></div>
                <div class="setup-progress-step"></div>
            </div>
            
            <div class="setup-header">
                <h1 id="setup-custom-url-title">What URL do you use?</h1>
                <p id="setup-custom-url-subtitle">Enter the web address you normally use</p>
            </div>
            
            <div class="setup-custom-url-card">
                <label class="setup-input-label">URL</label>
                <input type="url" id="setup-custom-url-input" class="setup-text-input" placeholder="https://..." autocapitalize="none" autocorrect="off">
                <p class="setup-input-hint" id="setup-custom-url-hint">
                    Tip: Open the game in Safari, copy the URL from the address bar
                </p>
            </div>
            
            <div class="setup-spacer"></div>
            
            <div class="setup-actions">
                <button class="setup-btn setup-btn-primary" onclick="setupTestCustomUrl()">
                    ðŸš€ Test This URL
                </button>
                <button class="setup-btn setup-btn-ghost" onclick="setupUseCustomUrlAndContinue()">
                    Save Without Testing
                </button>
                <div class="setup-back-link" onclick="setupSkipCurrentGame()">Skip this game</div>
            </div>
        </div>
        
        <!-- SETUP SCREEN 7: UPLOAD SCREENSHOT -->
        <div class="setup-screen" id="setup-upload">
            <div class="setup-progress">
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step active"></div>
                <div class="setup-progress-step"></div>
            </div>
            
            <div class="setup-header">
                <h1 id="setup-upload-title">ðŸ“¸ Screenshot Wordle</h1>
                <p>Take a screenshot of your stats, then upload it here</p>
            </div>
            
            <div class="setup-upload-area" id="setup-upload-area" onclick="document.getElementById('setup-file-input').click()">
                <div class="icon">ðŸ“·</div>
                <p>Tap to upload screenshot</p>
            </div>
            <input type="file" id="setup-file-input" accept="image/*" onchange="setupHandleFileUpload(event)">
            
            <div id="setup-stats-result" style="display: none;">
                <div class="setup-section-title">Stats Found</div>
                <div class="setup-stats-preview" id="setup-stats-preview"></div>
            </div>
            
            <div class="setup-spacer"></div>
            
            <div class="setup-actions">
                <button class="setup-btn setup-btn-primary" id="setup-btn-save-stats" onclick="setupSaveStatsAndNext()" disabled>
                    Save & Continue
                </button>
                <div class="setup-back-link" onclick="setupSkipCurrentGame()">Skip this game</div>
            </div>
        </div>
        
        <!-- SETUP SCREEN 7B: CONFIRM SAME SETTINGS -->
        <div class="setup-screen" id="setup-confirm-same">
            <div class="setup-progress">
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step active"></div>
                <div class="setup-progress-step"></div>
            </div>
            
            <div class="setup-header">
                <h1 id="setup-confirm-same-title">Same for other NYT games?</h1>
                <p id="setup-confirm-same-subtitle">You also selected Connections and Strands</p>
            </div>
            
            <div class="setup-screenshot-card">
                <div class="setup-screenshot-card-header">
                    <span class="icon">âœ…</span>
                    <h3 id="setup-confirmed-game-name">Wordle worked!</h3>
                </div>
                <div class="setup-screenshot-instructions">
                    <p id="setup-confirmed-settings">Browser â†’ Hub â†’ nytimes.com/games</p>
                </div>
            </div>
            
            <div id="setup-other-games-list" style="margin: 16px 0;">
                <!-- Filled by JS -->
            </div>
            
            <div class="setup-spacer"></div>
            
            <div class="setup-actions">
                <button class="setup-btn setup-btn-primary" onclick="setupConfirmSameSettings(true)">
                    âœ“ Yes, Same Settings
                </button>
                <button class="setup-btn setup-btn-outline" onclick="setupConfirmSameSettings(false)">
                    No, Configure Each
                </button>
            </div>
        </div>
        
        <!-- SETUP SCREEN 8: SHARING -->
        <div class="setup-screen" id="setup-sharing">
            <div class="setup-progress">
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step active"></div>
            </div>
            
            <div class="setup-header">
                <h1>How do you share results?</h1>
                <p>Select all that apply</p>
            </div>
            
            <div class="setup-scroll-content">
                <div id="setup-sharing-methods">
                    <div class="setup-sharing-option" onclick="setupToggleSharing('copy', this)">
                        <span class="icon">ðŸ“‹</span>
                        <div class="text">
                            <h4>Copy & Paste</h4>
                            <p>Share emoji grids as text</p>
                        </div>
                        <span class="check">âœ“</span>
                    </div>
                    <div class="setup-sharing-option" onclick="setupToggleSharing('image', this)">
                        <span class="icon">ðŸ–¼ï¸</span>
                        <div class="text">
                            <h4>Share as Image</h4>
                            <p>Create shareable graphics</p>
                        </div>
                        <span class="check">âœ“</span>
                    </div>
                    <div class="setup-sharing-option" onclick="setupToggleSharing('none', this)">
                        <span class="icon">ðŸ”‡</span>
                        <div class="text">
                            <h4>I don't share</h4>
                            <p>Just track my progress</p>
                        </div>
                        <span class="check">âœ“</span>
                    </div>
                </div>
                
                <div id="setup-social-section" style="display: none;">
                    <div class="setup-section-title">Where do you share?</div>
                    <div class="setup-social-grid" id="setup-social-grid"></div>
                </div>
            </div>
            
            <div class="setup-spacer"></div>
            
            <div class="setup-actions" id="setup-sharing-actions" style="display: none;">
                <button class="setup-btn setup-btn-primary" onclick="setupFinish()">
                    Finish Setup â†’
                </button>
            </div>
            
            <div class="setup-back-link" id="setup-sharing-skip" onclick="setupSkipSharing()">Skip for now</div>
        </div>
        
        <!-- SETUP SCREEN 9: COMPLETE -->
        <div class="setup-screen" id="setup-complete">
            <div class="setup-progress">
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step complete"></div>
                <div class="setup-progress-step complete"></div>
            </div>
            
            <div class="setup-header">
                <div class="setup-success-icon">âœ“</div>
                <h1>You're Ready!</h1>
                <p id="setup-complete-summary">3 games ready to track</p>
            </div>
            
            <div class="setup-scroll-content">
                <div class="setup-section-title">Your Games</div>
                <div id="setup-final-games-list"></div>
                
                <!-- Auto-log tip -->
                <div style="margin-top: 20px; padding: 16px; background: var(--bg-tertiary); border-radius: 12px; border-left: 4px solid var(--accent-green);">
                    <div style="font-weight: 600; margin-bottom: 8px;">ðŸ’¡ How it works:</div>
                    <div style="font-size: 0.9rem; color: var(--text-secondary); line-height: 1.5;">
                        After playing a game, <strong>copy your results</strong> and come back here. Game Shelf will <strong>automatically log</strong> your score!
                    </div>
                </div>
            </div>
            
            <div class="setup-actions">
                <button class="setup-btn setup-btn-success" onclick="setupOpenGameShelfWithTutorial()">
                    ðŸŽ¯ Take the Tour â†’
                </button>
                <button class="setup-btn setup-btn-ghost" onclick="setupOpenGameShelf()" style="margin-top: 8px;">
                    Skip tour, start using Game Shelf
                </button>
            </div>
        </div>
        
        <!-- SETUP SCREEN: ANALYZING -->
        <div class="setup-screen" id="setup-analyzing">
            <div class="setup-spacer"></div>
            <div class="setup-loading">
                <div class="setup-spinner"></div>
                <p id="setup-analyzing-status">Analyzing screenshot...</p>
            </div>
            <div class="setup-spacer"></div>
        </div>
    </div>
    
    <!-- Install Banner -->
    <div class="install-banner" id="install-banner" onclick="triggerInstall()">
        <div class="install-banner-content">
            <div class="install-banner-icon" id="install-icon">ðŸ“²</div>
            <div class="install-banner-text">
                <div class="install-banner-title">Install Game Shelf</div>
                <div class="install-banner-desc" id="install-desc">
                    Tap here, then "Add to Home Screen"
                </div>
            </div>
            <button class="install-banner-close" onclick="dismissInstallBanner(event)">âœ•</button>
        </div>
        <!-- iOS instruction arrow pointing to Safari share button -->
        <div class="install-arrow-hint" id="install-arrow" style="display: none;">
            <span style="font-size: 24px;">â†“</span>
            <span style="font-size: 12px; margin-left: 4px;">Tap share button below</span>
        </div>
    </div>
    
    <!-- Log Sheet -->
    <div class="bottom-sheet-overlay" id="log-sheet" onclick="closeLogSheet(event)">
        <div class="bottom-sheet" onclick="event.stopPropagation()" style="max-height: 80vh;">
            <div class="bottom-sheet-handle"></div>
            <div class="bottom-sheet-header">ðŸ“‹ Log Game Result</div>
            
            <!-- Tabs -->
            <div class="log-tabs">
                <button class="log-tab active" onclick="switchLogTab('paste')">ðŸ“‹ From Share</button>
                <button class="log-tab" onclick="switchLogTab('quick')">âœï¸ Manual</button>
            </div>
            
            <!-- Paste Tab -->
            <div class="log-tab-content" id="log-tab-paste">
                <!-- v1.2.7.6: Explicit paste button for iOS (avoids auto-paste permission popup) -->
                <button id="tap-to-paste-btn" onclick="tapToPaste()" style="width: 100%; padding: 14px; margin-bottom: 12px; background: var(--accent-blue); border: none; border-radius: 10px; color: white; font-size: 1rem; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;">
                    ðŸ“‹ Tap to Paste from Clipboard
                </button>
                <textarea class="log-textarea" id="log-input" placeholder="Or tap here to type/paste manually...

Example:
Wordle 1,234 3/6
â¬›â¬›ðŸŸ¨â¬›â¬›
ðŸŸ¨ðŸŸ©â¬›â¬›â¬›
ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©" oninput="parseLogInput()"></textarea>
                <div class="parse-preview" id="parse-preview">
                    <div class="parse-game-name" id="parse-game-name"></div>
                    <div class="parse-score" id="parse-score"></div>
                </div>
                <div class="log-buttons">
                    <button class="log-btn" id="log-btn" onclick="submitLog()">Log Game</button>
                    <button class="log-btn-secondary" id="bulk-log-btn" onclick="bulkImport()" style="display: none;">Log All Found</button>
                </div>
            </div>
            
            <!-- Quick Log Tab -->
            <div class="log-tab-content" id="log-tab-quick" style="display: none;">
                <p style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 12px;">
                    Tap a game to quickly log without pasting:
                </p>
                <div id="quick-log-buttons" class="quick-log-buttons">
                    <!-- Populated by renderQuickLogButtons() -->
                </div>
                <div id="quick-log-options" class="quick-log-options" style="display: none;">
                    <!-- Score options appear here -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Score Conflict Modal (v1.2.47) -->
    <div class="bottom-sheet-overlay" id="score-conflict-modal" onclick="resolveScoreConflict('keep')">
        <div class="bottom-sheet" onclick="event.stopPropagation()" style="max-height: 60vh;">
            <div class="bottom-sheet-handle"></div>
            <div class="bottom-sheet-header">
                <span id="conflict-game-icon">ðŸŽ®</span>
                <span id="conflict-game-name">Game</span>
                <span style="color: var(--accent-orange);"> - Score Conflict</span>
            </div>
            <div style="padding: 20px; text-align: center;">
                <p style="color: var(--text-secondary); margin-bottom: 16px;">
                    You already logged a different score today
                </p>
                <div style="display: flex; justify-content: center; gap: 24px; margin-bottom: 24px;">
                    <div style="text-align: center;">
                        <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px;">Logged</div>
                        <div id="conflict-old-score" style="font-size: 1.5rem; font-weight: 700; color: var(--text-secondary);">4/6</div>
                    </div>
                    <div style="font-size: 1.5rem; color: var(--text-muted); align-self: center;">â†’</div>
                    <div style="text-align: center;">
                        <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px;">Clipboard</div>
                        <div id="conflict-new-score" style="font-size: 1.5rem; font-weight: 700; color: var(--accent-purple);">3/6</div>
                    </div>
                </div>
                <div style="display: flex; gap: 12px;">
                    <button onclick="resolveScoreConflict('keep')" style="flex: 1; padding: 14px; border-radius: 10px; border: 1px solid var(--border); background: var(--bg-tertiary); color: var(--text-primary); font-size: 1rem; cursor: pointer;">
                        Keep Original
                    </button>
                    <button onclick="resolveScoreConflict('replace')" style="flex: 1; padding: 14px; border-radius: 10px; border: none; background: var(--accent-purple); color: white; font-size: 1rem; font-weight: 600; cursor: pointer;">
                        Replace
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Streak Conflict Modal (v1.2.47 Phase 2) -->
    <div class="bottom-sheet-overlay" id="streak-conflict-modal" onclick="resolveStreakConflict('keep')">
        <div class="bottom-sheet" onclick="event.stopPropagation()" style="max-height: 60vh;">
            <div class="bottom-sheet-handle"></div>
            <div class="bottom-sheet-header">
                <span id="streak-conflict-game-icon">ðŸŽ®</span>
                <span id="streak-conflict-game-name">Game</span>
                <span style="color: var(--accent-orange);"> - Streak Mismatch</span>
            </div>
            <div style="padding: 20px; text-align: center;">
                <p style="color: var(--text-secondary); margin-bottom: 16px;">
                    Your stats show a lower streak than Game Shelf
                </p>
                <div style="display: flex; justify-content: center; gap: 24px; margin-bottom: 24px;">
                    <div style="text-align: center;">
                        <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px;">Game Shelf</div>
                        <div id="streak-conflict-gs-value" style="font-size: 2rem; font-weight: 700; color: var(--accent-green);">52</div>
                        <div style="font-size: 0.7rem; color: var(--text-muted);">day streak</div>
                    </div>
                    <div style="font-size: 1.5rem; color: var(--text-muted); align-self: center;">vs</div>
                    <div style="text-align: center;">
                        <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px;">Stats Page</div>
                        <div id="streak-conflict-stats-value" style="font-size: 2rem; font-weight: 700; color: var(--accent-orange);">12</div>
                        <div style="font-size: 0.7rem; color: var(--text-muted);">day streak</div>
                    </div>
                </div>
                <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 16px;">
                    This could mean your streak was broken, or the screenshot is from an older session.
                </p>
                <div style="display: flex; gap: 12px;">
                    <button onclick="resolveStreakConflict('keep')" style="flex: 1; padding: 14px; border-radius: 10px; border: 1px solid var(--border); background: var(--bg-tertiary); color: var(--text-primary); font-size: 1rem; cursor: pointer;">
                        Keep Higher
                    </button>
                    <button onclick="resolveStreakConflict('reset')" style="flex: 1; padding: 14px; border-radius: 10px; border: none; background: var(--accent-orange); color: white; font-size: 1rem; font-weight: 600; cursor: pointer;">
                        Reset to Stats
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Issue Report Sheet -->
    <div class="bottom-sheet-overlay" id="issue-sheet" onclick="closeIssueSheet()">
        <div class="bottom-sheet" onclick="event.stopPropagation()" style="max-height: 90vh;">
            <div class="bottom-sheet-handle"></div>
            <div class="bottom-sheet-header">ðŸ“ Report Issue / Request</div>
            
            <div style="padding: 16px; overflow-y: auto; max-height: 70vh;">
                <form id="issue-report-form" onsubmit="submitIssueReport(event)">
                    <div style="margin-bottom: 14px;">
                        <label style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px; display: block;">Type *</label>
                        <select id="issue-type" required style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--card-bg); color: var(--text-primary); font-size: 0.9rem;">
                            <option value="">What is this?</option>
                            <option value="bug">ðŸ› Bug - Something is broken</option>
                            <option value="enhancement">âœ¨ Enhancement - Improve existing feature</option>
                            <option value="feature">ðŸ’¡ Feature Request - New idea</option>
                            <option value="question">â“ Question - Need help</option>
                        </select>
                    </div>
                    
                    <div style="margin-bottom: 14px;">
                        <label style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px; display: block;">App Section *</label>
                        <select id="issue-section" required style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--card-bg); color: var(--text-primary); font-size: 0.9rem;">
                            <option value="">Select section...</option>
                            <option value="home">ðŸ  Home Screen</option>
                            <option value="games">ðŸŽ® Games / Shelf</option>
                            <option value="social">ðŸ‘¥ Social / Friends</option>
                            <option value="battles">âš”ï¸ Brain Battles</option>
                            <option value="share">ðŸ“¤ Share Tab</option>
                            <option value="log">ðŸ“‹ Log Results</option>
                            <option value="settings">âš™ï¸ Settings</option>
                            <option value="onboarding">ðŸŽ¯ Setup / Onboarding</option>
                            <option value="achievements">ðŸ† Achievements</option>
                            <option value="rewards">ðŸŽ Rewards Shop</option>
                            <option value="other">ðŸ“± Other</option>
                        </select>
                    </div>
                    
                    <div style="margin-bottom: 14px;">
                        <label style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px; display: block;">Severity *</label>
                        <select id="issue-severity" required style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--card-bg); color: var(--text-primary); font-size: 0.9rem;">
                            <option value="">How bad is it?</option>
                            <option value="critical">ðŸ”´ Critical - App crashes</option>
                            <option value="major">ðŸŸ  Major - Feature broken</option>
                            <option value="minor">ðŸŸ¡ Minor - Annoying but works</option>
                            <option value="cosmetic">ðŸŸ¢ Cosmetic - Visual glitch</option>
                            <option value="suggestion">ðŸ’¡ Just a suggestion</option>
                        </select>
                    </div>
                    
                    <div style="margin-bottom: 14px;">
                        <label style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px; display: block;">What happened? *</label>
                        <input type="text" id="issue-title" required maxlength="100" placeholder="Brief description" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--card-bg); color: var(--text-primary); font-size: 0.9rem;">
                    </div>
                    
                    <div style="margin-bottom: 14px;">
                        <label style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px; display: block;">Details (optional)</label>
                        <textarea id="issue-description" rows="3" placeholder="More info about what went wrong..." style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--card-bg); color: var(--text-primary); font-size: 0.9rem; resize: none;"></textarea>
                    </div>
                    
                    <!-- Feedback Debug Context (visible when Feedback mode is on) -->
                    <div id="feedback-debug-section" style="margin-bottom: 14px; display: none;">
                        <label style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px; display: block;">ðŸ” Debug Context (auto-captured)</label>
                        <div class="debug-log-preview" id="debug-log-preview">
                            Loading context...
                        </div>
                        <div style="margin-top: 8px;">
                            <label style="display: flex; align-items: center; gap: 8px; font-size: 0.8rem; color: var(--text-secondary);">
                                <input type="checkbox" id="include-debug-log" checked>
                                Include debug log with report
                            </label>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 14px;">
                        <label style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px; display: block;">ðŸ“· Screenshot (optional)</label>
                        <div id="issue-screenshot-preview" onclick="document.getElementById('issue-screenshot-input').click()" style="border: 2px dashed var(--border-color); border-radius: 8px; min-height: 100px; display: flex; align-items: center; justify-content: center; cursor: pointer; overflow: hidden; position: relative;">
                            <div id="issue-screenshot-placeholder" style="text-align: center; color: var(--text-muted); padding: 20px;">
                                <div style="font-size: 2rem; margin-bottom: 8px;">ðŸ“·</div>
                                <div style="font-size: 0.85rem;">Tap to add screenshot</div>
                                <div style="font-size: 0.7rem; opacity: 0.7;">or paste from clipboard</div>
                            </div>
                        </div>
                        <input type="file" id="issue-screenshot-input" accept="image/*" onchange="handleIssueScreenshot(event)" style="display: none;">
                    </div>
                    
                    <div style="display: flex; gap: 10px;">
                        <button type="button" onclick="closeIssueSheet()" style="flex: 1; padding: 12px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--card-bg); color: var(--text-primary); font-size: 0.9rem; cursor: pointer;">Cancel</button>
                        <button type="submit" id="issue-submit-btn" style="flex: 2; padding: 12px; border-radius: 8px; border: none; background: var(--accent-primary); color: white; font-size: 0.9rem; font-weight: 600; cursor: pointer;">ðŸ“¤ Submit</button>
                    </div>
                </form>
                
                <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-color); text-align: center;">
                    <a href="https://stewartdavidp-ship-it.github.io/gameshelf-testplan/?tab=issues" target="_blank" style="color: var(--accent-primary); font-size: 0.8rem; text-decoration: none;">
                        ðŸ“‹ View all reported issues â†’
                    </a>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Clipboard Prompt -->
    <div class="clipboard-prompt" id="clipboard-prompt" style="display:none;">
        <span class="prompt-icon" id="prompt-icon">ðŸ“</span>
        <span class="prompt-text" id="prompt-text">Log game?</span>
        <button class="prompt-yes" id="prompt-yes-btn" type="button" onclick="acceptClipboard()" ontouchend="event.preventDefault(); acceptClipboard();">âœ“</button>
        <button class="prompt-no" id="prompt-no-btn" type="button" onclick="dismissClipboard()" ontouchend="event.preventDefault(); dismissClipboard();">âœ•</button>
    </div>
    
    <!-- Return-from-Game Prompt -->
    <div class="return-prompt" id="return-prompt" style="display: none;">
        <button class="return-prompt-close" onclick="dismissReturnPrompt()">âœ•</button>
        <div class="return-prompt-header">
            <div class="return-prompt-icon" id="return-prompt-icon">ðŸŽ®</div>
            <div>
                <div class="return-prompt-title" id="return-prompt-title">Back from Wordle?</div>
                <div class="return-prompt-subtitle">How did it go?</div>
            </div>
        </div>
        <div class="return-prompt-actions">
            <button class="return-prompt-btn secondary" onclick="returnPromptNotYet()">Still Playing</button>
            <button class="return-prompt-btn primary" onclick="returnPromptLogManual()">Log Result</button>
        </div>
    </div>
    
    <!-- Hint FAB (Floating Action Button) -->
    <button class="hint-fab" id="hint-fab" onclick="openHintSheet()" title="Need a hint?">
        ðŸ’¡
        <span class="hint-fab-badge" id="hint-fab-badge" style="display: none;">!</span>
    </button>
    
    <!-- Hint Helper Bottom Sheet -->
    <div class="bottom-sheet-overlay" id="hint-sheet-overlay" onclick="closeHintSheet()">
        <div class="bottom-sheet hint-sheet" onclick="event.stopPropagation()">
            <div class="bottom-sheet-handle"></div>
            <button class="hint-sheet-close" onclick="closeHintSheet()" aria-label="Close hint sheet">Ã—</button>
            
            <div class="hint-sheet-header">
                <div class="hint-sheet-icon">ðŸ’¡</div>
                <div>
                    <div class="hint-sheet-title">Need a Hint?</div>
                    <div class="hint-sheet-subtitle">AI-powered hints without spoiling the fun</div>
                </div>
            </div>
            
            <!-- Detected Game Card -->
            <div class="hint-game-card detected" id="hint-game-card">
                <div class="hint-game-info">
                    <span class="hint-game-icon" id="hint-game-icon">ðŸ”—</span>
                    <div>
                        <div class="hint-game-name" id="hint-game-name">Connections</div>
                        <div class="hint-game-puzzle" id="hint-game-puzzle">#578 â€¢ January 25, 2026</div>
                    </div>
                </div>
                <div class="hint-detected-badge" id="hint-detected-badge">
                    <span>âœ“</span> Puzzle data detected
                </div>
            </div>
            
            <!-- User Input (when needed) -->
            <div class="hint-input-section" id="hint-input-section" style="display: none;">
                <div class="hint-input-label" id="hint-input-label">Which clue are you stuck on?</div>
                <input type="text" class="hint-input" id="hint-input" placeholder="e.g., 1-Across">
            </div>
            
            <!-- Hint Level Slider -->
            <div class="hint-level-control">
                <div class="hint-level-header">
                    <span class="hint-level-label">Hint Level</span>
                    <span class="hint-level-value" id="hint-level-value">4/10 â€¢ Nudge</span>
                </div>
                <input type="range" class="hint-level-slider" id="hint-level-slider" min="1" max="10" value="4" oninput="updateHintLevel(this.value)">
                <div class="hint-level-bar" id="hint-level-bar">
                    <div class="hint-level-segment active green"></div>
                    <div class="hint-level-segment active green"></div>
                    <div class="hint-level-segment active green"></div>
                    <div class="hint-level-segment active yellow"></div>
                    <div class="hint-level-segment"></div>
                    <div class="hint-level-segment"></div>
                    <div class="hint-level-segment"></div>
                    <div class="hint-level-segment"></div>
                    <div class="hint-level-segment"></div>
                    <div class="hint-level-segment"></div>
                </div>
                <div class="hint-level-desc" id="hint-level-desc">Clearer direction toward the answer</div>
            </div>
            
            <!-- Error Display -->
            <div class="hint-error" id="hint-error" style="display: none;"></div>
            
            <!-- Hint Result -->
            <div class="hint-result" id="hint-result" style="display: none;">
                <div class="hint-result-header">
                    <span>ðŸ’¡</span>
                    <span id="hint-result-level">Level 4 Hint</span>
                </div>
                <div class="hint-result-text" id="hint-result-text"></div>
                <div class="hint-actions">
                    <button class="hint-action-btn still-stuck" id="hint-still-stuck" onclick="hintStillStuck()">
                        ðŸ˜© Still Stuck
                    </button>
                    <button class="hint-action-btn got-it" onclick="hintGotIt()">
                        âœ… Got It!
                    </button>
                </div>
            </div>
            
            <!-- Hint History -->
            <div class="hint-history" id="hint-history" style="display: none;">
                <div class="hint-history-title">
                    <span>Previous Hints</span>
                    <button onclick="resetHintSession()" style="background: none; border: none; color: #f87171; font-size: 0.75rem; cursor: pointer;">Reset</button>
                </div>
                <div id="hint-history-list"></div>
            </div>
            
            <!-- Get Hint Button -->
            <button class="hint-get-btn" id="hint-get-btn" onclick="getHint()">
                ðŸ†˜ Get Level <span id="hint-btn-level">4</span> Hint
            </button>
            
            <!-- Other Games -->
            <div class="hint-other-games">
                <div class="hint-other-games-title">Or get hints for other games:</div>
                <div class="hint-game-chips" id="hint-game-chips">
                    <!-- NYT Games -->
                    <div class="hint-chip-category">NYT</div>
                    <div class="hint-game-chip" onclick="selectHintGame('connections')">ðŸ”— Connections</div>
                    <div class="hint-game-chip" onclick="selectHintGame('wordle')">ðŸŸ© Wordle</div>
                    <div class="hint-game-chip" onclick="selectHintGame('strands')">ðŸ”µ Strands</div>
                    <div class="hint-game-chip" onclick="selectHintGame('spellingbee')">ðŸ Spelling Bee</div>
                    <div class="hint-game-chip" onclick="selectHintGame('mini')">ðŸ“° Mini</div>
                    <div class="hint-game-chip" onclick="selectHintGame('letterboxed')">ðŸ“¦ Letterboxed</div>
                    <!-- LinkedIn Games -->
                    <div class="hint-chip-category">LinkedIn</div>
                    <div class="hint-game-chip" onclick="selectHintGame('queens')">ðŸ‘‘ Queens</div>
                    <div class="hint-game-chip" onclick="selectHintGame('tango')">ðŸ’ƒ Tango</div>
                    <div class="hint-game-chip" onclick="selectHintGame('pinpoint')">ðŸ“ Pinpoint</div>
                    <div class="hint-game-chip" onclick="selectHintGame('crossclimb')">ðŸ§— Crossclimb</div>
                    <div class="hint-game-chip" onclick="selectHintGame('zip')">âš¡ Zip</div>
                    <!-- Wordle Variants -->
                    <div class="hint-chip-category">Wordle+</div>
                    <div class="hint-game-chip" onclick="selectHintGame('quordle')">4ï¸âƒ£ Quordle</div>
                    <div class="hint-game-chip" onclick="selectHintGame('octordle')">8ï¸âƒ£ Octordle</div>
                    <div class="hint-game-chip" onclick="selectHintGame('dordle')">2ï¸âƒ£ Dordle</div>
                    <div class="hint-game-chip" onclick="selectHintGame('waffle')">ðŸ§‡ Waffle</div>
                    <div class="hint-game-chip" onclick="selectHintGame('nerdle')">ðŸ§® Nerdle</div>
                    <!-- Geography -->
                    <div class="hint-chip-category">Geography</div>
                    <div class="hint-game-chip" onclick="selectHintGame('worldle')">ðŸŒ Worldle</div>
                    <div class="hint-game-chip" onclick="selectHintGame('globle')">ðŸŒŽ Globle</div>
                    <div class="hint-game-chip" onclick="selectHintGame('tradle')">ðŸš¢ Tradle</div>
                    <div class="hint-game-chip" onclick="selectHintGame('travle')">âœˆï¸ Travle</div>
                    <div class="hint-game-chip" onclick="selectHintGame('wheretaken')">ðŸ“¸ WhereTaken</div>
                    <div class="hint-game-chip" onclick="selectHintGame('foodguessr')">ðŸ• FoodGuessr</div>
                    <!-- Entertainment -->
                    <div class="hint-chip-category">Movies & Music</div>
                    <div class="hint-game-chip" onclick="selectHintGame('framed')">ðŸŽ¬ Framed</div>
                    <div class="hint-game-chip" onclick="selectHintGame('actorle')">ðŸŽ­ Actorle</div>
                    <div class="hint-game-chip" onclick="selectHintGame('moviedle')">ðŸŽ¥ Moviedle</div>
                    <div class="hint-game-chip" onclick="selectHintGame('heardle')">ðŸŽµ Heardle</div>
                    <div class="hint-game-chip" onclick="selectHintGame('bandle')">ðŸŽ¸ Bandle</div>
                    <!-- Word/Semantic -->
                    <div class="hint-chip-category">Word Games</div>
                    <div class="hint-game-chip" onclick="selectHintGame('contexto')">ðŸŽ¯ Contexto</div>
                    <div class="hint-game-chip" onclick="selectHintGame('redactle')">â–ˆ Redactle</div>
                    <div class="hint-game-chip" onclick="selectHintGame('semantle')">ðŸ§  Semantle</div>
                    <!-- Other -->
                    <div class="hint-chip-category">Other</div>
                    <div class="hint-game-chip" onclick="selectHintGame('immaculate-grid')">âš¾ Immaculate Grid</div>
                    <div class="hint-game-chip" onclick="selectHintGame('costcodle')">ðŸ›’ Costcodle</div>
                    <!-- GS Originals -->
                    <div class="hint-chip-category">Game Shelf</div>
                    <div class="hint-game-chip" onclick="selectHintGame('quotle')">ðŸ’¬ Quotle</div>
                    <div class="hint-game-chip" onclick="selectHintGame('rungs')">ðŸªœ Rungs</div>
                    <div class="hint-game-chip" onclick="selectHintGame('slate')">ðŸ“ Slate</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Clipboard++ Monitor Badge -->
    <div class="clipboard-monitor-badge" id="clipboard-badge">
        <span>ðŸ“‹</span>
        <span>Watching clipboard...</span>
    </div>
    
    <!-- Pre-Launch Reminder Overlay -->
    <div class="prelaunch-reminder" id="prelaunch-reminder">
        <div class="prelaunch-content">
            <div class="prelaunch-icon">ðŸ“‹</div>
            <div class="prelaunch-text">Remember to <strong>copy</strong> your result!</div>
            <div class="prelaunch-subtext">Launching <span id="prelaunch-game-name">Game</span>...</div>
            <div class="prelaunch-progress"></div>
        </div>
    </div>
    
    <!-- Quick Capture Bottom Sheet -->
    <div class="bottom-sheet-overlay" id="quick-capture-sheet" onclick="closeQuickCapture()">
        <div class="bottom-sheet" onclick="event.stopPropagation()" style="max-height: 70vh;">
            <div class="bottom-sheet-handle"></div>
            <div class="bottom-sheet-header">âš¡ Quick Capture</div>
            <p style="color: var(--text-muted); font-size: 0.85rem; margin-bottom: 16px; text-align: center;">
                Tap a game you just played to log it
            </p>
            
            <div class="quick-capture-grid" id="quick-capture-grid">
                <!-- Populated by JS -->
            </div>
            
            <div style="text-align: center; padding-top: 8px; border-top: 1px solid var(--border);">
                <p style="color: var(--text-muted); font-size: 0.8rem; margin-bottom: 10px;">
                    ðŸ’¡ Tip: Copy your share text before returning for auto-detection
                </p>
                <button class="share-close-btn" onclick="closeQuickCapture()">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Nudge Received Banner -->
    <div class="nudge-banner" id="nudge-banner" style="display: none;">
        <div class="nudge-banner-content">
            <div class="nudge-banner-icon">ðŸ‘‹</div>
            <div class="nudge-banner-text">
                <div class="nudge-banner-title" id="nudge-banner-title">Friend is waiting!</div>
                <div class="nudge-banner-subtitle" id="nudge-banner-subtitle">Sarah nudged you to play</div>
            </div>
            <button class="nudge-banner-close" onclick="dismissNudgeBanner()">âœ•</button>
        </div>
    </div>
    
    <!-- TAP TO LOG CARD - Appears when user returns with clipboard content -->
    <div class="tap-to-log-card" id="tap-to-log-card" style="display: none;">
        <div class="tap-to-log-content" onclick="tapToLogClipboardWithDiff()">
            <div class="tap-to-log-icon" id="tap-to-log-icon">ðŸ“‹</div>
            <div class="tap-to-log-text">
                <div class="tap-to-log-title" id="tap-to-log-title">Just played a game?</div>
                <div class="tap-to-log-subtitle">Tap here to log your result</div>
            </div>
            <div class="tap-to-log-arrow">â†’</div>
        </div>
        <button class="tap-to-log-dismiss" onclick="dismissTapToLog(event)">âœ•</button>
    </div>
    
    <!-- CLIPBOARD NUDGE - Subtle banner for iOS gesture-deferred clipboard check -->
    <div class="clipboard-nudge" id="clipboard-nudge">
        <span class="clipboard-nudge-text" id="clipboard-nudge-text">ðŸŽ¯ Wordle result ready</span>
        <button class="clipboard-nudge-record" onclick="acceptClipboardNudge()">Record</button>
        <button class="clipboard-nudge-dismiss" onclick="dismissClipboardNudge()">âœ•</button>
    </div>
    
    <!-- Help Sheet -->
    <div class="bottom-sheet-overlay" id="help-sheet-overlay" onclick="closeHelpSheet()">
        <div class="bottom-sheet" onclick="event.stopPropagation()" style="max-height: 90vh;">
            <div class="bottom-sheet-handle"></div>
            <div class="help-sheet-content">
                <div class="bottom-sheet-header" style="padding: 16px; border-bottom: 1px solid var(--border);">
                    <h3 style="margin: 0; font-size: 1.1rem;">Help</h3>
                    <button style="background: none; border: none; font-size: 24px; color: var(--text-secondary); cursor: pointer; padding: 0; line-height: 1;" onclick="closeHelpSheet()">Ã—</button>
                </div>
                
                <!-- Search -->
                <div class="help-search-container">
                    <span class="help-search-icon">ðŸ”</span>
                    <input type="text" 
                           id="help-search-input" 
                           class="help-search-input" 
                           placeholder="Search FAQs..."
                           oninput="handleHelpSearch(this.value)">
                </div>
                
                <!-- Content Area -->
                <div class="help-content" id="help-content">
                    <!-- Populated by JS -->
                </div>
                
                <!-- Ask AI (Always Visible) -->
                <div class="help-ask-ai">
                    <div class="help-ask-ai-title">ðŸ¤– Can't find your answer?</div>
                    <button class="help-ask-ai-btn" onclick="showAskAI()">Ask AI</button>
                </div>
                
                <!-- Bottom Actions -->
                <div class="help-bottom-actions">
                    <div class="help-action-item" onclick="helpReportIssue()">
                        <span class="help-action-icon">ðŸ’¬</span>
                        <span class="help-action-text">Send Feedback</span>
                    </div>
                    <div class="help-action-item" onclick="helpStartTutorial()">
                        <span class="help-action-icon">ðŸ“–</span>
                        <span class="help-action-text">How to Use Game Shelf</span>
                    </div>
                    <div class="help-action-item" onclick="helpShowAbout()">
                        <span class="help-action-icon">ðŸŽ®</span>
                        <span class="help-action-text">About Game Shelf</span>
                    </div>
                    <div class="help-action-item" onclick="helpShowWhatsNew()">
                        <span class="help-action-icon">ðŸŽ‰</span>
                        <span class="help-action-text">What's New</span>
                        <span class="help-action-badge" id="help-whats-new-badge" style="display: none;">NEW</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- AI Help Sheet -->
    <div class="bottom-sheet-overlay" id="ai-help-sheet-overlay" onclick="closeAIHelpSheet()">
        <div class="bottom-sheet" onclick="event.stopPropagation()" style="max-height: 85vh;">
            <div class="bottom-sheet-handle"></div>
            <div class="ai-help-sheet-content">
                <div class="bottom-sheet-header" style="padding: 16px; border-bottom: 1px solid var(--border);">
                    <h3 style="margin: 0; font-size: 1.1rem;">ðŸ¤– AI Help</h3>
                    <button style="background: none; border: none; font-size: 24px; color: var(--text-secondary); cursor: pointer; padding: 0; line-height: 1;" onclick="closeAIHelpSheet()">Ã—</button>
                </div>
                
                <div class="ai-help-body">
                    <!-- Intro -->
                    <div class="ai-help-intro" id="ai-help-intro">
                        <div class="ai-help-intro-icon">ðŸ’¬</div>
                        <div class="ai-help-intro-text">Ask me anything about Game Shelf - how features work, troubleshooting, or tips!</div>
                    </div>
                    
                    <!-- Input Area -->
                    <div class="ai-help-input-area" id="ai-help-input-area">
                        <textarea 
                            id="ai-help-input" 
                            class="ai-help-input" 
                            placeholder="Type your question..."
                            rows="2"
                            onkeydown="if(event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); submitAIHelp(); }"
                        ></textarea>
                        <div class="ai-help-submit-row">
                            <span class="ai-help-cost" id="ai-help-cost">ðŸ’Ž 5 tokens</span>
                            <button class="ai-help-ask-btn" id="ai-help-submit-btn" onclick="submitAIHelp()">
                                <span>Ask</span>
                                <span>â†’</span>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Response Area -->
                    <div class="ai-help-response-area" id="ai-help-response-area">
                        <div class="ai-help-response" id="ai-help-response">
                            <div class="ai-help-response-header">
                                <span>ðŸ¤–</span>
                                <span>AI Assistant</span>
                            </div>
                            <div class="ai-help-response-text" id="ai-help-response-text"></div>
                        </div>
                        <div class="ai-help-ask-another">
                            <button class="ai-help-another-btn" onclick="resetAIHelp()">Ask another question</button>
                        </div>
                    </div>
                </div>
                
                <div class="ai-help-footer">
                    <div class="ai-help-footer-text">AI responses may not always be accurate. For bugs, use Send Feedback.</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- BIG SUCCESS CELEBRATION - Full screen, impossible to miss -->
    <div class="celebration-overlay" id="celebration-overlay">
        <div class="celebration-content">
            <div class="celebration-confetti" id="celebration-confetti"></div>
            <div class="celebration-emoji" id="celebration-emoji">ðŸŽ‰</div>
            <div class="celebration-title">NICE!</div>
            <div class="celebration-game">
                <span class="celebration-game-icon" id="celebration-game-icon">ðŸŸ©</span>
                <span class="celebration-game-name" id="celebration-game-name">Wordle</span>
            </div>
            <div class="celebration-score" id="celebration-score">3/6</div>
            <div class="celebration-streak" id="celebration-streak">ðŸ”¥ 47 day streak!</div>
            
            <div class="celebration-actions">
                <button class="celebration-btn primary" id="celebration-next-btn" onclick="celebrationPlayNext()">
                    <span id="celebration-next-icon">ðŸ”—</span>
                    <span id="celebration-next-text">Play Connections</span>
                </button>
                <button class="celebration-btn secondary" onclick="celebrationShare()">
                    <span>ðŸ“¤</span>
                    <span>Share Result</span>
                </button>
            </div>
            
            <div class="celebration-done" onclick="closeCelebration()">Done for now</div>
        </div>
    </div>
    
    <!-- RECORDING TUTORIAL - First time ANY game launch -->
    <div class="recording-tutorial-overlay" id="recording-tutorial-overlay">
        <div class="recording-tutorial-modal">
            <!-- Step 1: The Workflow -->
            <div class="tutorial-step active" data-step="1">
                <div class="tutorial-icon">ðŸ“‹</div>
                <h2 style="color: #ffffff !important; font-size: 1.5rem; font-weight: 700;">Recording Your Games</h2>
                
                <div class="tutorial-visual">
                    <div class="tutorial-phone">
                        <div class="tutorial-phone-screen">
                            <div class="tutorial-game-result">ðŸŸ©ðŸŸ¨â¬›ðŸŸ©ðŸŸ©</div>
                            <div class="tutorial-share-btn">Share â†—</div>
                        </div>
                    </div>
                    <div class="tutorial-arrow">â†’</div>
                    <div class="tutorial-copy-icon">ðŸ“‹</div>
                </div>
                
                <div class="tutorial-steps-list">
                    <div class="tutorial-step-item">
                        <span class="step-num">1</span>
                        <span>Tap the game's <strong>Share</strong> button</span>
                    </div>
                    <div class="tutorial-step-item">
                        <span class="step-num">2</span>
                        <span>Choose <strong>"Copy"</strong> to clipboard</span>
                    </div>
                    <div class="tutorial-step-item">
                        <span class="step-num">3</span>
                        <span>Come back here - we'll detect it! âœ¨</span>
                    </div>
                </div>
                
                <button class="tutorial-btn primary" onclick="recordingTutorialNext()">Next â†’</button>
                <button class="tutorial-btn ghost" onclick="skipRecordingTutorial()">Skip</button>
            </div>
            
            <!-- Step 2: What We Track -->
            <div class="tutorial-step" data-step="2">
                <div class="tutorial-icon">ðŸ“Š</div>
                <h2 style="color: #ffffff !important; font-size: 1.5rem; font-weight: 700;">Building Your Stats</h2>
                
                <p class="tutorial-desc">Every time you log a game, we track:</p>
                
                <div class="tutorial-benefits">
                    <div class="tutorial-benefit">
                        <span class="benefit-icon">ðŸ”¥</span>
                        <span>Streaks - Don't break the chain</span>
                    </div>
                    <div class="tutorial-benefit">
                        <span class="benefit-icon">ðŸ“ˆ</span>
                        <span>Win rate - How you're doing</span>
                    </div>
                    <div class="tutorial-benefit">
                        <span class="benefit-icon">â±ï¸</span>
                        <span>Speed - Quick solve bonus</span>
                    </div>
                    <div class="tutorial-benefit">
                        <span class="benefit-icon">ðŸ†</span>
                        <span>Best scores - Personal records</span>
                    </div>
                </div>
                
                <button class="tutorial-btn primary" onclick="recordingTutorialNext()">Next â†’</button>
            </div>
            
            <!-- Step 3: Share & Battle Teaser -->
            <div class="tutorial-step" data-step="3">
                <div class="tutorial-icon">ðŸ¤</div>
                <h2 style="color: #ffffff !important; font-size: 1.5rem; font-weight: 700;">Share & Battle</h2>
                
                <p class="tutorial-desc">Once you're logging games, you can:</p>
                
                <div class="tutorial-features">
                    <div class="tutorial-feature">
                        <div class="feature-header">
                            <span class="feature-icon">ðŸ“¤</span>
                            <span class="feature-title">Enhanced Share</span>
                        </div>
                        <p>Share beautiful result cards with friends</p>
                    </div>
                    <div class="tutorial-feature">
                        <div class="feature-header">
                            <span class="feature-icon">âš”ï¸</span>
                            <span class="feature-title">Brain Battles</span>
                        </div>
                        <p>Challenge friends to see who's really better!</p>
                    </div>
                </div>
                
                <p class="tutorial-cta">But first, let's play a game!</p>
                
                <button class="tutorial-btn primary" onclick="completeRecordingTutorial()">
                    Got it! Launch <span id="tutorial-game-name">Game</span> â†’
                </button>
            </div>
        </div>
    </div>
    
    <!-- LAUNCH PREFERENCE MODAL - First time game launch -->
    <div class="launch-pref-overlay" id="launch-pref-overlay">
        <div class="launch-pref-modal">
            <div class="launch-pref-header">
                <span class="launch-pref-icon" id="launch-pref-icon">ðŸŸ©</span>
                <span class="launch-pref-title">How do you play <span id="launch-pref-game-name">Wordle</span>?</span>
            </div>
            
            <p class="launch-pref-subtitle">We'll take you to the right place so your stats and streaks are saved</p>
            
            <div class="launch-pref-options">
                <button class="launch-pref-option" id="launch-pref-app" onclick="selectLaunchPref('app')">
                    <span class="launch-pref-option-icon">ðŸ“±</span>
                    <div class="launch-pref-option-text">
                        <span class="launch-pref-option-title">In the <span id="launch-pref-app-name">NYT Games</span> app</span>
                        <span class="launch-pref-option-desc">Opens the app on your phone</span>
                    </div>
                </button>
                
                <button class="launch-pref-option" onclick="selectLaunchPref('browser')">
                    <span class="launch-pref-option-icon">ðŸŒ</span>
                    <div class="launch-pref-option-text">
                        <span class="launch-pref-option-title">In my browser</span>
                        <span class="launch-pref-option-desc">Opens the website</span>
                    </div>
                </button>
            </div>
            
            <div class="launch-pref-footer">
                <span>You can change this later in Settings</span>
            </div>
        </div>
    </div>
    
    <!-- LAUNCH VERIFY MODAL - Did we get it right? -->
    <div class="launch-verify-overlay" id="launch-verify-overlay">
        <div class="launch-verify-modal">
            <div class="launch-verify-header">
                <span class="launch-verify-icon" id="launch-verify-icon">ðŸŸ©</span>
                <span class="launch-verify-title">Did that open <span id="launch-verify-game-name">Wordle</span> correctly?</span>
            </div>
            
            <p class="launch-verify-subtitle" id="launch-verify-subtitle">With your stats and streaks?</p>
            
            <div class="launch-verify-options">
                <button class="launch-verify-btn success" onclick="verifyLaunchSuccess()">
                    <span>âœ“</span>
                    <span>Yes, it worked!</span>
                </button>
                
                <button class="launch-verify-btn fail" onclick="showLaunchFixOptions()">
                    <span>âœ—</span>
                    <span>No, something was wrong</span>
                </button>
            </div>
        </div>
    </div>
    
    <!-- LAUNCH FIX MODAL - Help them fix it -->
    <div class="launch-fix-overlay" id="launch-fix-overlay">
        <div class="launch-fix-modal">
            <div class="launch-fix-header">
                <span class="launch-fix-icon" id="launch-fix-icon">ðŸ”§</span>
                <span class="launch-fix-title">Let's fix that</span>
            </div>
            
            <p class="launch-fix-subtitle">What happened?</p>
            
            <div class="launch-fix-options">
                <button class="launch-fix-option" onclick="fixLaunchIssue('wrong-place')">
                    <span class="launch-fix-option-icon">ðŸ </span>
                    <span>Went to homepage, not the game</span>
                </button>
                
                <button class="launch-fix-option" onclick="fixLaunchIssue('no-stats')">
                    <span class="launch-fix-option-icon">ðŸ“Š</span>
                    <span>Game loaded but my stats weren't there</span>
                </button>
                
                <button class="launch-fix-option" onclick="fixLaunchIssue('try-other')">
                    <span class="launch-fix-option-icon">ðŸ”„</span>
                    <span>Try the other option (app/browser)</span>
                </button>
                
                <button class="launch-fix-option" onclick="fixLaunchIssue('custom-url')">
                    <span class="launch-fix-option-icon">âœï¸</span>
                    <span>Let me enter my own URL</span>
                </button>
            </div>
            
            <div class="launch-fix-cancel" onclick="closeLaunchFixModal()">Cancel</div>
        </div>
    </div>
    
    <!-- CUSTOM URL MODAL -->
    <div class="custom-url-overlay" id="custom-url-overlay">
        <div class="custom-url-modal">
            <div class="custom-url-header">
                <span class="custom-url-icon" id="custom-url-icon">âœï¸</span>
                <span class="custom-url-title">Enter your URL for <span id="custom-url-game-name">Wordle</span></span>
            </div>
            
            <p class="custom-url-subtitle">Paste the link you normally use to play</p>
            
            <input type="url" id="custom-url-input" class="custom-url-input" placeholder="https://..." />
            
            <div class="custom-url-actions">
                <button class="custom-url-btn cancel" onclick="closeCustomUrlModal()">Cancel</button>
                <button class="custom-url-btn save" onclick="saveCustomUrl()">Save & Try</button>
            </div>
        </div>
    </div>
    
    <!-- Toast -->
    <div class="toast" id="toast"></div>
    
    <!-- Account Modal -->
    <div class="bottom-sheet-overlay" id="account-sheet" onclick="closeAccountModal()">
        <div class="bottom-sheet" onclick="event.stopPropagation()">
            <div class="bottom-sheet-handle"></div>
            <div class="bottom-sheet-header">ðŸ‘¤ Account</div>
            <div id="modal-content">
                <!-- Populated by JS based on auth state -->
            </div>
        </div>
    </div>
    
    <!-- Confirmation Modal -->
    <div class="confirm-modal-overlay" id="confirm-modal-overlay" onclick="closeConfirmModal()">
        <div class="confirm-modal" onclick="event.stopPropagation()">
            <div class="confirm-modal-icon" id="confirm-modal-icon">âš ï¸</div>
            <div class="confirm-modal-title" id="confirm-modal-title">Are you sure?</div>
            <div class="confirm-modal-message" id="confirm-modal-message">This action cannot be undone.</div>
            <div class="confirm-modal-buttons">
                <button class="confirm-modal-btn cancel" onclick="closeConfirmModal()">Cancel</button>
                <button class="confirm-modal-btn secondary" id="confirm-modal-third" onclick="confirmModalThirdAction()" style="display: none;">Third</button>
                <button class="confirm-modal-btn secondary" id="confirm-modal-alt" onclick="confirmModalAltAction()" style="display: none;">Alt</button>
                <button class="confirm-modal-btn danger" id="confirm-modal-action" onclick="confirmModalAction()">Confirm</button>
            </div>
        </div>
    </div>
    
    <!-- Success Modal -->
    <div class="modal-overlay" id="success-modal" onclick="closeSuccessModal()">
        <div class="success-modal-content" onclick="event.stopPropagation()">
            <div class="success-celebration" id="success-celebration">ðŸŽ‰</div>
            <div class="success-icon" id="success-icon">ðŸŸ©</div>
            <div class="success-game" id="success-game">Wordle</div>
            <div class="success-score" id="success-score">3/6</div>
            <div class="success-points" id="success-points">+25 pts</div>
            <div class="success-streak" id="success-streak">ðŸ”¥ 5 day streak!</div>
            <div class="success-context" id="success-context" style="display: none;">
                <div class="success-context-item" id="success-context-games"></div>
                <div class="success-context-item" id="success-context-extra"></div>
            </div>
            
            <!-- Battle Impact Card (shown when game is part of active battle) -->
            <div class="battle-impact-card" id="battle-impact-card" style="display: none;">
                <div class="battle-impact-header">
                    <span>âš”ï¸</span>
                    <span>BATTLE UPDATE</span>
                </div>
                <div class="battle-impact-name" id="battle-impact-name">Weekend Warriors</div>
                <div class="battle-impact-stats">
                    <div class="battle-impact-stat">
                        <div class="battle-impact-stat-label">Your Score</div>
                        <div class="battle-impact-stat-value" id="battle-impact-score">85 pts</div>
                    </div>
                    <div class="battle-impact-stat">
                        <div class="battle-impact-stat-label">Position</div>
                        <div class="battle-impact-position" id="battle-impact-position">
                            <span>ðŸ¥ˆ</span>
                            <span>2nd of 4</span>
                        </div>
                    </div>
                    <div class="battle-impact-stat">
                        <div class="battle-impact-stat-label">Leader</div>
                        <div class="battle-impact-stat-value" id="battle-impact-leader">@John (92 pts)</div>
                    </div>
                    <div class="battle-impact-stat">
                        <div class="battle-impact-stat-label">Gap</div>
                        <div class="battle-impact-stat-value" id="battle-impact-gap">-7 pts</div>
                    </div>
                </div>
                <div class="battle-impact-tip" id="battle-impact-tip">
                    <span>ðŸ’¡</span>
                    <span>4 days remaining - stay consistent!</span>
                </div>
                <div class="battle-impact-actions">
                    <button class="battle-impact-btn" onclick="event.stopPropagation(); closeSuccessModal(); showBattleDetails(currentBattleImpact?.id)">View Battle</button>
                    <button class="battle-impact-btn primary" onclick="event.stopPropagation(); shareBattleProgress()">Share Progress</button>
                </div>
            </div>
            
            <div class="success-btn-row">
                <button class="success-share-btn" onclick="event.stopPropagation(); openInstantShare();">
                    <span>Share</span>
                    <span>ðŸ“¤</span>
                </button>
                <button class="success-done-btn" onclick="event.stopPropagation(); closeSuccessModal();">Done</button>
            </div>
        </div>
    </div>
    
    <!-- Instant Share Sheet -->
    <div class="instant-share-backdrop" id="instant-share-backdrop" onclick="closeInstantShare()"></div>
    <div class="instant-share-sheet" id="instant-share-sheet">
        <div class="instant-share-header">
            <h3>ðŸ“¤ Share Result</h3>
            <button class="instant-share-close" onclick="closeInstantShare()">âœ•</button>
        </div>
        
        <div class="instant-share-preview">
            <textarea class="instant-share-textarea" id="instant-share-preview" rows="5" placeholder="Your share message..."></textarea>
        </div>
        
        <div class="instant-share-platforms">
            <button class="instant-platform-btn" style="background: #000;" onclick="instantShareTo('twitter')">
                <span class="icon">ð•</span>
                <span>Twitter</span>
            </button>
            <button class="instant-platform-btn" style="background: #5865F2;" onclick="instantShareTo('discord')">
                <span class="icon">ðŸ’¬</span>
                <span>Discord</span>
            </button>
            <button class="instant-platform-btn" style="background: #FF4500;" onclick="instantShareTo('reddit')">
                <span class="icon">ðŸ”´</span>
                <span>Reddit</span>
            </button>
            <button class="instant-platform-btn" style="background: #0085FF;" onclick="instantShareTo('bluesky')">
                <span class="icon">ðŸ¦‹</span>
                <span>Bluesky</span>
            </button>
        </div>
        
        <div class="instant-share-actions">
            <button class="instant-copy-btn" onclick="copyInstantShare()">
                <span>ðŸ“‹</span>
                <span>Copy</span>
            </button>
            <button class="instant-native-btn" onclick="nativeInstantShare()">
                <span>ðŸ“¤</span>
                <span>Share</span>
            </button>
        </div>
        
        <!-- Image Card Section -->
        <div class="image-card-section">
            <h4>ðŸ–¼ï¸ Share as Image</h4>
            
            <!-- Format Toggle -->
            <div class="image-format-toggle">
                <button class="image-format-btn active" onclick="setImageFormat('landscape')" data-format="landscape">
                    <span>ðŸ–¼ï¸</span> Post
                </button>
                <button class="image-format-btn" onclick="setImageFormat('story')" data-format="story">
                    <span>ðŸ“±</span> Story
                </button>
            </div>
            
            <div class="image-card-styles">
                <button class="image-style-btn active" onclick="setImageStyle('default')" data-style="default">Classic</button>
                <button class="image-style-btn" onclick="setImageStyle('dark')" data-style="dark">Dark</button>
                <button class="image-style-btn" onclick="setImageStyle('gradient')" data-style="gradient">Gradient</button>
                <button class="image-style-btn" onclick="setImageStyle('minimal')" data-style="minimal">Minimal</button>
            </div>
            <div class="image-card-preview" id="image-card-preview-container">
                <canvas id="share-card-canvas" width="600" height="400"></canvas>
            </div>
            <div class="image-card-actions">
                <button class="image-download-btn" onclick="downloadShareCard()">
                    <span>â¬‡ï¸</span>
                    <span>Download</span>
                </button>
                <button class="image-share-btn" onclick="shareCardImage()">
                    <span>ðŸ“¤</span>
                    <span>Share Image</span>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Streak Milestone Celebration -->
    <div class="milestone-overlay" id="milestone-overlay" onclick="closeMilestone()">
        <div class="milestone-content" onclick="event.stopPropagation()">
            <div class="milestone-flames">ðŸ”¥</div>
            <div class="milestone-number" id="milestone-number">50</div>
            <div class="milestone-label">Day Streak!</div>
            <div class="milestone-game" id="milestone-game">ðŸŸ© Wordle</div>
            <div class="milestone-message" id="milestone-message">Incredible dedication!</div>
            <div class="milestone-btn-row">
                <button class="milestone-share-btn" onclick="event.stopPropagation(); shareMilestone();">
                    <span>Share</span>
                    <span>ðŸŽ‰</span>
                </button>
                <button class="milestone-close-btn" onclick="event.stopPropagation(); closeMilestone();">Nice!</button>
            </div>
        </div>
    </div>
    
    <!-- Confetti Container -->
    <div class="confetti-container" id="confetti-container"></div>
    
    <!-- Sound Customizer Modal -->
    <div class="modal-overlay" id="sound-customizer-modal" onclick="closeSoundCustomizer()" style="z-index: 1500;">
        <div class="bottom-sheet" onclick="event.stopPropagation()" style="max-height: 85vh;">
            <div class="bottom-sheet-handle"></div>
            <div class="bottom-sheet-header">
                <h2 style="margin: 0;">ðŸŽµ Customize Sounds</h2>
            </div>
            <p style="font-size: 0.85rem; color: var(--text-secondary); margin: 0 0 15px;">
                Choose which sound plays for each action. Tap â–¶ï¸ to preview.
            </p>
            
            <div id="sound-events-list" style="flex: 1; overflow-y: auto; margin: 0 -20px; padding: 0 20px; max-height: 50vh;">
                <!-- Populated by renderSoundCustomizer() -->
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border);">
                <button class="btn btn-secondary" onclick="resetSoundDefaults()" style="flex: 0 0 auto; padding: 12px 16px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 10px; color: var(--text-primary); cursor: pointer;">Reset</button>
                <button class="btn btn-primary" onclick="closeSoundCustomizer()" style="flex: 1; padding: 12px 16px; background: var(--accent-purple); border: none; border-radius: 10px; color: white; cursor: pointer; font-weight: 600;">Done</button>
            </div>
        </div>
    </div>
    
    <!-- Merch Store Bottom Sheet -->
    <div class="bottom-sheet-overlay" id="merch-sheet" onclick="closeMerchStore()">
        <div class="bottom-sheet" onclick="event.stopPropagation()">
            <div class="bottom-sheet-handle"></div>
            <div class="bottom-sheet-header">ðŸ›ï¸ Merch Store</div>
            
            <div class="merch-balance-bar">
                <span>Your Balance:</span>
                <span class="merch-balance-amount">ðŸª™ <span id="merch-balance">0</span></span>
            </div>
            
            <div class="merch-tabs">
                <button class="merch-tab active" onclick="filterMerch('all')">All</button>
                <button class="merch-tab" onclick="filterMerch('virtual')">ðŸ† Rewards</button>
                <button class="merch-tab" onclick="filterMerch('physical')">ðŸŽ Gifts</button>
            </div>
            
            <div id="merch-catalog" class="merch-catalog">
                <!-- Rendered by JS -->
            </div>
            
            <div style="text-align: center; font-size: 0.75rem; color: var(--text-muted); padding-top: 10px; border-top: 1px solid var(--border); margin-top: 10px;">
                Physical gifts fulfilled by Goody
            </div>
            
            <button class="share-close-btn" style="margin-top: 15px;" onclick="closeMerchStore()">Close</button>
        </div>
    </div>
    
    <!-- Create Battle Bottom Sheet -->
    <div class="bottom-sheet-overlay" id="create-battle-sheet" onclick="closeCreateBattle()">
        <div class="bottom-sheet" onclick="event.stopPropagation()" style="max-height: 85vh; overflow-y: auto;">
            <div class="bottom-sheet-handle"></div>
            <div class="bottom-sheet-header">âš”ï¸ Create Battle</div>
            
            <div class="battle-form-group">
                <label class="battle-form-label">Battle Name</label>
                <input type="text" class="battle-input" id="battle-name-input" placeholder="e.g., Weekend Showdown" maxlength="30">
            </div>
            
            <div class="battle-form-group">
                <label class="battle-form-label">Battle Type</label>
                <div class="battle-type-select" id="battle-type-select">
                    <div class="battle-type-option selected" data-type="total-score" onclick="selectBattleType(this)">
                        <div class="battle-type-icon">ðŸ†</div>
                        <div class="battle-type-info">
                            <div class="battle-type-name">Total Score</div>
                            <div class="battle-type-desc">Highest combined score wins</div>
                        </div>
                    </div>
                    <div class="battle-type-option" data-type="streak" onclick="selectBattleType(this)">
                        <div class="battle-type-icon">ðŸ”¥</div>
                        <div class="battle-type-info">
                            <div class="battle-type-name">Streak Challenge</div>
                            <div class="battle-type-desc">Play daily - miss a day, lose points</div>
                        </div>
                    </div>
                    <div class="battle-type-option" data-type="wins" onclick="selectBattleType(this)">
                        <div class="battle-type-icon">âœ…</div>
                        <div class="battle-type-info">
                            <div class="battle-type-name">Most Wins</div>
                            <div class="battle-type-desc">Each game won = 1 point</div>
                        </div>
                    </div>
                    <div class="battle-type-option" data-type="perfect" onclick="selectBattleType(this)">
                        <div class="battle-type-icon">ðŸŽ¯</div>
                        <div class="battle-type-info">
                            <div class="battle-type-name">Perfect Hunter</div>
                            <div class="battle-type-desc">Only perfect scores count</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="battle-form-group">
                <label class="battle-form-label">Select Games</label>
                <button class="select-games-btn" onclick="openGameSelector()">
                    <span>ðŸŽ®</span>
                    <span id="selected-games-count">Select games for battle...</span>
                </button>
                <div class="selected-games-preview" id="selected-games-preview">
                    <!-- Filled dynamically -->
                </div>
                <div id="battle-game-select" style="display: none;">
                    <!-- Hidden container for tracking selected games -->
                </div>
            </div>
            
            <div class="battle-form-group">
                <label class="battle-form-label">Duration</label>
                <select class="battle-input" id="battle-duration" onchange="updateBattleRulesPreview()">
                    <option value="1">1 Day - Quick Match</option>
                    <option value="3" selected>3 Days - Weekend Battle</option>
                    <option value="7">7 Days - Weekly War</option>
                    <option value="14">14 Days - Championship</option>
                </select>
            </div>
            
            <div class="battle-form-group">
                <label class="battle-form-label">Stakes</label>
                <div class="battle-stake-select" id="battle-stake-select" style="display: flex; gap: 8px; margin-bottom: 8px;">
                    <div class="battle-stake-option selected" data-stake="friendly" onclick="selectBattleStake(this)" style="flex: 1; padding: 12px 8px; text-align: center; background: var(--bg-tertiary); border-radius: 8px; cursor: pointer; border: 2px solid var(--accent-purple); transition: all 0.2s;">
                        <div style="font-size: 1.2rem;">ðŸ¤</div>
                        <div style="font-size: 0.8rem; font-weight: 600;">Friendly</div>
                    </div>
                    <div class="battle-stake-option" data-stake="coins" onclick="selectBattleStake(this)" style="flex: 1; padding: 12px 8px; text-align: center; background: var(--bg-tertiary); border-radius: 8px; cursor: pointer; border: 2px solid transparent; transition: all 0.2s;">
                        <div style="font-size: 1.2rem;">ðŸª™</div>
                        <div style="font-size: 0.8rem; font-weight: 600;">Coins</div>
                    </div>
                    <div class="battle-stake-option" data-stake="tokens" onclick="selectBattleStake(this)" style="flex: 1; padding: 12px 8px; text-align: center; background: var(--bg-tertiary); border-radius: 8px; cursor: pointer; border: 2px solid transparent; transition: all 0.2s;">
                        <div style="font-size: 1.2rem;">ðŸŽŸï¸</div>
                        <div style="font-size: 0.8rem; font-weight: 600;">Tokens</div>
                    </div>
                </div>
                <!-- Amount input (hidden for Friendly) -->
                <div id="stake-amount-container" style="display: none;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span id="stake-amount-icon" style="font-size: 1.2rem;">ðŸª™</span>
                        <input type="number" class="battle-input" id="battle-stake-amount" min="1" max="5" value="1" style="flex: 1; text-align: center; font-size: 1.1rem;" onchange="validateStakeAmount()">
                        <span id="stake-amount-label" style="font-size: 0.85rem; color: var(--text-muted);">coins (max 5)</span>
                    </div>
                </div>
                <!-- Hidden field for legacy compatibility -->
                <select class="battle-input" id="battle-entry-fee" style="display: none;">
                    <option value="0" selected>Free</option>
                </select>
            </div>
            
            <!-- Public/Private Toggle -->
            <div class="battle-visibility-toggle" onclick="toggleBattleVisibility()">
                <div class="battle-visibility-info">
                    <span class="battle-visibility-icon" id="battle-visibility-icon">ðŸ”’</span>
                    <div>
                        <div class="battle-visibility-text" id="battle-visibility-text">Private Battle</div>
                        <div class="battle-visibility-desc" id="battle-visibility-desc">Only people with code can join</div>
                    </div>
                </div>
                <input type="checkbox" id="battle-public-toggle" style="width: 50px; height: 28px; accent-color: var(--accent-purple);">
            </div>
            
            <!-- Integrity Notice -->
            <div id="battle-integrity-notice" style="background: var(--bg-tertiary); border-radius: 8px; padding: 10px 12px; margin-top: 12px; font-size: 0.8rem; color: var(--text-muted);">
                ðŸ¤ Battles run on trust - like a friendly golf wager. Play fair!
            </div>
            
            <!-- Battle Rules Preview -->
            <div class="battle-rules-preview" id="battle-rules-preview">
                <div class="rules-modal-content" id="battle-rules-content">
                    <!-- Generated by updateBattleRulesPreview() -->
                </div>
            </div>
            
            <button id="create-battle-btn" class="share-close-btn btn-disabled" style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; margin-top: 10px; opacity: 0.5; pointer-events: none; cursor: not-allowed;" onclick="createBattle()">Create Battle</button>
            <button class="share-close-btn" style="margin-top: 10px;" onclick="closeCreateBattle()">Cancel</button>
        </div>
    </div>
    
    <!-- Join Battle Bottom Sheet -->
    <div class="bottom-sheet-overlay" id="join-battle-sheet" onclick="closeJoinBattle()">
        <div class="bottom-sheet" onclick="event.stopPropagation()">
            <div class="bottom-sheet-handle"></div>
            <div class="bottom-sheet-header">ðŸ” Join Battle</div>
            
            <div class="battle-form-group">
                <label class="battle-form-label">Enter Battle Code</label>
                <input type="text" class="battle-input" id="join-code-input" placeholder="e.g., ABC123" maxlength="6" style="text-transform: uppercase; text-align: center; font-size: 1.5rem; letter-spacing: 4px;" oninput="this.value = this.value.toUpperCase()">
            </div>
            
            <div id="join-battle-preview" style="display: none;">
                <!-- Battle Info -->
                <div style="padding: 15px; background: var(--bg-tertiary); border-radius: 10px; margin-bottom: 15px;">
                    <div style="font-weight: 700; font-size: 1.1rem;" id="join-battle-name"></div>
                    <div style="font-size: 0.85rem; color: var(--text-muted); margin-top: 4px;" id="join-battle-info"></div>
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <div style="flex: 1; text-align: center; padding: 8px; background: var(--bg-secondary); border-radius: 8px;">
                            <div style="font-size: 0.7rem; color: var(--text-muted);">Type</div>
                            <div style="font-weight: 600;" id="join-battle-type">ðŸ† Total Score</div>
                        </div>
                        <div style="flex: 1; text-align: center; padding: 8px; background: var(--bg-secondary); border-radius: 8px;">
                            <div style="font-size: 0.7rem; color: var(--text-muted);">Entry</div>
                            <div style="font-weight: 600;" id="join-battle-fee">Free</div>
                        </div>
                        <div style="flex: 1; text-align: center; padding: 8px; background: var(--bg-secondary); border-radius: 8px;">
                            <div style="font-size: 0.7rem; color: var(--text-muted);">Days Left</div>
                            <div style="font-weight: 600;" id="join-battle-days">3</div>
                        </div>
                    </div>
                </div>
                
                <!-- Rules Preview (scrollable) -->
                <div class="battle-rules-preview" id="join-battle-rules">
                    <div class="rules-modal-content" id="join-battle-rules-content">
                        <!-- Generated when battle found -->
                    </div>
                </div>
                
                <!-- Join Button (disabled until agreed) -->
                <button id="join-battle-btn" class="share-close-btn btn-disabled" style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; margin-top: 15px; opacity: 0.5; pointer-events: none; cursor: not-allowed;">Join Battle</button>
            </div>
            
            <div id="join-battle-error" style="display: none; color: var(--accent-red); padding: 10px; text-align: center;"></div>
            
            <button id="find-battle-btn" class="share-close-btn" style="background: linear-gradient(135deg, #667eea, #764ba2); color: white;" onclick="lookupBattleCode()">Find Battle</button>
            <button class="share-close-btn" style="margin-top: 10px;" onclick="closeJoinBattle()">Cancel</button>
        </div>
    </div>
    
    <!-- Game Selector Modal -->
    <div class="game-selector-overlay" id="game-selector-overlay" onclick="closeGameSelector()">
        <div class="game-selector-modal" onclick="event.stopPropagation()">
            <div class="game-selector-header">
                <h3>ðŸŽ® Select Games</h3>
                <button class="game-selector-close" onclick="closeGameSelector()">âœ•</button>
            </div>
            <div class="game-selector-body" id="game-selector-body">
                <!-- Populated dynamically -->
            </div>
            <div class="game-selector-footer">
                <div class="game-selector-count">
                    <span id="game-selector-count-text">0 games selected</span>
                </div>
                <button class="game-selector-done" onclick="confirmGameSelection()">Done</button>
            </div>
        </div>
    </div>
    
    <!-- Battle Details Bottom Sheet -->
    <div class="bottom-sheet-overlay" id="battle-details-sheet" onclick="closeBattleDetails()">
        <div class="bottom-sheet" onclick="event.stopPropagation()" style="max-height: 85vh; overflow-y: auto;">
            <div class="bottom-sheet-handle"></div>
            <div class="bottom-sheet-header" id="battle-details-title">âš”ï¸ Battle Details</div>
            
            <div id="battle-status-banner" style="padding: 10px; border-radius: 10px; text-align: center; margin-bottom: 15px; font-weight: 600;"></div>
            
            <!-- Battle Type Badge -->
            <div id="battle-type-badge" style="display: flex; align-items: center; gap: 10px; padding: 12px; background: var(--bg-tertiary); border-radius: 10px; margin-bottom: 15px;">
                <span id="battle-type-icon" style="font-size: 1.5rem;">ðŸ†</span>
                <div>
                    <div id="battle-type-name" style="font-weight: 700;">Total Score</div>
                    <div id="battle-type-desc" style="font-size: 0.8rem; color: var(--text-muted);">Highest combined score wins</div>
                </div>
            </div>
            
            <div style="display: flex; gap: 15px; margin-bottom: 15px;">
                <div style="flex: 1; text-align: center;">
                    <div style="font-size: 0.75rem; color: var(--text-muted);">Games</div>
                    <div style="font-weight: 600;" id="battle-games-display">-</div>
                </div>
                <div style="flex: 1; text-align: center;">
                    <div style="font-size: 0.75rem; color: var(--text-muted);">Time Left</div>
                    <div style="font-weight: 600;" id="battle-time-display">-</div>
                </div>
                <div style="flex: 1; text-align: center;" id="battle-prize-display">
                    <div style="font-size: 0.75rem; color: var(--text-muted);">Prize Pool</div>
                    <div style="font-weight: 600; color: var(--accent-gold);" id="battle-prize-amount">-</div>
                </div>
            </div>
            
            <div id="battle-share-code" style="display: none; background: linear-gradient(135deg, rgba(102, 126, 234, 0.15), rgba(118, 75, 162, 0.1)); padding: 16px; border-radius: 12px; margin-bottom: 15px; border: 1px solid var(--accent-purple);">
                <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 8px; text-align: center;">ðŸ“¨ Invite friends to join!</div>
                <div style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 12px;">
                    <div style="font-size: 0.75rem; color: var(--text-muted);">Code:</div>
                    <div style="font-size: 1.8rem; font-weight: 700; letter-spacing: 4px; color: var(--accent-purple);" id="battle-code-display"></div>
                </div>
                <div style="display: flex; gap: 8px;">
                    <button style="flex: 1; padding: 10px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 0.85rem; font-weight: 500; cursor: pointer;" onclick="copyBattleCode()">ðŸ“‹ Copy Code</button>
                    <button style="flex: 1; padding: 10px; background: var(--accent-purple); border: none; border-radius: 8px; color: white; font-size: 0.85rem; font-weight: 600; cursor: pointer;" onclick="shareBattleInvite()">ðŸ“¤ Share Invite</button>
                </div>
            </div>
            
            <div style="font-weight: 600; margin-bottom: 10px;">ðŸ† Leaderboard</div>
            <div id="battle-leaderboard-display">
                <!-- Populated by JS -->
            </div>
            
            <button class="share-close-btn" style="margin-top: 15px;" onclick="closeBattleDetails()">Close</button>
        </div>
    </div>
    
    <!-- Battle Results Modal (shown when battle completes) -->
    <div class="battle-results-modal" id="battle-results-modal" onclick="closeBattleResults()">
        <div class="battle-results-content" onclick="event.stopPropagation()">
            <div class="battle-results-trophy" id="battle-results-trophy">ðŸ†</div>
            <div class="battle-results-title" id="battle-results-title">VICTORY!</div>
            <div class="battle-results-name" id="battle-results-name">Weekend Warriors</div>
            
            <!-- Your Stats -->
            <div class="battle-results-stats" id="battle-results-stats">
                <div class="battle-results-stat-row">
                    <span class="battle-results-stat-label">Final Score</span>
                    <span class="battle-results-stat-value" id="battle-results-score">312 pts</span>
                </div>
                <div class="battle-results-stat-row">
                    <span class="battle-results-stat-label">Perfect Games</span>
                    <span class="battle-results-stat-value" id="battle-results-perfects">5</span>
                </div>
                <div class="battle-results-stat-row">
                    <span class="battle-results-stat-label">Games Played</span>
                    <span class="battle-results-stat-value" id="battle-results-played">12/14</span>
                </div>
                <div class="battle-results-stat-row" id="battle-results-margin-row">
                    <span class="battle-results-stat-label">Win Margin</span>
                    <span class="battle-results-stat-value" id="battle-results-margin">+14 pts</span>
                </div>
            </div>
            
            <!-- Prize (for winners) -->
            <div class="battle-results-prize" id="battle-results-prize" style="display: none;">
                <div class="battle-results-prize-label">ðŸŽ‰ PRIZE WON</div>
                <div class="battle-results-prize-amount" id="battle-results-prize-amount">120 tokens</div>
            </div>
            
            <!-- Final Standings -->
            <div class="battle-results-standings">
                <h4>Final Standings</h4>
                <div id="battle-results-standings-list">
                    <!-- Populated by JS -->
                </div>
            </div>
            
            <!-- Tips for non-winners -->
            <div class="battle-results-tips" id="battle-results-tips" style="display: none;">
                <h4>ðŸ’¡ What could have helped</h4>
                <div id="battle-results-tips-list">
                    <!-- Populated by JS -->
                </div>
            </div>
            
            <!-- Actions -->
            <div class="battle-results-actions">
                <button class="battle-results-btn secondary" onclick="closeBattleResults()">Close</button>
                <button class="battle-results-btn primary" id="battle-results-share-btn" onclick="shareBattleResult()">Share ðŸ“¤</button>
            </div>
            
            <!-- Rematch option -->
            <button style="width: 100%; margin-top: 10px; padding: 12px; background: transparent; border: 1px solid var(--border); border-radius: 10px; color: var(--text-secondary); font-size: 0.9rem; cursor: pointer;" onclick="startRematch()" id="battle-results-rematch">
                ðŸ”„ Challenge to Rematch
            </button>
        </div>
    </div>
    
    <!-- Referral Bottom Sheet -->
    <div class="bottom-sheet-overlay" id="referral-sheet" onclick="closeReferralSheet()">
        <div class="bottom-sheet" onclick="event.stopPropagation()" style="max-height: 85vh;">
            <div class="bottom-sheet-handle"></div>
            <div class="bottom-sheet-header">ðŸŽ Invite Friends</div>
            
            <!-- Earnings Summary -->
            <div class="referral-earnings">
                <div class="referral-earnings-total">
                    <span class="referral-earnings-value" id="referral-total-earned">0</span>
                    <span class="referral-earnings-label">ðŸŽŸï¸ tokens earned</span>
                </div>
                <div class="referral-stats">
                    <div class="referral-stat">
                        <span class="referral-stat-value" id="referral-invites-sent">0</span>
                        <span class="referral-stat-label">Invites Sent</span>
                    </div>
                    <div class="referral-stat">
                        <span class="referral-stat-value" id="referral-friends-joined">0</span>
                        <span class="referral-stat-label">Friends Joined</span>
                    </div>
                    <div class="referral-stat">
                        <span class="referral-stat-value" id="referral-friends-engaged">0</span>
                        <span class="referral-stat-label">Purchased</span>
                    </div>
                </div>
            </div>
            
            <!-- Your Invite Link -->
            <div class="referral-code-section">
                <div class="referral-code-label">Your Invite Link</div>
                <div class="referral-code-box">
                    <span id="referral-link-display">Loading...</span>
                    <button class="referral-copy-btn" onclick="copyReferralLink()">ðŸ“‹</button>
                </div>
            </div>
            
            <!-- Share Buttons -->
            <div class="referral-share-section">
                <div class="referral-share-label">Share via</div>
                <div class="referral-share-buttons">
                    <button class="referral-share-btn" onclick="shareReferral('sms')" style="background: #34C759;">ðŸ’¬ Text</button>
                    <button class="referral-share-btn" onclick="shareReferral('email')" style="background: #007AFF;">âœ‰ï¸ Email</button>
                    <button class="referral-share-btn" onclick="shareReferral('twitter')" style="background: #000;">ð•</button>
                    <button class="referral-share-btn" onclick="shareReferral('native')" style="background: var(--accent-purple);">ðŸ“¤ Share</button>
                </div>
            </div>
            
            <!-- Reward Tiers -->
            <div class="referral-tiers">
                <div class="referral-tiers-title">How It Works</div>
                <div class="referral-tier">
                    <div class="referral-tier-icon">ðŸ“¨</div>
                    <div class="referral-tier-info">
                        <div class="referral-tier-name">Send Invite</div>
                        <div class="referral-tier-desc">Share your link</div>
                    </div>
                    <div class="referral-tier-reward">+10 ðŸŽŸï¸</div>
                </div>
                <div class="referral-tier">
                    <div class="referral-tier-icon">ðŸ‘‹</div>
                    <div class="referral-tier-info">
                        <div class="referral-tier-name">Friend Joins</div>
                        <div class="referral-tier-desc">They sign up + you become friends!</div>
                    </div>
                    <div class="referral-tier-reward">+50 ðŸŽŸï¸</div>
                </div>
                <div class="referral-tier">
                    <div class="referral-tier-icon">â­</div>
                    <div class="referral-tier-info">
                        <div class="referral-tier-name">Friend Buys Coins</div>
                        <div class="referral-tier-desc">They make their first purchase</div>
                    </div>
                    <div class="referral-tier-reward">+100 ðŸŽŸï¸</div>
                </div>
                <div class="referral-tier-total">
                    <span>Total per friend:</span>
                    <span class="referral-tier-reward">160 ðŸŽŸï¸</span>
                </div>
            </div>
            
            <!-- Have a code section -->
            <div style="margin-top: 20px; padding-top: 16px; border-top: 1px solid var(--border);">
                <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 8px;">Have a friend's code?</div>
                <div style="display: flex; gap: 8px; align-items: stretch;">
                    <input type="text" id="referral-friend-code-input" 
                           placeholder="ABCD1234" maxlength="8" 
                           style="flex: 1; min-width: 0; padding: 12px; border: 2px solid var(--border); border-radius: 10px; font-size: 1rem; font-family: monospace; text-align: center; letter-spacing: 2px; text-transform: uppercase; background: var(--bg-primary); color: var(--text-primary); box-sizing: border-box;"
                           oninput="this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, '')">
                    <button onclick="addFriendFromReferralSheet()" style="flex-shrink: 0; padding: 12px 20px; background: var(--accent-purple); border: none; border-radius: 10px; color: white; font-weight: 600; cursor: pointer; white-space: nowrap;">
                        Connect
                    </button>
                </div>
                <div id="referral-friend-error" style="display: none; color: var(--accent-red); padding: 8px; text-align: center; font-size: 0.8rem;"></div>
            </div>
            
            <!-- Find from Contacts -->
            <div class="contact-finder-section">
                <button class="contact-finder-btn" id="referral-contact-finder-btn" onclick="findFriendsFromContacts()">
                    <span>ðŸ“±</span>
                    <span>Find Friends from Contacts</span>
                </button>
                <div class="contact-finder-hint">
                    See which of your contacts are already on Game Shelf
                </div>
            </div>
            
            <button class="share-close-btn" style="margin-top: 15px;" onclick="closeReferralSheet()">Close</button>
        </div>
    </div>
    
    <!-- Add Friend Bottom Sheet -->
    <div class="bottom-sheet-overlay" id="add-friend-sheet" onclick="closeAddFriend()">
        <div class="bottom-sheet" onclick="event.stopPropagation()" style="max-height: 85vh;">
            <div class="bottom-sheet-handle"></div>
            <div class="bottom-sheet-header">ðŸ‘¥ Invite & Connect</div>
            
            <!-- Your Invite Code -->
            <div class="friend-code-display">
                <div class="friend-code-label">Your Invite Code</div>
                <div class="friend-code-value" id="my-friend-code">--------</div>
                <div class="friend-code-actions">
                    <button class="friend-code-btn secondary" onclick="copyFriendCode()">ðŸ“‹ Copy Code</button>
                    <button class="friend-code-btn primary" onclick="shareFriendLink()">ðŸ“¤ Share Link</button>
                </div>
                <div style="font-size: 0.75rem; color: var(--text-muted); margin-top: 8px; text-align: center;">
                    New users get ðŸŽŸï¸ 100 tokens â€¢ You get ðŸŽŸï¸ 50 tokens
                </div>
            </div>
            
            <!-- Add by Code -->
            <div class="friend-input-section">
                <div class="friend-input-label">Enter Friend's Invite Code</div>
                <input type="text" class="friend-code-input" id="add-friend-code-input" 
                       placeholder="ABCD1234" maxlength="8" 
                       oninput="this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, '')">
                <button onclick="addFriendByCode()" style="width: 100%; padding: 14px; background: linear-gradient(135deg, #667eea, #764ba2); border: none; border-radius: 12px; color: white; font-weight: 600; font-size: 0.95rem; cursor: pointer; margin-top: 12px;">
                    Find & Connect
                </button>
                <div id="add-friend-error" style="display: none; color: var(--accent-red); padding: 10px; text-align: center; font-size: 0.85rem;"></div>
            </div>
            
            <!-- Find from Contacts -->
            <div class="contact-finder-section">
                <button class="contact-finder-btn" id="contact-finder-btn" onclick="findFriendsFromContacts()">
                    <span>ðŸ“±</span>
                    <span>Find Friends from Contacts</span>
                </button>
                <div class="contact-finder-hint" id="contact-finder-hint">
                    See which of your contacts are already on Game Shelf
                </div>
            </div>
            
            <button class="share-close-btn" style="margin-top: 20px;" onclick="closeAddFriend()">Close</button>
        </div>
    </div>
    
    <!-- Contact Finder Results Sheet -->
    <div class="bottom-sheet-overlay" id="contact-results-sheet" onclick="closeContactResults()">
        <div class="bottom-sheet" onclick="event.stopPropagation()" style="max-height: 80vh;">
            <div class="bottom-sheet-handle"></div>
            <div class="bottom-sheet-header">ðŸ“± Friends on Game Shelf</div>
            
            <div id="contact-results-content">
                <!-- Populated by JS -->
            </div>
            
            <button class="share-close-btn" style="margin-top: 15px;" onclick="closeContactResults()">Done</button>
        </div>
    </div>
    
    <!-- Suggest Game Bottom Sheet -->
    <div class="bottom-sheet-overlay" id="suggest-game-sheet" onclick="closeSuggestGame()">
        <div class="bottom-sheet" onclick="event.stopPropagation()">
            <div class="bottom-sheet-handle"></div>
            <div class="bottom-sheet-header">ðŸ’¡ Suggest a Game</div>
            
            <p style="color: var(--text-muted); font-size: 0.85rem; margin-bottom: 16px;">
                Know a daily puzzle game we should add? Let us know!
            </p>
            
            <div style="margin-bottom: 12px;">
                <label style="font-size: 0.85rem; font-weight: 600; display: block; margin-bottom: 6px;">Game Name *</label>
                <input type="text" id="suggest-game-name" placeholder="e.g., Worldle" 
                       style="width: 100%; padding: 12px; border: 2px solid var(--border); border-radius: 10px; font-size: 0.95rem; background: var(--bg-primary); color: var(--text-primary); box-sizing: border-box;">
            </div>
            
            <div style="margin-bottom: 12px;">
                <label style="font-size: 0.85rem; font-weight: 600; display: block; margin-bottom: 6px;">Game URL *</label>
                <input type="url" id="suggest-game-url" placeholder="https://example.com" 
                       style="width: 100%; padding: 12px; border: 2px solid var(--border); border-radius: 10px; font-size: 0.95rem; background: var(--bg-primary); color: var(--text-primary); box-sizing: border-box;">
            </div>
            
            <div style="margin-bottom: 16px;">
                <label style="font-size: 0.85rem; font-weight: 600; display: block; margin-bottom: 6px;">Category</label>
                <select id="suggest-game-category" 
                        style="width: 100%; padding: 12px; border: 2px solid var(--border); border-radius: 10px; font-size: 0.95rem; background: var(--bg-primary); color: var(--text-primary); box-sizing: border-box;">
                    <option value="">Select category...</option>
                    <option value="word">Word Games</option>
                    <option value="geography">Geography</option>
                    <option value="entertainment">Entertainment</option>
                    <option value="sports">Sports</option>
                    <option value="other">Other</option>
                </select>
            </div>
            
            <div id="suggest-game-error" style="display: none; color: var(--accent-red); padding: 8px; text-align: center; font-size: 0.85rem; margin-bottom: 12px;"></div>
            
            <button onclick="submitGameSuggestion()" style="width: 100%; padding: 14px; background: linear-gradient(135deg, #667eea, #764ba2); border: none; border-radius: 12px; color: white; font-weight: 600; font-size: 0.95rem; cursor: pointer;">
                Submit Suggestion
            </button>
            
            <button class="share-close-btn" style="margin-top: 12px;" onclick="closeSuggestGame()">Cancel</button>
        </div>
    </div>
    
    <!-- Friend Confirm Bottom Sheet -->
    <div class="bottom-sheet-overlay" id="friend-confirm-sheet" onclick="closeFriendConfirm()">
        <div class="bottom-sheet" onclick="event.stopPropagation()">
            <div class="bottom-sheet-handle"></div>
            <div class="bottom-sheet-header">ðŸ‘‹ Add Friend?</div>
            
            <div class="profile-header" id="friend-confirm-profile">
                <!-- Populated by JS -->
            </div>
            
            <div class="profile-actions">
                <button class="profile-action-btn secondary" onclick="closeFriendConfirm()">Cancel</button>
                <button class="profile-action-btn primary" id="confirm-add-friend-btn" onclick="confirmAddFriend()">âœ“ Add Friend</button>
            </div>
        </div>
    </div>
    
    <!-- Profile View Bottom Sheet -->
    <div class="bottom-sheet-overlay" id="profile-view-sheet" onclick="closeProfileView()">
        <div class="bottom-sheet" onclick="event.stopPropagation()" style="max-height: 90vh;">
            <div class="bottom-sheet-handle"></div>
            
            <div class="profile-header" id="profile-view-header">
                <!-- Populated by JS -->
            </div>
            
            <div style="padding: 0 16px 16px;">
                <!-- Recent Activity -->
                <div style="font-weight: 600; margin-bottom: 10px; font-size: 0.9rem; color: var(--text-muted);">ðŸ“Š Recent Games</div>
                <div id="profile-recent-games" style="margin-bottom: 20px;">
                    <!-- Populated by JS -->
                </div>
                
                <div class="profile-actions" id="profile-view-actions">
                    <!-- Populated by JS -->
                </div>
            </div>
            
            <button class="share-close-btn" style="margin: 0 16px 16px;" onclick="closeProfileView()">Close</button>
        </div>
    </div>
    
    <!-- Activity Summary Modal -->
    <div class="bottom-sheet-overlay" id="activity-summary-sheet" onclick="closeActivitySummary()">
        <div class="bottom-sheet" onclick="event.stopPropagation()" style="max-height: 85vh;">
            <div class="bottom-sheet-handle"></div>
            <div class="bottom-sheet-header">ðŸ‘‹ Welcome Back!</div>
            
            <div id="activity-summary-content" style="max-height: 60vh; overflow-y: auto;">
                <!-- Generated by showActivitySummary() -->
            </div>
            
            <button class="share-close-btn" style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; margin-top: 15px;" onclick="closeActivitySummary()">Got It!</button>
        </div>
    </div>
    
    <!-- Achievements Bottom Sheet -->
    <div class="bottom-sheet-overlay" id="achievements-sheet" onclick="closeAchievements()">
        <div class="bottom-sheet" onclick="event.stopPropagation()">
            <div class="bottom-sheet-handle"></div>
            <div class="bottom-sheet-header">ðŸ† Achievements</div>
            
            <div class="achievements-header">
                <span>Your Progress</span>
                <span class="achievements-progress" id="achievements-count">0/14</span>
            </div>
            <div class="achievements-progress-bar">
                <div class="achievements-progress-fill" id="achievements-fill" style="width: 0%"></div>
            </div>
            
            <div class="achievements-grid" id="achievements-grid">
                <!-- Populated by JS -->
            </div>
            
            <button class="share-close-btn" style="margin-top: 15px;" onclick="closeAchievements()">Close</button>
        </div>
    </div>
    
    <script>
        // ============ FIREBASE CONFIG ============
        const firebaseConfig = {
            apiKey: "AIzaSyBQVwn8vOrFTzLlm2MYIPBwgZV2xR9AuhM",
            authDomain: "word-boxing.firebaseapp.com",
            databaseURL: "https://word-boxing-default-rtdb.firebaseio.com",
            projectId: "word-boxing"
        };
        
        // Initialize Firebase with graceful fallback
        let auth = null;
        let db = null;
        let firebaseAvailable = false;
        
        try {
            if (typeof firebase !== 'undefined') {
                firebase.initializeApp(firebaseConfig);
                auth = firebase.auth();
                db = firebase.database();
                firebaseAvailable = true;
                console.log('[Firebase] Initialized successfully');
                
                // Set auth persistence for PWA
                auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL).catch(e => {
                    console.log('Auth persistence error:', e);
                });
            } else {
                console.warn('[Firebase] SDK not loaded - running in offline mode');
            }
        } catch (e) {
            console.error('[Firebase] Initialization failed:', e);
            console.warn('[Firebase] Running in offline mode');
        }
        
        // ============ APP STATE ============
        let currentUser = null;
        let appData = null;
        let detectedClipboard = null;
        
        // ============ URL UTILITIES ============
        // Dynamic base URL - works for any deployment location
        function getReferralBaseUrl() {
            // Get origin + pathname, but remove index.html if present
            let base = window.location.origin + window.location.pathname;
            // Remove trailing index.html or similar
            base = base.replace(/\/index\.html$/, '').replace(/\/$/, '');
            return base;
        }
        
        // ============ SECURITY UTILITIES ============
        // Escape HTML to prevent XSS attacks from user-generated content
        function escapeHtml(text) {
            if (text === null || text === undefined) return '';
            const div = document.createElement('div');
            div.textContent = String(text);
            return div.innerHTML;
        }
        
        // Escape for use in HTML attributes (onclick handlers, etc.)
        function escapeAttr(text) {
            if (text === null || text === undefined) return '';
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/'/g, '&#39;')
                .replace(/"/g, '&quot;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        }
        
        // Sanitize text input - removes HTML/script tags and limits length
        // Use for user-generated content before storing in database
        function sanitizeTextInput(text, maxLength = 50) {
            if (text === null || text === undefined) return '';
            return String(text)
                .replace(/<[^>]*>/g, '')           // Remove HTML tags
                .replace(/[<>'"&]/g, '')           // Remove dangerous chars
                .trim()
                .slice(0, maxLength);
        }
        
        // Validate display name - only alphanumeric, spaces, basic punctuation
        function isValidDisplayName(name) {
            if (!name || typeof name !== 'string') return false;
            if (name.length < 1 || name.length > 30) return false;
            // Allow letters, numbers, spaces, hyphens, underscores, periods
            return /^[a-zA-Z0-9 ._-]+$/.test(name);
        }
        
        // ============ FRIENDS SYSTEM ============
        let friendsData = [];
        let friendsMap = new Map(); // O(1) friend lookups by UID
        let friendsActivity = [];
        let friendsShelfData = {};
        let pendingFriendUid = null;
        let pendingFriendData = null;
        let viewingProfileUid = null;
        
        // Helper for O(1) friend lookup
        function getFriend(uid) {
            return friendsMap.get(uid);
        }
        
        function isFriend(uid) {
            return friendsMap.has(uid);
        }
        
        // Generate profile link (still useful for viewing profiles)
        function getProfileLink(uid) {
            return `${getReferralBaseUrl()}/#profile=${uid || currentUser?.uid}`;
        }
        
        // Social tab switching
        function switchSocialTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.social-tab').forEach(tab => {
                const isActive = tab.dataset.socialTab === tabName;
                tab.classList.toggle('active', isActive);
                tab.style.color = isActive ? 'var(--text-primary)' : 'var(--text-muted)';
                tab.style.borderBottomColor = isActive ? 'var(--accent-purple)' : 'transparent';
            });
            
            // Update tab content
            document.querySelectorAll('.social-tab-content').forEach(content => {
                content.style.display = content.id === `social-tab-${tabName}` ? 'block' : 'none';
            });
            
            // Load data for tab
            if (tabName === 'friends') {
                renderFriendsList();
                renderFriendsLeaderboard();
            } else if (tabName === 'activity') {
                renderActivityFeed();
            } else if (tabName === 'battles') {
                renderBattles();
                loadPublicBattles();
            }
        }
        
        // Show Add Friend sheet
        function showAddFriend() {
            if (!currentUser) {
                showToast('Sign in to connect with friends', 'error');
                return;
            }
            // Show the user's referral code (unified invite code)
            document.getElementById('my-friend-code').textContent = getReferralCode();
            document.getElementById('add-friend-code-input').value = '';
            document.getElementById('add-friend-error').style.display = 'none';
            document.getElementById('add-friend-sheet').classList.add('active');
        }
        
        function closeAddFriend() {
            document.getElementById('add-friend-sheet').classList.remove('active');
        }
        
        // Copy invite code (referral code)
        function copyFriendCode() {
            const code = getReferralCode();
            navigator.clipboard.writeText(code).then(() => {
                showToast('ðŸ“‹ Invite code copied!');
            }).catch(() => {
                showToast('Could not copy code', 'error');
            });
        }
        
        // Share invite link (uses referral link)
        function shareFriendLink() {
            const link = getReferralLink();
            const message = `Join me on Game Shelf! ðŸŽ®\n\nTrack daily puzzles, compete in battles, and build streaks together.\n\nâœ¨ You'll get 50 bonus tokens when you sign up!\n\n${link}`;
            
            if (navigator.share) {
                navigator.share({
                    title: 'Join me on Game Shelf!',
                    text: message,
                    url: link
                }).catch(() => {
                    navigator.clipboard.writeText(message).then(() => {
                        showToast('ðŸ“‹ Invite copied!');
                    }).catch(() => {
                        showToast('Could not copy invite', 'error');
                    });
                });
            } else {
                navigator.clipboard.writeText(message).then(() => {
                    showToast('ðŸ“‹ Invite copied!');
                }).catch(() => {
                    showToast('Could not copy invite', 'error');
                });
            }
            
            // Track invite sent
            if (!appData.referral) appData.referral = { invitesSent: 0 };
            appData.referral.invitesSent++;
            appData.wallet.tokens += REFERRAL_REWARDS.sent;
            saveData();
            
            closeAddFriend();
        }
        
        // Add friend by invite code (looks up referral code)
        async function addFriendByCode() {
            const code = document.getElementById('add-friend-code-input').value.trim().toUpperCase();
            const errorEl = document.getElementById('add-friend-error');
            
            if (code.length !== 8) {
                errorEl.textContent = 'Enter an 8-character code';
                errorEl.style.display = 'block';
                return;
            }
            
            if (code === getReferralCode()) {
                errorEl.textContent = "That's your own code!";
                errorEl.style.display = 'block';
                return;
            }
            
            errorEl.style.display = 'none';
            showToast('ðŸ” Looking up friend...');
            
            try {
                // Look up by referral code
                const snapshot = await db.ref(`referralCodes/${code}`).once('value');
                const referralData = snapshot.val();
                
                if (!referralData) {
                    errorEl.textContent = 'Code not found. Check and try again.';
                    errorEl.style.display = 'block';
                    return;
                }
                
                const friendUid = referralData.ownerId;
                
                // Check if already friends
                const existingFriend = friendsData.find(f => f.odataId === friendUid);
                if (existingFriend) {
                    errorEl.textContent = 'Already connected!';
                    errorEl.style.display = 'block';
                    return;
                }
                
                // Get their profile
                const profileSnapshot = await db.ref('gameshelf-public/' + friendUid).once('value');
                const profileData = profileSnapshot.val() || { displayName: referralData.ownerName || 'Player' };
                
                // Show confirmation
                closeAddFriend();
                showFriendConfirm(friendUid, profileData);
                
            } catch (e) {
                console.error('Friend lookup error:', e);
                errorEl.textContent = 'Could not find friend. Try again.';
                errorEl.style.display = 'block';
            }
        }
        
        // Handle friend link from URL
        async function handleFriendLink(friendUid) {
            if (!currentUser) {
                showToast('Sign in to add friends!');
                sessionStorage.setItem('pendingFriend', friendUid);
                return;
            }
            
            if (friendUid === currentUser.uid) {
                showToast("That's your own link!");
                return;
            }
            
            // Check if already friends
            const existingFriend = friendsData.find(f => f.odataId === friendUid);
            if (existingFriend) {
                showToast('Already friends!');
                return;
            }
            
            try {
                const snapshot = await db.ref('gameshelf-public/' + friendUid).once('value');
                const friendData = snapshot.val();
                
                if (!friendData) {
                    showToast('Friend not found');
                    return;
                }
                
                showFriendConfirm(friendUid, friendData);
            } catch (e) {
                console.error('Failed to fetch friend:', e);
                showToast('Could not find friend');
            }
        }
        
        // ============ CONTACT FINDER ============
        let contactFinderResults = [];
        
        // Check if Contact Picker API is supported
        function isContactPickerSupported() {
            return 'contacts' in navigator && 'ContactsManager' in window;
        }
        
        // Simple hash function for privacy (not cryptographic, just for matching)
        async function hashContact(value) {
            // Normalize: lowercase, remove spaces and special chars
            const normalized = value.toLowerCase().replace(/[\s\-\(\)\.]/g, '');
            
            // Use SubtleCrypto if available, otherwise simple hash
            if (window.crypto && window.crypto.subtle) {
                const encoder = new TextEncoder();
                const data = encoder.encode(normalized + '_gameshelf_salt');
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.slice(0, 8).map(b => b.toString(16).padStart(2, '0')).join('');
            } else {
                // Fallback simple hash
                let hash = 0;
                for (let i = 0; i < normalized.length; i++) {
                    const char = normalized.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return Math.abs(hash).toString(16).padStart(8, '0');
            }
        }
        
        // Store user's contact hashes for discovery
        async function publishContactHashes() {
            if (!currentUser) return;
            
            // Get user's email
            const email = currentUser.email;
            if (email) {
                const emailHash = await hashContact(email);
                await db.ref(`contact-hashes/${emailHash}`).set({
                    odataId: currentUser.uid,
                    displayName: currentUser.displayName || 'Player',
                    photoURL: currentUser.photoURL || null
                });
            }
        }
        
        // Find friends from contacts
        async function findFriendsFromContacts() {
            if (!currentUser) {
                showToast('Sign in to find friends', 'error');
                return;
            }
            
            const btn = document.getElementById('contact-finder-btn');
            const hint = document.getElementById('contact-finder-hint');
            
            // Check if Contact Picker API is supported
            if (!isContactPickerSupported()) {
                // Fallback: Show email entry option
                showManualContactFinder();
                return;
            }
            
            try {
                btn.disabled = true;
                btn.innerHTML = '<span>ðŸ”„</span><span>Accessing contacts...</span>';
                
                // Request contacts
                const props = ['name', 'email', 'tel'];
                const opts = { multiple: true };
                
                const contacts = await navigator.contacts.select(props, opts);
                
                if (!contacts || contacts.length === 0) {
                    btn.disabled = false;
                    btn.innerHTML = '<span>ðŸ“±</span><span>Find Friends from Contacts</span>';
                    showToast('No contacts selected');
                    return;
                }
                
                btn.innerHTML = '<span>ðŸ”</span><span>Searching...</span>';
                
                // Extract and hash contact info
                const hashes = [];
                for (const contact of contacts) {
                    if (contact.email) {
                        for (const email of contact.email) {
                            const hash = await hashContact(email);
                            hashes.push({ hash, name: contact.name?.[0] || 'Contact', type: 'email' });
                        }
                    }
                    if (contact.tel) {
                        for (const phone of contact.tel) {
                            const hash = await hashContact(phone);
                            hashes.push({ hash, name: contact.name?.[0] || 'Contact', type: 'phone' });
                        }
                    }
                }
                
                // Look up hashes in Firebase
                const matches = [];
                const existingFriendIds = friendsData.map(f => f.odataId);
                
                for (const { hash, name, type } of hashes) {
                    try {
                        const snapshot = await db.ref(`contact-hashes/${hash}`).once('value');
                        const userData = snapshot.val();
                        
                        if (userData && userData.odataId !== currentUser.uid) {
                            // Don't add duplicates or existing friends
                            if (!matches.find(m => m.odataId === userData.odataId) && 
                                !existingFriendIds.includes(userData.odataId)) {
                                matches.push({
                                    ...userData,
                                    contactName: name
                                });
                            }
                        }
                    } catch (e) {
                        // Hash not found, continue
                    }
                }
                
                contactFinderResults = matches;
                showContactResults(matches, contacts.length);
                
            } catch (e) {
                console.error('Contact picker error:', e);
                if (e.name === 'SecurityError' || e.name === 'InvalidStateError') {
                    showManualContactFinder();
                } else {
                    showToast('Could not access contacts', 'error');
                }
            } finally {
                btn.disabled = false;
                btn.innerHTML = '<span>ðŸ“±</span><span>Find Friends from Contacts</span>';
            }
        }
        
        // Show manual contact finder (fallback for unsupported browsers)
        function showManualContactFinder() {
            const content = document.getElementById('contact-results-content');
            content.innerHTML = `
                <div class="contact-empty-state">
                    <div class="contact-empty-icon">ðŸ“§</div>
                    <p style="margin-bottom: 15px;">Contact access not available on this browser.</p>
                    <p style="font-size: 0.85rem; margin-bottom: 20px;">Enter an email to check if they're on Game Shelf:</p>
                    <input type="email" id="manual-contact-email" placeholder="friend@email.com" 
                           style="width: 100%; padding: 12px; border: 2px solid var(--border); border-radius: 10px; font-size: 0.95rem; background: var(--bg-primary); color: var(--text-primary); margin-bottom: 12px; box-sizing: border-box;">
                    <button onclick="searchManualContact()" style="width: 100%; padding: 12px; background: var(--accent-purple); color: white; border: none; border-radius: 10px; font-weight: 600; cursor: pointer;">
                        Search
                    </button>
                </div>
            `;
            document.getElementById('contact-results-sheet').classList.add('active');
        }
        
        // Search for a manually entered contact
        async function searchManualContact() {
            const email = document.getElementById('manual-contact-email').value.trim();
            if (!email) {
                showToast('Enter an email address');
                return;
            }
            
            const hash = await hashContact(email);
            
            try {
                const snapshot = await db.ref(`contact-hashes/${hash}`).once('value');
                const userData = snapshot.val();
                
                if (userData && userData.odataId !== currentUser.uid) {
                    const existingFriendIds = friendsData.map(f => f.odataId);
                    if (existingFriendIds.includes(userData.odataId)) {
                        showToast('Already friends!');
                    } else {
                        contactFinderResults = [{ ...userData, contactName: email }];
                        showContactResults(contactFinderResults, 1);
                    }
                } else {
                    showContactResults([], 1);
                }
            } catch (e) {
                console.error('Search error:', e);
                showToast('Search failed', 'error');
            }
        }
        
        // Show contact search results
        function showContactResults(matches, totalSearched) {
            const content = document.getElementById('contact-results-content');
            
            if (matches.length === 0) {
                content.innerHTML = `
                    <div class="contact-empty-state">
                        <div class="contact-empty-icon">ðŸ”</div>
                        <p>No matches found from ${totalSearched} contact${totalSearched !== 1 ? 's' : ''}.</p>
                        <p style="font-size: 0.85rem; margin-top: 10px;">Invite your friends to join Game Shelf!</p>
                        <button onclick="closeContactResults(); shareFriendLink();" 
                                style="margin-top: 15px; padding: 12px 24px; background: var(--accent-purple); color: white; border: none; border-radius: 10px; font-weight: 600; cursor: pointer;">
                            ðŸ“¤ Send Invite
                        </button>
                    </div>
                `;
            } else {
                content.innerHTML = `
                    <p style="color: var(--text-muted); font-size: 0.85rem; margin-bottom: 16px; text-align: center;">
                        Found ${matches.length} friend${matches.length !== 1 ? 's' : ''} from ${totalSearched} contact${totalSearched !== 1 ? 's' : ''}!
                    </p>
                    <div class="contact-results-list">
                        ${matches.map(m => `
                            <div class="contact-result-card" id="contact-result-${m.odataId}">
                                <div class="contact-result-avatar">
                                    ${m.photoURL ? `<img src="${escapeAttr(m.photoURL)}" style="width: 100%; height: 100%; border-radius: 50%; object-fit: cover;">` : escapeHtml((m.displayName || 'U')[0].toUpperCase())}
                                </div>
                                <div class="contact-result-info">
                                    <div class="contact-result-name">${escapeHtml(m.displayName || 'Player')}</div>
                                    <div class="contact-result-status">âœ“ On Game Shelf</div>
                                </div>
                                <button class="contact-result-add" onclick="addContactAsFriend('${escapeAttr(m.odataId)}', '${escapeAttr(m.displayName || 'Player')}')">
                                    + Add
                                </button>
                            </div>
                        `).join('')}
                    </div>
                `;
            }
            
            document.getElementById('contact-results-sheet').classList.add('active');
        }
        
        // Add a contact as friend
        async function addContactAsFriend(friendUid, displayName) {
            if (!currentUser) return;
            
            try {
                // Add friend (bidirectional)
                await db.ref('friends/' + currentUser.uid + '/' + friendUid).set({
                    odataId: friendUid,
                    displayName: displayName,
                    addedAt: Date.now()
                });
                
                await db.ref('friends/' + friendUid + '/' + currentUser.uid).set({
                    odataId: currentUser.uid,
                    displayName: currentUser.displayName || 'Player',
                    addedAt: Date.now()
                });
                
                // Update UI
                const btn = document.querySelector(`#contact-result-${friendUid} .contact-result-add`);
                if (btn) {
                    btn.classList.add('added');
                    btn.textContent = 'âœ“ Added';
                    btn.disabled = true;
                }
                
                SoundManager.play('success');
                showToast(`âœ“ Added ${displayName}!`, 'success');
                
                // Reload friends
                await loadFriendsData();
                renderFriendsList();
                renderFriendsLeaderboard();
                
            } catch (e) {
                console.error('Failed to add friend:', e);
                showToast('Could not add friend', 'error');
            }
        }
        
        function closeContactResults() {
            document.getElementById('contact-results-sheet').classList.remove('active');
        }
        
        // Show friend confirm sheet
        function showFriendConfirm(friendUid, friendData) {
            pendingFriendUid = friendUid;
            pendingFriendData = friendData;
            
            const profileHtml = `
                <div class="profile-avatar">
                    ${friendData.photoURL 
                        ? `<img src="${escapeAttr(friendData.photoURL)}" alt="">` 
                        : escapeHtml((friendData.displayName || 'U')[0].toUpperCase())}
                </div>
                <div class="profile-name">${escapeHtml(friendData.displayName || 'Puzzle Player')}</div>
                <div class="profile-subtitle">Wants to be puzzle buddies!</div>
                <div class="profile-stats">
                    <div class="profile-stat">
                        <div class="profile-stat-value">${parseInt(friendData.gamesTracked) || 0}</div>
                        <div class="profile-stat-label">Games</div>
                    </div>
                    <div class="profile-stat">
                        <div class="profile-stat-value">${parseInt(friendData.currentStreak) || 0}</div>
                        <div class="profile-stat-label">Day Streak</div>
                    </div>
                    <div class="profile-stat">
                        <div class="profile-stat-value">${parseInt(friendData.todayCount) || 0}</div>
                        <div class="profile-stat-label">Today</div>
                    </div>
                </div>
            `;
            
            document.getElementById('friend-confirm-profile').innerHTML = profileHtml;
            document.getElementById('friend-confirm-sheet').classList.add('active');
        }
        
        function closeFriendConfirm() {
            document.getElementById('friend-confirm-sheet').classList.remove('active');
            pendingFriendUid = null;
            pendingFriendData = null;
        }
        
        // Confirm add friend
        async function confirmAddFriend() {
            if (!currentUser || !pendingFriendUid) {
                showToast('Please sign in first', 'error');
                return;
            }
            
            try {
                // Add to my friends list
                await db.ref('friends/' + currentUser.uid + '/' + pendingFriendUid).set({
                    odataId: pendingFriendUid,
                    displayName: pendingFriendData?.displayName || 'Friend',
                    photoURL: pendingFriendData?.photoURL || null,
                    addedAt: Date.now()
                });
                
                // Also add me to their friends list (bidirectional)
                await db.ref('friends/' + pendingFriendUid + '/' + currentUser.uid).set({
                    odataId: currentUser.uid,
                    displayName: currentUser.displayName || 'Friend',
                    photoURL: currentUser.photoURL || null,
                    addedAt: Date.now()
                });
                
                closeFriendConfirm();
                showToast('âœ“ Friend added!');
                
                // Reload friends
                await loadFriendsData();
                renderFriendsList();
                renderFriendsLeaderboard();
                renderFriendsWidget();
                
            } catch (e) {
                console.error('Failed to add friend:', e);
                showToast('Could not add friend', 'error');
            }
        }
        
        // Load friends data from Firebase
        async function loadFriendsData() {
            if (!currentUser || !db) return;
            
            try {
                const snapshot = await db.ref('friends/' + currentUser.uid).once('value');
                const friendsObj = snapshot.val() || {};
                friendsData = Object.values(friendsObj);
                
                // Build O(1) lookup map
                friendsMap = new Map(friendsData.map(f => [f.odataId, f]));
                
                // Update count badge
                const countBadge = document.getElementById('friends-count-badge');
                if (countBadge) countBadge.textContent = friendsData.length;
                
                // Load each friend's public shelf data
                await loadFriendsShelfData();
                
            } catch (e) {
                console.error('Failed to load friends:', e);
            }
        }
        
        // Load friends' public shelf data (OPTIMIZED with parallel requests)
        async function loadFriendsShelfData() {
            if (!db || friendsData.length === 0) return;
            
            const today = getTodayString();
            friendsActivity = [];
            friendsShelfData = {};
            
            // Parallel fetch all friends (much faster than sequential)
            const promises = friendsData.map(friend => 
                db.ref('gameshelf-public/' + friend.odataId).once('value')
                    .then(snapshot => ({ friend, data: snapshot.val() }))
                    .catch(() => ({ friend, data: null }))
            );
            
            const results = await Promise.all(promises);
            
            // Process results
            results.forEach(({ friend, data }) => {
                if (data) {
                    friendsShelfData[friend.odataId] = data;
                    friend.shelfData = data;
                    
                    // Collect activity
                    if (data.lastActivity) {
                        friendsActivity.push({
                            odataId: friend.odataId,
                            displayName: data.displayName || friend.displayName,
                            photoURL: data.photoURL,
                            ...data.lastActivity
                        });
                    }
                }
            });
            
            // Sort by recency
            friendsActivity.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
            friendsActivity = friendsActivity.slice(0, 20);
        }
        
        // Publish public profile data
        async function publishPublicProfile() {
            if (!currentUser || !db || !appData) return;
            
            try {
                const today = getTodayString();
                const todayHistory = appData.history?.[today] || {};
                const todayCount = Object.keys(todayHistory).length;
                
                // Calculate current streak (v1.3.0: use local time, not UTC)
                let streak = 0;
                let checkDate = new Date();
                while (true) {
                    const dateStr = getLocalDateString(checkDate);
                    if (appData.history?.[dateStr] && Object.keys(appData.history[dateStr]).length > 0) {
                        streak++;
                        checkDate.setDate(checkDate.getDate() - 1);
                    } else {
                        break;
                    }
                }
                
                const publicData = {
                    displayName: currentUser.displayName || 'Puzzle Player',
                    photoURL: currentUser.photoURL || null,
                    inviteCode: getReferralCode(), // Unified invite code
                    gamesTracked: appData.games?.length || 0,
                    currentStreak: streak,
                    todayCount: todayCount,
                    lastUpdated: Date.now()
                };
                
                // Add last activity if there's history today
                if (todayCount > 0) {
                    const lastGameId = Object.keys(todayHistory).pop();
                    const lastGame = todayHistory[lastGameId];
                    publicData.lastActivity = {
                        gameId: lastGameId,
                        gameName: GAMES[lastGameId]?.name || lastGameId,
                        score: lastGame.score || 'âœ“',
                        date: today,
                        timestamp: lastGame.timestamp || Date.now()
                    };
                }
                
                await db.ref('gameshelf-public/' + currentUser.uid).set(publicData);
            } catch (e) {
                console.error('Failed to publish public profile:', e);
            }
        }
        
        // Render friends list
        function renderFriendsList() {
            const listEl = document.getElementById('friends-list');
            if (!listEl) return;
            
            if (friendsData.length === 0) {
                listEl.innerHTML = `
                    <div class="friend-empty">
                        <div class="friend-empty-icon">ðŸ‘¥</div>
                        <div class="friend-empty-text">No friends yet!<br>Add friends to compare scores.</div>
                    </div>
                `;
                return;
            }
            
            const today = getTodayString();
            
            listEl.innerHTML = friendsData.map(friend => {
                const shelfData = friend.shelfData || {};
                const todayCount = shelfData.todayCount || 0;
                const hasPlayed = todayCount > 0;
                const streak = shelfData.currentStreak || 0;
                const nudgeSent = hasNudgedToday(friend.odataId);
                
                // Determine status class and text
                let statusClass = hasPlayed ? 'played' : 'inactive';
                let statusText = hasPlayed ? `âœ“ ${parseInt(todayCount)} games today` : 'ðŸ˜´ Hasn\'t played yet';
                
                return `
                    <div class="friend-card" onclick="showFriendProfile('${escapeAttr(friend.odataId)}')">
                        <div class="friend-card-avatar">
                            ${shelfData.photoURL 
                                ? `<img src="${escapeAttr(shelfData.photoURL)}" alt="">` 
                                : escapeHtml((friend.displayName || 'U')[0].toUpperCase())}
                            <div class="${hasPlayed ? 'friend-active-dot' : 'friend-inactive-dot'}"></div>
                        </div>
                        <div class="friend-card-info">
                            <div class="friend-card-name">${escapeHtml(friend.displayName || 'Friend')}</div>
                            <div class="friend-card-status ${statusClass}">
                                ${statusText}
                            </div>
                        </div>
                        <div class="friend-card-actions">
                            ${!hasPlayed ? `
                                <button class="friend-card-nudge ${nudgeSent ? 'sent' : ''}" 
                                        onclick="event.stopPropagation(); nudgeFriend('${escapeAttr(friend.odataId)}', '${escapeAttr(friend.displayName || 'Friend')}')">
                                    ${nudgeSent ? 'âœ“ Nudged' : 'ðŸ‘‹ Nudge'}
                                </button>
                            ` : ''}
                            ${streak > 0 ? `<div class="friend-card-streak">ðŸ”¥ ${parseInt(streak)}</div>` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Render friends leaderboard
        function renderFriendsLeaderboard() {
            const listEl = document.getElementById('friends-leaderboard');
            if (!listEl) return;
            
            if (friendsData.length === 0 && !currentUser) {
                listEl.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-muted);">Add friends to see leaderboard</div>';
                return;
            }
            
            const today = getTodayString();
            
            // Build leaderboard array (friends + you)
            let leaderboard = [];
            
            // Add yourself
            if (currentUser && appData) {
                const myTodayCount = Object.keys(appData.history?.[today] || {}).length;
                let myStreak = 0;
                let checkDate = new Date();
                // v1.3.0: Use local time for history lookup, not UTC
                while (appData.history?.[getLocalDateString(checkDate)]?.length !== undefined || 
                       Object.keys(appData.history?.[getLocalDateString(checkDate)] || {}).length > 0) {
                    if (Object.keys(appData.history?.[getLocalDateString(checkDate)] || {}).length > 0) {
                        myStreak++;
                        checkDate.setDate(checkDate.getDate() - 1);
                    } else {
                        break;
                    }
                }
                
                leaderboard.push({
                    odataId: currentUser.uid,
                    displayName: 'You',
                    photoURL: currentUser.photoURL,
                    todayCount: myTodayCount,
                    streak: myStreak,
                    isYou: true
                });
            }
            
            // Add friends
            friendsData.forEach(friend => {
                const shelfData = friend.shelfData || {};
                leaderboard.push({
                    odataId: friend.odataId,
                    displayName: friend.displayName || 'Friend',
                    photoURL: shelfData.photoURL,
                    todayCount: shelfData.todayCount || 0,
                    streak: shelfData.currentStreak || 0,
                    isYou: false
                });
            });
            
            // Sort by today's count, then by streak
            leaderboard.sort((a, b) => {
                if (b.todayCount !== a.todayCount) return b.todayCount - a.todayCount;
                return b.streak - a.streak;
            });
            
            listEl.innerHTML = leaderboard.map((entry, i) => {
                const rank = i + 1;
                const rankClass = rank === 1 ? 'gold' : rank === 2 ? 'silver' : rank === 3 ? 'bronze' : '';
                const hasPlayed = entry.todayCount > 0;
                
                return `
                    <div class="leaderboard-row ${entry.isYou ? 'you' : ''} ${!hasPlayed ? 'not-played' : ''}" 
                         ${!entry.isYou ? `onclick="showFriendProfile('${escapeAttr(entry.odataId)}')"` : ''}>
                        <div class="leaderboard-rank ${rankClass}">${rank}</div>
                        <div class="leaderboard-avatar">
                            ${entry.photoURL 
                                ? `<img src="${escapeAttr(entry.photoURL)}" alt="" style="width:100%;height:100%;border-radius:50%;object-fit:cover;">` 
                                : escapeHtml((entry.displayName || 'U')[0].toUpperCase())}
                        </div>
                        <div class="leaderboard-name">${escapeHtml(entry.displayName)}${entry.streak > 0 ? ` ðŸ”¥${parseInt(entry.streak)}` : ''}</div>
                        <div class="leaderboard-score">${parseInt(entry.todayCount)} games</div>
                    </div>
                `;
            }).join('');
        }
        
        // Render activity feed
        function renderActivityFeed() {
            const feedEl = document.getElementById('activity-feed');
            if (!feedEl) return;
            
            if (friendsActivity.length === 0) {
                feedEl.innerHTML = `
                    <div class="friend-empty">
                        <div class="friend-empty-icon">ðŸ“°</div>
                        <div class="friend-empty-text">No recent activity<br>Activity appears when friends play games.</div>
                    </div>
                `;
                return;
            }
            
            feedEl.innerHTML = friendsActivity.map(activity => {
                const game = GAMES[activity.gameId] || { icon: 'ðŸŽ®', name: activity.gameName || activity.gameId };
                const timeAgo = getTimeAgo(activity.timestamp);
                
                return `
                    <div class="activity-item" onclick="showFriendProfile('${escapeAttr(activity.odataId)}')">
                        <div class="activity-avatar">
                            ${activity.photoURL 
                                ? `<img src="${escapeAttr(activity.photoURL)}" alt="" style="width:100%;height:100%;border-radius:50%;object-fit:cover;">` 
                                : escapeHtml((activity.displayName || 'U')[0].toUpperCase())}
                        </div>
                        <div class="activity-content">
                            <div class="activity-text">
                                <strong>${escapeHtml(activity.displayName)}</strong> played ${escapeHtml(game.name)}
                                ${activity.score ? `<span style="color: var(--text-muted);"> â€¢ ${escapeHtml(activity.score)}</span>` : ''}
                            </div>
                            <div class="activity-time">${escapeHtml(timeAgo)}</div>
                        </div>
                        <div class="activity-game-icon">${game.icon}</div>
                    </div>
                `;
            }).join('');
        }
        
        // Time ago helper
        function getTimeAgo(timestamp) {
            if (!timestamp) return '';
            const seconds = Math.floor((Date.now() - timestamp) / 1000);
            if (seconds < 60) return 'Just now';
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}h ago`;
            const days = Math.floor(hours / 24);
            return `${days}d ago`;
        }
        
        // Show friend profile
        function showFriendProfile(friendUid) {
            viewingProfileUid = friendUid;
            const friend = getFriend(friendUid); // O(1) lookup
            const shelfData = friend?.shelfData || friendsShelfData[friendUid] || {};
            
            const headerHtml = `
                <div class="profile-avatar">
                    ${shelfData.photoURL 
                        ? `<img src="${escapeAttr(shelfData.photoURL)}" alt="">` 
                        : escapeHtml((shelfData.displayName || friend?.displayName || 'U')[0].toUpperCase())}
                </div>
                <div class="profile-name">${escapeHtml(shelfData.displayName || friend?.displayName || 'Puzzle Player')}</div>
                <div class="profile-subtitle">ðŸŽ® ${parseInt(shelfData.gamesTracked) || 0} games tracked</div>
                <div class="profile-stats">
                    <div class="profile-stat">
                        <div class="profile-stat-value">${parseInt(shelfData.todayCount) || 0}</div>
                        <div class="profile-stat-label">Today</div>
                    </div>
                    <div class="profile-stat">
                        <div class="profile-stat-value">${parseInt(shelfData.currentStreak) || 0}</div>
                        <div class="profile-stat-label">Day Streak</div>
                    </div>
                </div>
            `;
            
            document.getElementById('profile-view-header').innerHTML = headerHtml;
            
            // Recent games (from last activity)
            let recentHtml = '';
            if (shelfData.lastActivity) {
                const game = GAMES[shelfData.lastActivity.gameId] || { icon: 'ðŸŽ®', name: shelfData.lastActivity.gameName };
                recentHtml = `
                    <div class="activity-item" style="cursor: default;">
                        <div class="activity-game-icon">${game.icon}</div>
                        <div class="activity-content">
                            <div class="activity-text">${escapeHtml(game.name)}</div>
                            <div class="activity-time">${escapeHtml(shelfData.lastActivity.score || 'Completed')} â€¢ ${escapeHtml(getTimeAgo(shelfData.lastActivity.timestamp))}</div>
                        </div>
                    </div>
                `;
            } else {
                recentHtml = '<div style="text-align: center; padding: 20px; color: var(--text-muted);">No recent games</div>';
            }
            document.getElementById('profile-recent-games').innerHTML = recentHtml;
            
            // Actions
            const isFriend = friendsData.some(f => f.odataId === friendUid);
            const hasPlayedToday = (shelfData.todayCount || 0) > 0;
            const nudgeSent = hasNudgedToday(friendUid);
            const displayName = shelfData.displayName || friend?.displayName || 'Friend';
            
            let actionsHtml = `
                <button class="profile-action-btn primary" onclick="startBattleWithFriend('${escapeAttr(friendUid)}', '${escapeAttr(displayName)}')">
                    âš”ï¸ Challenge to Battle
                </button>
            `;
            
            // Show nudge button if friend hasn't played today
            if (isFriend && !hasPlayedToday) {
                actionsHtml += `
                    <button class="profile-action-btn secondary" 
                            onclick="nudgeFriend('${escapeAttr(friendUid)}', '${escapeAttr(displayName)}')"
                            ${nudgeSent ? 'disabled style="opacity: 0.5;"' : ''}>
                        ${nudgeSent ? 'âœ“ Nudge sent today' : 'ðŸ‘‹ Nudge to Play'}
                    </button>
                `;
            }
            
            actionsHtml += isFriend 
                ? `<button class="profile-action-btn secondary" onclick="removeFriend('${escapeAttr(friendUid)}')" style="color: var(--accent-red);">Remove Friend</button>` 
                : `<button class="profile-action-btn secondary" onclick="closeProfileView(); handleFriendLink('${escapeAttr(friendUid)}')">Add Friend</button>`;
            
            document.getElementById('profile-view-actions').innerHTML = actionsHtml;
            
            document.getElementById('profile-view-sheet').classList.add('active');
        }
        
        function closeProfileView() {
            document.getElementById('profile-view-sheet').classList.remove('active');
            viewingProfileUid = null;
        }
        
        // Start battle with friend
        function startBattleWithFriend(friendUid, friendName) {
            closeProfileView();
            showCreateBattle();
            // Pre-fill with friend's name
            setTimeout(() => {
                const nameInput = document.getElementById('battle-name-input');
                if (nameInput) nameInput.value = `Battle vs ${friendName}`;
            }, 100);
        }
        
        // Remove friend
        async function removeFriend(friendUid) {
            if (!currentUser) return;
            
            if (!confirm('Remove this friend?')) return;
            
            try {
                // Remove from my list
                await db.ref('friends/' + currentUser.uid + '/' + friendUid).remove();
                // Remove me from their list
                await db.ref('friends/' + friendUid + '/' + currentUser.uid).remove();
                
                closeProfileView();
                showToast('Friend removed');
                
                await loadFriendsData();
                renderFriendsList();
                renderFriendsLeaderboard();
                renderFriendsWidget();
            } catch (e) {
                console.error('Failed to remove friend:', e);
                showToast('Could not remove friend', 'error');
            }
        }
        
        // ============ FRIEND NUDGE SYSTEM ============
        let sentNudgesToday = {}; // Track nudges sent today
        let receivedNudges = [];  // Nudges received from friends
        
        // Check if we already nudged this friend today
        function hasNudgedToday(friendUid) {
            const today = getTodayString();
            return sentNudgesToday[today]?.includes(friendUid) || false;
        }
        
        // Send a nudge to a friend
        async function nudgeFriend(friendUid, friendName) {
            if (!currentUser) {
                showToast('Sign in to nudge friends');
                return;
            }
            
            if (hasNudgedToday(friendUid)) {
                showToast('Already nudged today!');
                return;
            }
            
            try {
                const today = getTodayString();
                const nudgeData = {
                    fromUid: currentUser.uid,
                    fromName: currentUser.displayName || 'A friend',
                    timestamp: Date.now(),
                    date: today
                };
                
                // Store nudge in Firebase for the recipient
                await db.ref(`nudges/${friendUid}/${currentUser.uid}`).set(nudgeData);
                
                // Track that we sent this nudge today
                if (!sentNudgesToday[today]) sentNudgesToday[today] = [];
                sentNudgesToday[today].push(friendUid);
                
                // Save to localStorage
                localStorage.setItem('sentNudges', JSON.stringify(sentNudgesToday));
                
                SoundManager.play('success');
                showToast(`ðŸ‘‹ Nudged ${friendName}!`, 'success');
                
                // Re-render to show "Nudged" state
                renderFriendsList();
                
            } catch (e) {
                console.error('Failed to send nudge:', e);
                showToast('Could not send nudge', 'error');
            }
        }
        
        // Load sent nudges from localStorage
        function loadSentNudges() {
            try {
                const saved = localStorage.getItem('sentNudges');
                if (saved) {
                    sentNudgesToday = JSON.parse(saved);
                    
                    // Clean up old dates (v1.3.0: use local time, not UTC)
                    const today = getTodayString();
                    const yesterday = new Date();
                    yesterday.setDate(yesterday.getDate() - 1);
                    const yesterdayStr = getLocalDateString(yesterday);
                    
                    // Keep only today and yesterday
                    const cleaned = {};
                    if (sentNudgesToday[today]) cleaned[today] = sentNudgesToday[today];
                    if (sentNudgesToday[yesterdayStr]) cleaned[yesterdayStr] = sentNudgesToday[yesterdayStr];
                    sentNudgesToday = cleaned;
                }
            } catch (e) {
                sentNudgesToday = {};
            }
        }
        
        // Check for nudges received
        async function checkReceivedNudges() {
            if (!currentUser || !db) return;
            
            try {
                const snapshot = await db.ref(`nudges/${currentUser.uid}`).once('value');
                const nudges = snapshot.val();
                
                if (!nudges) return;
                
                const today = getTodayString();
                receivedNudges = [];
                
                // Process nudges from today
                Object.entries(nudges).forEach(([senderUid, nudgeData]) => {
                    if (nudgeData.date === today) {
                        receivedNudges.push({
                            senderUid,
                            senderName: nudgeData.fromName,
                            timestamp: nudgeData.timestamp
                        });
                    }
                });
                
                // Show banner if we have nudges
                if (receivedNudges.length > 0) {
                    showNudgeBanner(receivedNudges);
                }
                
                // Clear old nudges (keep only today's)
                const nudgesToRemove = Object.entries(nudges)
                    .filter(([_, data]) => data.date !== today)
                    .map(([uid, _]) => uid);
                
                for (const uid of nudgesToRemove) {
                    await db.ref(`nudges/${currentUser.uid}/${uid}`).remove();
                }
                
            } catch (e) {
                console.error('Failed to check nudges:', e);
            }
        }
        
        // Show nudge received banner
        function showNudgeBanner(nudges) {
            const banner = document.getElementById('nudge-banner');
            if (!banner) return;
            
            // Check if we already showed the banner this session
            const shownKey = 'nudgeBannerShown_' + getTodayString();
            if (sessionStorage.getItem(shownKey)) return;
            
            const titleEl = document.getElementById('nudge-banner-title');
            const subtitleEl = document.getElementById('nudge-banner-subtitle');
            
            if (nudges.length === 1) {
                titleEl.textContent = `${nudges[0].senderName} nudged you! ðŸ‘‹`;
                subtitleEl.textContent = 'Time to play some games!';
            } else {
                titleEl.textContent = `${nudges.length} friends nudged you! ðŸ‘‹`;
                subtitleEl.textContent = `${nudges.map(n => n.senderName).join(', ')} are waiting!`;
            }
            
            banner.style.display = 'block';
            // Small delay to trigger CSS transition
            setTimeout(() => banner.classList.add('visible'), 10);
            sessionStorage.setItem(shownKey, 'true');
            
            // Auto-dismiss after 8 seconds
            setTimeout(() => {
                dismissNudgeBanner();
            }, 8000);
        }
        
        // Dismiss nudge banner
        function dismissNudgeBanner() {
            const banner = document.getElementById('nudge-banner');
            if (banner) {
                banner.classList.remove('visible');
                // Hide after transition completes
                setTimeout(() => {
                    if (!banner.classList.contains('visible')) {
                        banner.style.display = 'none';
                    }
                }, 300);
            }
        }
        
        // Clear received nudges (mark as seen)
        async function clearReceivedNudges() {
            if (!currentUser || !db) return;
            
            try {
                await db.ref(`nudges/${currentUser.uid}`).remove();
                receivedNudges = [];
            } catch (e) {
                console.error('Failed to clear nudges:', e);
            }
        }
        
        // Handle profile link from URL
        async function handleProfileLink(profileUid) {
            try {
                const snapshot = await db.ref('gameshelf-public/' + profileUid).once('value');
                const profileData = snapshot.val();
                
                if (!profileData) {
                    showToast('Profile not found');
                    return;
                }
                
                // Store for profile view
                friendsShelfData[profileUid] = profileData;
                
                setTimeout(() => {
                    showFriendProfile(profileUid);
                }, 500);
            } catch (e) {
                console.error('Failed to load profile:', e);
                showToast('Could not load profile');
            }
        }
        
        // Helper to parse deep link params from both query string and hash
        function getDeepLinkParam(name) {
            // Check query string first
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get(name)) return urlParams.get(name);
            
            // Check hash (format: #param=value or #param=value&other=value)
            const hash = window.location.hash.slice(1); // Remove leading #
            if (hash) {
                const hashParams = new URLSearchParams(hash);
                if (hashParams.get(name)) return hashParams.get(name);
            }
            return null;
        }
        
        // Clean deep link from URL
        function cleanDeepLinkUrl() {
            const cleanUrl = window.location.href.split('?')[0].split('#')[0];
            window.history.replaceState({}, document.title, cleanUrl);
        }
        
        // Check URL for friend/profile params
        function checkFriendParam() {
            const friendUid = getDeepLinkParam('friend');
            const profileUid = getDeepLinkParam('profile');
            
            if (friendUid) {
                cleanDeepLinkUrl();
                setTimeout(() => {
                    handleFriendLink(friendUid);
                }, 500);
            }
            
            if (profileUid) {
                cleanDeepLinkUrl();
                setTimeout(() => {
                    handleProfileLink(profileUid);
                }, 500);
            }
        }
        
        // Check for pending friend after sign in
        function checkPendingFriend() {
            const pendingFriend = sessionStorage.getItem('pendingFriend');
            if (pendingFriend && currentUser) {
                sessionStorage.removeItem('pendingFriend');
                handleFriendLink(pendingFriend);
            }
        }
        
        // ============ DEEP LINK ROUTING ============
        // Handles hash-based deep links for test automation and direct navigation
        function handleDeepLinks() {
            const hash = window.location.hash;
            if (!hash || hash.length < 2) return;
            
            // Don't process deep links during setup flow
            if (!isSetupComplete()) return;
            
            const cleanHash = hash.slice(1).split('=')[0].split('&')[0]; // Get base hash without params
            
            console.log('ðŸ”— Deep link:', cleanHash);
            
            // Small delay to ensure UI is ready
            setTimeout(() => {
                switch(cleanHash) {
                    // Tab navigation
                    case 'home':
                        switchTab('home');
                        break;
                    case 'games':
                        switchTab('games');
                        break;
                    case 'social':
                        switchTab('social');
                        break;
                    case 'share':
                        switchTab('share');
                        break;
                    
                    // Modals & Sheets
                    case 'log':
                        openLogSheet();
                        break;
                    case 'menu':
                        if (!document.getElementById('settings-menu').classList.contains('active')) {
                            toggleSettingsMenu();
                        }
                        break;
                    case 'settings':
                        // Open menu and expand settings submenu
                        if (!document.getElementById('settings-menu').classList.contains('active')) {
                            toggleSettingsMenu();
                        }
                        setTimeout(() => {
                            const submenu = document.getElementById('settings-submenu-content');
                            if (submenu && !submenu.classList.contains('expanded')) {
                                toggleSettingsSubmenu();
                            }
                        }, 100);
                        break;
                    case 'achievements':
                        showAchievements();
                        break;
                    case 'sounds':
                        showSoundCustomizer();
                        break;
                    case 'tutorial':
                        startTutorial();
                        break;
                    
                    // Game management
                    case 'reconfigure':
                        startSetupFlow();
                        break;
                    
                    // Data management
                    case 'export':
                        exportData();
                        break;
                    case 'import':
                        // TODO: Implement import modal
                        showToast('Import coming soon');
                        break;
                    
                    // Invite/Referral
                    case 'invite':
                        // Open menu and scroll to invite section
                        if (!document.getElementById('settings-menu').classList.contains('active')) {
                            toggleSettingsMenu();
                        }
                        setTimeout(() => {
                            const inviteSection = document.querySelector('.referral-code-section');
                            if (inviteSection) inviteSection.scrollIntoView({ behavior: 'smooth' });
                        }, 200);
                        break;
                    
                    // Shop/Rewards
                    case 'shop':
                        showMerchStore();
                        break;
                    
                    // Contacts finder
                    case 'contacts':
                        switchTab('social');
                        setTimeout(() => findFriendsFromContacts(), 300);
                        break;
                    
                    // Privacy settings (placeholder)
                    case 'privacy':
                        if (!document.getElementById('settings-menu').classList.contains('active')) {
                            toggleSettingsMenu();
                        }
                        // TODO: Add privacy section to settings
                        showToast('Privacy settings coming soon');
                        break;
                    
                    // Suggest game (placeholder)
                    case 'suggest':
                        // TODO: Implement suggest game form
                        showToast('Suggest game coming soon');
                        break;
                    
                    // Existing deep links handled elsewhere: friend, profile, battle, ref
                    default:
                        // Let other handlers process (friend=, profile=, battle=, ref=)
                        break;
                }
            }, 300);
        }
        
        // Listen for hash changes (for navigation without reload)
        window.addEventListener('hashchange', handleDeepLinks);
        
        // ============ TEST HELPERS ============
        // Utilities for automated testing - activated via URL params
        const TestHelpers = {
            // Check if test mode is enabled
            isTestMode: () => {
                const params = new URLSearchParams(window.location.search);
                return params.has('testMode') || params.has('debugConsole');
            },
            
            // Get app state for assertions (uses actual field names)
            getState: () => ({
                user: currentUser ? { uid: currentUser.uid, email: currentUser.email } : null,
                games: appData.games || [],
                history: appData.history || {},
                stats: appData.stats || {},
                wallet: appData.wallet || { tokens: 0, coins: 0 },
                friends: appData.friends || [],
                achievements: appData.achievements || {},
                settings: appData.settings || {},
                setupComplete: isSetupComplete(),
                currentTab: document.querySelector('.nav-tab.active')?.dataset?.tab || 'home'
            }),
            
            // Seed test data (uses actual field names, deep merges)
            seedTestData: (data) => {
                if (data.games !== undefined) appData.games = data.games;
                if (data.history) appData.history = { ...appData.history, ...data.history };
                if (data.stats) appData.stats = { ...appData.stats, ...data.stats };
                if (data.wallet) appData.wallet = { ...appData.wallet, ...data.wallet };
                if (data.achievements) appData.achievements = { ...appData.achievements, ...data.achievements };
                if (data.settings) appData.settings = { ...appData.settings, ...data.settings };
                if (data.friends) appData.friends = data.friends;
                if (data.dailyGoal !== undefined) appData.dailyGoal = data.dailyGoal;
                saveData();
                renderAll();
                console.log('ðŸ§ª Test data seeded:', data);
            },
            
            // Reset to fresh state (like new user)
            resetToFresh: () => {
                // Clear ALL gameshelf-related localStorage keys
                const keysToRemove = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && (key.includes('gameshelf') || key.includes('gameShelf') || key.includes('gs-'))) {
                        keysToRemove.push(key);
                    }
                }
                keysToRemove.forEach(key => localStorage.removeItem(key));
                sessionStorage.clear();
                console.log('ðŸ§ª Data cleared, reloading...');
                location.reload();
            },
            
            // Simulate paste event with game result
            simulatePaste: (text) => {
                const logInput = document.getElementById('log-input');
                if (logInput) {
                    logInput.value = text;
                    logInput.dispatchEvent(new Event('input', { bubbles: true }));
                }
                console.log('ðŸ§ª Simulated paste:', text.substring(0, 50) + '...');
            },
            
            // Click element by selector
            click: (selector) => {
                const el = document.querySelector(selector);
                if (el) {
                    el.click();
                    console.log('ðŸ§ª Clicked:', selector);
                    return true;
                }
                console.warn('ðŸ§ª Element not found:', selector);
                return false;
            },
            
            // Wait for element to appear
            waitFor: (selector, timeout = 5000) => {
                return new Promise((resolve, reject) => {
                    const el = document.querySelector(selector);
                    if (el) return resolve(el);
                    
                    const observer = new MutationObserver(() => {
                        const el = document.querySelector(selector);
                        if (el) {
                            observer.disconnect();
                            resolve(el);
                        }
                    });
                    
                    observer.observe(document.body, { childList: true, subtree: true });
                    
                    setTimeout(() => {
                        observer.disconnect();
                        reject(new Error(`Timeout waiting for ${selector}`));
                    }, timeout);
                });
            },
            
            // Check if element is visible
            isVisible: (selector) => {
                const el = document.querySelector(selector);
                if (!el) return false;
                const style = window.getComputedStyle(el);
                return style.display !== 'none' && 
                       style.visibility !== 'hidden' && 
                       style.opacity !== '0' &&
                       el.offsetParent !== null;
            },
            
            // Get text content
            getText: (selector) => {
                const el = document.querySelector(selector);
                return el ? el.textContent.trim() : null;
            },
            
            // Log all console errors (for test reporting)
            errors: [],
            captureErrors: () => {
                const originalError = console.error;
                console.error = (...args) => {
                    TestHelpers.errors.push({ time: new Date().toISOString(), args });
                    originalError.apply(console, args);
                };
                window.onerror = (msg, src, line, col, err) => {
                    TestHelpers.errors.push({ time: new Date().toISOString(), msg, src, line, err });
                };
            },
            
            // Get last launched game (for return-from-game testing)
            getLastLaunchedGame: () => lastLaunchedGame,
            
            // Get last launch time
            getLastLaunchTime: () => lastLaunchTime,
            
            // Manually set last launched game (for testing)
            setLastLaunchedGame: (gameId) => {
                lastLaunchedGame = gameId;
                lastLaunchTime = Date.now();
            },
            
            // Get clipboard monitoring state
            getClipboardMonitorState: () => ({
                hasInterval: !!clipboardPlusInterval,
                intervalTime: 5000,
                lastContent: lastClipboardContent
            }),
            
            // Get all PARSERS for testing
            getParsers: () => PARSERS,
            
            // Parse text using app's parsers (for testing)
            parseText: (text) => parseShareText(text),
            
            // Get GAMES catalog
            getGames: () => GAMES,
            
            // Get app data directly
            getAppData: () => appData
        };
        
        // Expose TestHelpers globally for automation scripts
        window.GameShelfTest = TestHelpers;
        
        // Also expose key variables for direct access in tests
        window.getLastLaunchedGame = () => lastLaunchedGame;
        
        // Check for test mode params BEFORE app init
        function checkTestParams() {
            const params = new URLSearchParams(window.location.search);
            
            // ?fresh=1 - Clear all data and start fresh (BEFORE loading data)
            if (params.get('fresh') === '1') {
                console.log('ðŸ§ª Fresh mode - clearing all data');
                // Clear ALL gameshelf-related localStorage keys
                const keysToRemove = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && (key.includes('gameshelf') || key.includes('gameShelf') || key.includes('gs-'))) {
                        keysToRemove.push(key);
                    }
                }
                keysToRemove.forEach(key => {
                    console.log('ðŸ§ª Removing:', key);
                    localStorage.removeItem(key);
                });
                sessionStorage.clear();
                // Remove the param from URL and reload to apply fresh state
                const cleanUrl = window.location.pathname + window.location.hash;
                window.history.replaceState({}, document.title, cleanUrl);
                // Reload to start fresh (URL no longer has ?fresh=1 so won't loop)
                window.location.reload();
                return; // Stop execution, page will reload
            }
            
            // ?debugConsole=1 - Enable error capture
            if (params.get('debugConsole') === '1') {
                TestHelpers.captureErrors();
                console.log('ðŸ§ª Debug console enabled - errors captured to GameShelfTest.errors');
            }
            
            // ?testMode=1 - Log that test mode is active
            if (params.get('testMode') === '1') {
                console.log('ðŸ§ª Test mode enabled');
                console.log('ðŸ§ª Access helpers via window.GameShelfTest');
                console.log('ðŸ§ª Available methods: getState(), seedTestData(), resetToFresh(), simulatePaste(), click(), waitFor(), isVisible(), getText()');
            }
            
            // ?seedData=base64json - Seed with test data (handled after init)
            const seedData = params.get('seedData');
            if (seedData) {
                // Delay until after app init
                setTimeout(() => {
                    try {
                        const data = JSON.parse(atob(seedData));
                        TestHelpers.seedTestData(data);
                    } catch (e) {
                        console.error('ðŸ§ª Failed to parse seedData:', e);
                    }
                }, 1000);
            }
        }
        
        // Run test param check immediately (before init)
        checkTestParams();
        
        // ============ GAME CATALOG ============
        const GAMES = {
            // NYT Games
            wordle: { id: 'wordle', name: 'Wordle', icon: 'ðŸŸ©', url: 'https://www.nytimes.com/games/wordle', publisher: 'nyt', hasApp: true },
            connections: { id: 'connections', name: 'Connections', icon: 'ðŸ”—', url: 'https://www.nytimes.com/games/connections', publisher: 'nyt', hasApp: true },
            strands: { id: 'strands', name: 'Strands', icon: 'ðŸ§µ', url: 'https://www.nytimes.com/games/strands', publisher: 'nyt', hasApp: true },
            mini: { id: 'mini', name: 'Mini', icon: 'ðŸ“', url: 'https://www.nytimes.com/crosswords/game/mini', publisher: 'nyt', hasApp: true },
            'spelling-bee': { id: 'spelling-bee', name: 'Spelling Bee', icon: 'ðŸ', url: 'https://www.nytimes.com/puzzles/spelling-bee', publisher: 'nyt', hasApp: true },
            letterboxed: { id: 'letterboxed', name: 'Letterboxed', icon: 'ðŸ“¦', url: 'https://www.nytimes.com/puzzles/letter-boxed', publisher: 'nyt', hasApp: true },
            // LinkedIn Games
            queens: { id: 'queens', name: 'Queens', icon: 'ðŸ‘‘', url: 'https://www.linkedin.com/games/queens', publisher: 'linkedin', hasApp: true },
            tango: { id: 'tango', name: 'Tango', icon: 'ðŸ’ƒ', url: 'https://www.linkedin.com/games/tango', publisher: 'linkedin', hasApp: true },
            pinpoint: { id: 'pinpoint', name: 'Pinpoint', icon: 'ðŸ“', url: 'https://www.linkedin.com/games/pinpoint', publisher: 'linkedin', hasApp: true },
            crossclimb: { id: 'crossclimb', name: 'Crossclimb', icon: 'ðŸ§—', url: 'https://www.linkedin.com/games/crossclimb', publisher: 'linkedin', hasApp: true },
            zip: { id: 'zip', name: 'Zip', icon: 'âš¡', url: 'https://www.linkedin.com/games/zip', publisher: 'linkedin', hasApp: true },
            // Word Games (browser only)
            quordle: { id: 'quordle', name: 'Quordle', icon: '4ï¸âƒ£', url: 'https://www.quordle.com', hasApp: false },
            octordle: { id: 'octordle', name: 'Octordle', icon: '8ï¸âƒ£', url: 'https://octordle.com', hasApp: false },
            waffle: { id: 'waffle', name: 'Waffle', icon: 'ðŸ§‡', url: 'https://wafflegame.net', hasApp: false },
            redactle: { id: 'redactle', name: 'Redactle', icon: 'â–ˆ', url: 'https://redactle.net', hasApp: false },
            semantle: { id: 'semantle', name: 'Semantle', icon: 'ðŸ§ ', url: 'https://semantle.com', hasApp: false },
            nerdle: { id: 'nerdle', name: 'Nerdle', icon: 'ðŸ§®', url: 'https://nerdlegame.com', hasApp: false },
            contexto: { id: 'contexto', name: 'Contexto', icon: 'ðŸŽ¯', url: 'https://contexto.me', hasApp: false },
            dordle: { id: 'dordle', name: 'Dordle', icon: '2ï¸âƒ£', url: 'https://zaratustra.itch.io/dordle', hasApp: false },
            // Geography Games (browser only)
            worldle: { id: 'worldle', name: 'Worldle', icon: 'ðŸŒ', url: 'https://worldle.teuteuf.fr', hasApp: false },
            globle: { id: 'globle', name: 'Globle', icon: 'ðŸŒŽ', url: 'https://globle-game.com', hasApp: false },
            tradle: { id: 'tradle', name: 'Tradle', icon: 'ðŸš¢', url: 'https://oec.world/en/tradle', hasApp: false },
            wheretaken: { id: 'wheretaken', name: 'WhereTaken', icon: 'ðŸ“¸', url: 'https://wheretaken.teuteuf.fr', hasApp: false },
            foodguessr: { id: 'foodguessr', name: 'FoodGuessr', icon: 'ðŸ•', url: 'https://www.foodguessr.com', hasApp: false },
            travle: { id: 'travle', name: 'Travle', icon: 'âœˆï¸', url: 'https://travle.earth', hasApp: false },
            // Entertainment (browser only)
            framed: { id: 'framed', name: 'Framed', icon: 'ðŸŽ¬', url: 'https://framed.wtf', hasApp: false },
            actorle: { id: 'actorle', name: 'Actorle', icon: 'ðŸŽ­', url: 'https://actorle.com', hasApp: false },
            moviedle: { id: 'moviedle', name: 'Moviedle', icon: 'ðŸŽ¥', url: 'https://moviedle.app', hasApp: false },
            heardle: { id: 'heardle', name: 'Heardle', icon: 'ðŸŽµ', url: 'https://www.spotify.com/heardle', hasApp: false },
            bandle: { id: 'bandle', name: 'Bandle', icon: 'ðŸŽ¸', url: 'https://bandle.app', hasApp: false },
            // Sports & Misc (browser only)
            'immaculate-grid': { id: 'immaculate-grid', name: 'Immaculate Grid', icon: 'âš¾', url: 'https://www.immaculategrid.com', hasApp: false },
            costcodle: { id: 'costcodle', name: 'Costcodle', icon: 'ðŸ›’', url: 'https://costcodle.com', hasApp: false },
            // Game Shelf Originals (browser only) - Production at gameshelf.co
            quotle: { id: 'quotle', name: 'Quotle', icon: 'ðŸ’¬', url: 'https://gameshelf.co/quotle/', hasApp: false },
            slate: { id: 'slate', name: 'Slate', icon: 'ðŸ“', url: 'https://gameshelf.co/slate/', hasApp: false },
            rungs: { id: 'rungs', name: 'Rungs', icon: 'ðŸªœ', url: 'https://gameshelf.co/rungs/', hasApp: false },
            wordboxing: { id: 'wordboxing', name: 'Word Boxing', icon: 'ðŸ¥Š', url: 'https://gameshelf.co/wordboxing/', hasApp: false }
        };
        
        // Test URLs for GS Originals (used when Test Mode is enabled)
        const GS_ORIGINALS_TEST_URLS = {
            quotle: 'https://stewartdavidp-ship-it.github.io/gameshelftest/quotle/',
            slate: 'https://stewartdavidp-ship-it.github.io/gameshelftest/slate/',
            rungs: 'https://stewartdavidp-ship-it.github.io/gameshelftest/rungs/',
            wordboxing: 'https://stewartdavidp-ship-it.github.io/gameshelftest/wordboxing/'
        };
        
        // Production URLs for GS Originals (default) - gameshelf.co
        const GS_ORIGINALS_PROD_URLS = {
            quotle: 'https://gameshelf.co/quotle/',
            slate: 'https://gameshelf.co/slate/',
            rungs: 'https://gameshelf.co/rungs/',
            wordboxing: 'https://gameshelf.co/wordboxing/'
        };
        
        // Check if game is a GS Original
        function isGSOriginal(gameId) {
            return ['quotle', 'slate', 'rungs', 'wordboxing'].includes(gameId);
        }
        
        // Get URL for game (respects test mode for GS Originals)
        function getGameUrl(gameId) {
            if (isGSOriginal(gameId) && isTestModeEnabled()) {
                return GS_ORIGINALS_TEST_URLS[gameId];
            }
            return GAMES[gameId]?.url;
        }
        
        // Check if test mode is enabled
        // v1.2.7.6: Auto-enable when deployed to gameshelftest/ repo
        function isTestModeEnabled() {
            // Auto-enable when running from test repo (can't be toggled off)
            if (window.location.pathname.toLowerCase().includes('gameshelftest')) {
                return true;
            }
            return localStorage.getItem('gameshelf_test_mode') === 'true';
        }
        
        // Check if test mode toggle should be disabled (when auto-enabled)
        function isTestModeAutoEnabled() {
            return window.location.pathname.toLowerCase().includes('gameshelftest');
        }
        
        // Check if this is the test Game Shelf instance (alias for badge/UI logic)
        function isTestGameShelf() {
            return window.location.hostname.includes('github.io') && 
                   window.location.pathname.toLowerCase().includes('gameshelftest');
        }
        
        // App info for publishers that have apps
        const APP_INFO = {
            nyt: {
                name: 'NYT Games',
                appStoreUrl: 'https://apps.apple.com/app/id307569751',
                playStoreUrl: 'https://play.google.com/store/apps/details?id=com.nytimes.crossword',
                icon: 'ðŸ“°'
            },
            linkedin: {
                name: 'LinkedIn',
                appStoreUrl: 'https://apps.apple.com/app/id288429040',
                playStoreUrl: 'https://play.google.com/store/apps/details?id=com.linkedin.android',
                icon: 'ðŸ’¼'
            }
        };
        
        const DEFAULT_SHELF = ['wordle', 'connections', 'strands', 'mini', 'spelling-bee', 'worldle'];
        const POPULAR_GAMES = ['quotle', 'slate', 'rungs', 'wordboxing', 'quordle', 'framed', 'queens', 'heardle', 'nerdle'];
        
        // Quick games that can reasonably be completed in under 30 seconds
        // Used for game-aware time thresholds in confidence algorithm
        const QUICK_GAMES = ['mini', 'zip', 'heardle', 'framed', 'worldle', 'tango', 'quotle', 'slate', 'rungs', 'word-boxing'];
        
        // Quick Start preset - NYT core + Game Shelf Originals (best auto-sync UX)
        const QUICK_START_GAMES = [
            'wordle', 'connections', 'strands',           // NYT Core
            'quotle', 'slate', 'rungs', 'wordboxing'      // Game Shelf Originals
        ];
        
        // Game categories for browse section
        const GAME_CATEGORIES = [
            { 
                id: 'nyt', 
                name: 'NYT Games', 
                icon: 'ðŸ“°',
                games: ['wordle', 'connections', 'strands', 'mini', 'spelling-bee', 'letterboxed']
            },
            { 
                id: 'originals', 
                name: 'Game Shelf Originals', 
                icon: 'ðŸŽ®',
                games: ['quotle', 'slate', 'rungs', 'wordboxing']
            },
            { 
                id: 'linkedin', 
                name: 'LinkedIn Games', 
                icon: 'ðŸ’¼',
                games: ['queens', 'tango', 'pinpoint', 'crossclimb', 'zip']
            },
            { 
                id: 'word', 
                name: 'Word Games', 
                icon: 'ðŸ”¤',
                games: ['quordle', 'octordle', 'waffle', 'redactle', 'semantle', 'nerdle', 'contexto', 'dordle']
            },
            { 
                id: 'geography', 
                name: 'Geography', 
                icon: 'ðŸŒ',
                games: ['worldle', 'globle', 'tradle', 'wheretaken', 'foodguessr', 'travle']
            },
            { 
                id: 'entertainment', 
                name: 'Entertainment', 
                icon: 'ðŸŽ¬',
                games: ['framed', 'actorle', 'moviedle', 'heardle', 'bandle']
            },
            { 
                id: 'sports', 
                name: 'Sports & Misc', 
                icon: 'ðŸˆ',
                games: ['immaculate-grid', 'costcodle']
            }
        ];
        
        // ============ SHARE TEXT PARSERS ============
        const PARSERS = [
            // ============ NYT GAMES (Enhanced) ============
            {
                id: 'wordle',
                // Matches: "Wordle 1,234 3/6", "Wordle 1234 X/6", with or without comma
                regex: /Wordle\s+([\d,]+)\s+([1-6X])\/6/i,
                extract: (match, text) => {
                    const puzzleNum = match[1].replace(',', '');
                    const guesses = match[2];
                    // Count colored squares for grid info
                    const greenCount = (text.match(/ðŸŸ©/g) || []).length;
                    const yellowCount = (text.match(/ðŸŸ¨/g) || []).length;
                    
                    // Battle scoring: 1/6 is "hole in one" rare moment
                    // Above average (3) beats average (4) clearly
                    const scoreMap = { '1': 50, '2': 30, '3': 22, '4': 15, '5': 10, '6': 6 };
                    const numericScore = guesses === 'X' ? 0 : (scoreMap[guesses] || 15);
                    
                    return {
                        gameId: 'wordle',
                        puzzleNumber: parseInt(puzzleNum),
                        score: guesses + '/6',
                        won: guesses !== 'X',
                        numericScore,
                        grid: text.match(/[â¬›â¬œðŸŸ¨ðŸŸ©]+/g)?.join('\n') || '',
                        meta: { greens: greenCount, yellows: yellowCount, perfect: guesses === '1' }
                    };
                }
            },
            {
                id: 'connections',
                // Matches: "Connections\nPuzzle #123", "Connections Puzzle #123"
                regex: /Connections\s*\n?\s*Puzzle\s*#?(\d+)/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    // Find emoji grid lines (4 squares each)
                    // Use 'u' flag for proper Unicode emoji matching
                    const lines = text.split('\n').filter(l => /^[ðŸŸ¨ðŸŸ©ðŸŸ¦ðŸŸª]{4}$/u.test(l.trim()));
                    const solved = lines.length >= 4;
                    // Count mistakes (lines with mixed colors)
                    const mistakes = text.split('\n')
                        .filter(l => /[ðŸŸ¨ðŸŸ©ðŸŸ¦ðŸŸª]/u.test(l))
                        .filter(l => {
                            const colors = new Set(l.match(/[ðŸŸ¨ðŸŸ©ðŸŸ¦ðŸŸª]/gu) || []);
                            return colors.size > 1;
                        }).length;
                    // Perfect = no mistakes in 4 guesses
                    const perfect = solved && mistakes === 0 && lines.length === 4;
                    
                    // Battle scoring: gradual penalty per mistake
                    // Perfect: 30, 1 miss: 24, 2 miss: 18, 3 miss: 12
                    // Failed: partial credit per group found
                    const numericScore = solved ? (30 - mistakes * 6) : (lines.length * 4);
                    
                    return {
                        gameId: 'connections',
                        puzzleNumber: parseInt(puzzleNum),
                        score: perfect ? 'Perfect! ðŸŽ¯' : (solved ? (mistakes > 0 ? `${mistakes} mistake${mistakes > 1 ? 's' : ''}` : 'Solved!') : `${lines.length}/4`),
                        won: solved,
                        numericScore,
                        grid: lines.join('\n'),
                        meta: { mistakes, perfect }
                    };
                }
            },
            {
                id: 'strands',
                // Matches: "Strands #123", "Strands#123"
                regex: /Strands\s*#?(\d+)/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    const hints = (text.match(/ðŸ’¡/g) || []).length;
                    // Find the spanagram (ðŸŸ¡) and theme words (ðŸ”µ)
                    const spanagram = text.includes('ðŸŸ¡');
                    const blueCount = (text.match(/ðŸ”µ/g) || []).length;
                    const perfect = hints === 0;
                    
                    // Battle scoring: softer hint penalty
                    // 0 hints: 28, 1 hint: 25, 2 hints: 22, 3 hints: 19, 4+ hints: min 10
                    const numericScore = perfect ? 28 : Math.max(25 - hints * 3, 10);
                    
                    return {
                        gameId: 'strands',
                        puzzleNumber: parseInt(puzzleNum),
                        score: perfect ? 'Perfect! ðŸŽ¯' : (hints > 0 ? `${hints} hint${hints > 1 ? 's' : ''}` : 'No hints!'),
                        won: true,
                        numericScore,
                        meta: { hints, spanagram, themeWords: blueCount, perfect }
                    };
                }
            },
            {
                id: 'mini',
                // Matches: "I solved the 1/17/2026 New York Times Mini Crossword in 1:23!"
                // Also: "Mini Crossword", time patterns
                regex: /(?:I\s+solved.*(?:Mini|mini).*in\s+)?(\d+):(\d+)|Mini\s*Crossword/i,
                extract: (match, text) => {
                    // Try to find time pattern anywhere in text
                    const timeMatch = text.match(/(\d+):(\d+)/);
                    if (timeMatch) {
                        const mins = parseInt(timeMatch[1]);
                        const secs = parseInt(timeMatch[2]);
                        const totalSecs = mins * 60 + secs;
                        
                        // Battle scoring: slower decay, reasonable floor
                        // <45s: 28, 1 min: 24, 2 min: 20, 3 min: 16, 4+ min: 12
                        const fast = totalSecs <= 45;
                        const numericScore = fast ? 28 : Math.max(25 - Math.floor(totalSecs / 15), 12);
                        
                        let score = `${mins}:${secs.toString().padStart(2, '0')}`;
                        if (fast) score += ' âš¡';
                        
                        return {
                            gameId: 'mini',
                            score,
                            won: true,
                            numericScore,
                            meta: { seconds: totalSecs, fast }
                        };
                    }
                    return { gameId: 'mini', score: 'Done', won: true, numericScore: 15 };
                }
            },
            {
                id: 'spelling-bee',
                // Matches various Spelling Bee share formats
                regex: /Spelling\s*Bee|ðŸ|reached\s+(Queen\s*Bee|Genius|Amazing|Great|Nice|Good|Solid|Moving\s*Up|Good\s*Start)/i,
                extract: (match, text) => {
                    // NYT ranks: Queen Bee > Genius > Amazing > Great > Nice > Good > Solid > Moving Up > Good Start > Beginner
                    const ranks = {
                        'queen bee': { score: 'Queen Bee! ðŸ‘‘', points: 50 },
                        'genius': { score: 'Genius!', points: 35 },
                        'amazing': { score: 'Amazing!', points: 30 },
                        'great': { score: 'Great!', points: 25 },
                        'nice': { score: 'Nice!', points: 20 },
                        'good': { score: 'Good!', points: 15 },
                        'solid': { score: 'Solid', points: 12 },
                        'moving up': { score: 'Moving Up', points: 10 },
                        'good start': { score: 'Good Start', points: 8 },
                        'beginner': { score: 'Beginner', points: 5 }
                    };
                    const textLower = text.toLowerCase();
                    for (const [rank, data] of Object.entries(ranks)) {
                        if (textLower.includes(rank)) {
                            return { gameId: 'spelling-bee', score: data.score, won: true, numericScore: data.points };
                        }
                    }
                    // Check for points: "I scored 123 points"
                    const pointsMatch = text.match(/(\d+)\s*points?/i);
                    if (pointsMatch) {
                        const pts = parseInt(pointsMatch[1]);
                        return { gameId: 'spelling-bee', score: `${pts} pts`, won: true, numericScore: Math.min(Math.floor(pts / 5), 40) };
                    }
                    return { gameId: 'spelling-bee', score: 'Played', won: true, numericScore: 10 };
                }
            },
            {
                id: 'letterboxed',
                // Matches: "I solved Letter Boxed in 3 words"
                regex: /Letter\s*Boxed|solved.*in\s+(\d+)\s+word/i,
                extract: (match, text) => {
                    const wordMatch = text.match(/in\s+(\d+)\s+word/i);
                    if (wordMatch) {
                        const words = parseInt(wordMatch[1]);
                        // 2-word solution is impressive, 3-4 is good
                        const perfect = words <= 2;
                        return { 
                            gameId: 'letterboxed', 
                            score: perfect ? `${words} words! ðŸŽ¯` : `${words} words`, 
                            won: true, 
                            numericScore: Math.max(35 - (words - 2) * 8, 10),
                            meta: { words, perfect }
                        };
                    }
                    return { gameId: 'letterboxed', score: 'Completed', won: true, numericScore: 15 };
                }
            },
            // ============ POPULAR WORD GAMES (Enhanced) ============
            {
                id: 'quordle',
                // Matches: "Daily Quordle 123" with emoji grid
                regex: /Daily\s+Quordle\s+(\d+)/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    // Count red squares (failed) and find scores
                    const failed = (text.match(/ðŸŸ¥/g) || []).length;
                    // Extract individual word scores (digits in the grid area)
                    const scores = text.match(/[1-9ï¸âƒ£ðŸ”ŸðŸŸ¥]/g) || [];
                    const solved = 4 - failed;
                    const perfect = failed === 0;
                    return {
                        gameId: 'quordle',
                        puzzleNumber: parseInt(puzzleNum),
                        score: perfect ? 'Perfect! ðŸŽ¯' : (failed > 0 ? `${solved}/4` : 'Solved!'),
                        won: failed < 4,
                        numericScore: perfect ? 30 : Math.max(25 - failed * 5, 5),
                        meta: { solved, failed }
                    };
                }
            },
            {
                id: 'octordle',
                // Matches: "Daily Octordle #123"
                regex: /Daily\s+Octordle\s+#?(\d+)/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    const failed = (text.match(/ðŸŸ¥/g) || []).length;
                    const solved = 8 - failed;
                    const perfect = failed === 0;
                    return {
                        gameId: 'octordle',
                        puzzleNumber: parseInt(puzzleNum),
                        score: perfect ? 'Perfect! ðŸŽ¯' : `${solved}/8`,
                        won: failed < 8,
                        numericScore: perfect ? 35 : Math.max(30 - failed * 3, 5),
                        meta: { solved, failed }
                    };
                }
            },
            {
                id: 'dordle',
                // Matches: "Daily Dordle #123 X&4/7" or similar
                regex: /(?:Daily\s+)?Dordle\s+#?(\d+)\s*([0-7X])&([0-7X])\/7/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    const left = match[2];
                    const right = match[3];
                    const won = left !== 'X' && right !== 'X';
                    const total = (left === 'X' ? 7 : parseInt(left)) + (right === 'X' ? 7 : parseInt(right));
                    return {
                        gameId: 'dordle',
                        puzzleNumber: parseInt(puzzleNum),
                        score: `${left}&${right}/7`,
                        won,
                        numericScore: won ? Math.max(28 - total * 2, 10) : 0,
                        meta: { left, right }
                    };
                }
            },
            {
                id: 'worldle',
                // Matches: "#Worldle #123 (date) 3/6"
                regex: /#?Worldle\s+#?(\d+).*?([1-6X])\/6/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    const guesses = match[2];
                    const perfect = guesses === '1';
                    
                    // Battle scoring: match Wordle philosophy
                    // 1=35 (rare!), 2=28, 3=22, 4=16, 5=10, 6=6
                    const scoreMap = { '1': 35, '2': 28, '3': 22, '4': 16, '5': 10, '6': 6 };
                    const numericScore = guesses === 'X' ? 0 : (scoreMap[guesses] || 15);
                    
                    return {
                        gameId: 'worldle',
                        puzzleNumber: parseInt(puzzleNum),
                        score: perfect ? '1/6 ðŸŽ¯' : (guesses + '/6'),
                        won: guesses !== 'X',
                        numericScore,
                        meta: { perfect }
                    };
                }
            },
            {
                id: 'globle',
                // Matches: "ðŸŒŽ Jan 17, 2026 ðŸŒ" with colored squares
                regex: /ðŸŒŽ.*ðŸŒ|Globle/i,
                extract: (match, text) => {
                    // Count guesses from colored squares
                    const guesses = (text.match(/[ðŸŸ©ðŸŸ¨ðŸŸ§ðŸŸ¥â¬œ]/g) || []).length;
                    const perfect = guesses <= 3;
                    const great = guesses <= 6;
                    
                    // Battle scoring: reward low guesses more
                    // 1-3: 35, 4-6: 28, 7-10: 22, 11-15: 16, 16-20: 12, 20+: 10
                    let numericScore = 10;
                    if (guesses <= 3) numericScore = 35;
                    else if (guesses <= 6) numericScore = 28;
                    else if (guesses <= 10) numericScore = 22;
                    else if (guesses <= 15) numericScore = 16;
                    else if (guesses <= 20) numericScore = 12;
                    
                    return {
                        gameId: 'globle',
                        score: guesses > 0 ? (perfect ? `${guesses} ðŸŽ¯` : `${guesses} guesses`) : 'Completed',
                        won: true,
                        numericScore: guesses > 0 ? numericScore : 15,
                        meta: { guesses, perfect }
                    };
                }
            },
            {
                id: 'tradle',
                // Matches: "#Tradle #123 X/6"
                regex: /#?Tradle\s+#?(\d+)\s*([1-6X])\/6/i,
                extract: (match) => {
                    const puzzleNum = match[1];
                    const guesses = match[2];
                    const perfect = guesses === '1';
                    
                    // Battle scoring: match Wordle philosophy
                    const scoreMap = { '1': 35, '2': 28, '3': 22, '4': 16, '5': 10, '6': 6 };
                    const numericScore = guesses === 'X' ? 0 : (scoreMap[guesses] || 15);
                    
                    return {
                        gameId: 'tradle',
                        puzzleNumber: parseInt(puzzleNum),
                        score: perfect ? '1/6 ðŸŽ¯' : (guesses + '/6'),
                        won: guesses !== 'X',
                        numericScore,
                        meta: { perfect }
                    };
                }
            },
            {
                id: 'travle',
                // Matches: "#travle #123 +2" or "#travle #123 (Perfect)"
                regex: /#?travle\s+#?(\d+)\s*(?:\(?(Perfect|\+\d+)\)?)?/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    const result = match[2] || '';
                    const perfect = result.toLowerCase() === 'perfect' || result === '+0';
                    const extra = result.startsWith('+') ? parseInt(result.slice(1)) : 0;
                    return {
                        gameId: 'travle',
                        puzzleNumber: parseInt(puzzleNum),
                        score: perfect ? 'Perfect! ðŸŽ¯' : (extra > 0 ? `+${extra}` : 'Solved!'),
                        won: true,
                        numericScore: perfect ? 30 : Math.max(25 - extra * 3, 5),
                        meta: { extra, perfect }
                    };
                }
            },
            {
                id: 'waffle',
                // Matches: "#waffle123" or "Waffle #123" with star rating
                regex: /#?waffle\s*#?(\d+)/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    // Look for star rating (0-5 stars)
                    const starsMatch = text.match(/([0-5])\/5\s*â­/) || text.match(/â­\s*([0-5])\/5/);
                    const stars = starsMatch ? parseInt(starsMatch[1]) : 3;
                    // Look for swaps used
                    const swapsMatch = text.match(/(\d+)\s*swaps?/i);
                    const swaps = swapsMatch ? parseInt(swapsMatch[1]) : null;
                    const perfect = stars === 5;
                    return {
                        gameId: 'waffle',
                        puzzleNumber: parseInt(puzzleNum),
                        score: perfect ? '5/5 â­ ðŸŽ¯' : `${stars}/5 â­`,
                        won: stars >= 1,
                        numericScore: stars * 6,
                        meta: { stars, swaps, perfect }
                    };
                }
            },
            {
                id: 'contexto',
                // Matches: "I played contexto.me #123 and got it in 45 guesses"
                regex: /contexto(?:\.me)?\s*#?(\d+).*?(\d+)\s*guesses?/i,
                extract: (match) => {
                    const puzzleNum = match[1];
                    const guesses = parseInt(match[2]);
                    const perfect = guesses <= 10;
                    const great = guesses <= 25;
                    const good = guesses <= 50;
                    
                    // Battle scoring: tiered by guess count
                    // <10: 35 (amazing), 10-25: 28, 26-50: 22, 51-100: 16, 100+: 10
                    let numericScore = 10;
                    if (guesses <= 10) numericScore = 35;
                    else if (guesses <= 25) numericScore = 28;
                    else if (guesses <= 50) numericScore = 22;
                    else if (guesses <= 100) numericScore = 16;
                    
                    return {
                        gameId: 'contexto',
                        puzzleNumber: parseInt(puzzleNum),
                        score: perfect ? `${guesses} ðŸŽ¯` : `${guesses} guesses`,
                        won: true,
                        numericScore,
                        meta: { guesses, perfect }
                    };
                }
            },
            // ============ MOVIE/TV GAMES ============
            {
                id: 'framed',
                // Matches: "Framed #123"
                regex: /Framed\s+#?(\d+)/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    // Green = correct, Red = wrong, Black = skipped
                    const frames = text.split('\n').find(l => /[ðŸŽ¥ðŸŸ©ðŸŸ¥â¬›]/.test(l)) || '';
                    const greenPos = frames.indexOf('ðŸŸ©');
                    const won = greenPos !== -1;
                    // Count position (1-6)
                    const guessCount = won ? (frames.slice(0, greenPos).match(/[ðŸŸ¥â¬›]/g) || []).length + 1 : 6;
                    const perfect = guessCount === 1;
                    // Battle scoring: match Wordle philosophy
                    const scoreMap = { 1: 35, 2: 28, 3: 22, 4: 16, 5: 10, 6: 6 };
                    const numericScore = won ? (scoreMap[guessCount] || 15) : 0;
                    
                    return {
                        gameId: 'framed',
                        puzzleNumber: parseInt(puzzleNum),
                        score: won ? (perfect ? '1/6 ðŸŽ¯' : `${guessCount}/6`) : 'X/6',
                        won,
                        numericScore,
                        meta: { guessCount, perfect }
                    };
                }
            },
            {
                id: 'actorle',
                // Matches: "Actorle #123 3/8"
                regex: /Actorle\s*#?(\d+)\s*([1-8X])\/8/i,
                extract: (match) => {
                    const puzzleNum = match[1];
                    const guesses = match[2];
                    const perfect = guesses === '1';
                    
                    // Battle scoring: 8-guess scale
                    // 1=35, 2=30, 3=25, 4=20, 5=16, 6=12, 7=8, 8=5
                    const scoreMap = { '1': 35, '2': 30, '3': 25, '4': 20, '5': 16, '6': 12, '7': 8, '8': 5 };
                    const numericScore = guesses === 'X' ? 0 : (scoreMap[guesses] || 15);
                    
                    return {
                        gameId: 'actorle',
                        puzzleNumber: parseInt(puzzleNum),
                        score: perfect ? '1/8 ðŸŽ¯' : (guesses + '/8'),
                        won: guesses !== 'X',
                        numericScore,
                        meta: { perfect }
                    };
                }
            },
            {
                id: 'moviedle',
                // Matches: "#Moviedle #123" or "Moviedle #123 2/6"
                regex: /#?Moviedle\s*#?(\d+).*?([1-6X])?\/6/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    // Try to find score in text
                    const guessMatch = text.match(/([1-6X])\/6/);
                    const guesses = guessMatch ? guessMatch[1] : null;
                    const perfect = guesses === '1';
                    if (guesses) {
                        // Battle scoring: match Wordle philosophy
                        const scoreMap = { '1': 35, '2': 28, '3': 22, '4': 16, '5': 10, '6': 6 };
                        const numericScore = guesses === 'X' ? 0 : (scoreMap[guesses] || 15);
                        
                        return {
                            gameId: 'moviedle',
                            puzzleNumber: parseInt(puzzleNum),
                            score: perfect ? '1/6 ðŸŽ¯' : (guesses + '/6'),
                            won: guesses !== 'X',
                            numericScore,
                            meta: { perfect }
                        };
                    }
                    return { gameId: 'moviedle', puzzleNumber: parseInt(puzzleNum), score: 'Completed', won: true, numericScore: 15 };
                }
            },
            // ============ MUSIC GAMES ============
            {
                id: 'heardle',
                // Matches: "Heardle #123" or "ðŸŽµ #123"
                regex: /Heardle\s*#?(\d+)|ðŸŽµ\s*#?(\d+)/i,
                extract: (match, text) => {
                    const puzzleNum = match[1] || match[2];
                    // Find the emoji result line
                    const resultLine = text.split('\n').find(l => /[ðŸŸ¥ðŸŸ©â¬œðŸŸ¨â¬›]/.test(l)) || '';
                    const greenPos = resultLine.indexOf('ðŸŸ©');
                    const won = greenPos !== -1;
                    const guesses = won ? (resultLine.slice(0, greenPos).match(/[ðŸŸ¥â¬œâ¬›]/g) || []).length + 1 : 6;
                    const perfect = guesses === 1;
                    
                    // Battle scoring: match Wordle philosophy
                    const scoreMap = { 1: 35, 2: 28, 3: 22, 4: 16, 5: 10, 6: 6 };
                    const numericScore = won ? (scoreMap[guesses] || 15) : 0;
                    
                    return {
                        gameId: 'heardle',
                        puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null,
                        score: won ? (perfect ? '1/6 ðŸŽ¯' : `${guesses}/6`) : 'X/6',
                        won,
                        numericScore,
                        meta: { guesses, perfect }
                    };
                }
            },
            {
                id: 'bandle',
                // Matches: "Bandle #123 2/6"
                regex: /Bandle\s*#?(\d+)\s*([1-6X])\/6/i,
                extract: (match) => {
                    const puzzleNum = match[1];
                    const guesses = match[2];
                    const perfect = guesses === '1';
                    
                    // Battle scoring: match Wordle philosophy
                    const scoreMap = { '1': 35, '2': 28, '3': 22, '4': 16, '5': 10, '6': 6 };
                    const numericScore = guesses === 'X' ? 0 : (scoreMap[guesses] || 15);
                    
                    return {
                        gameId: 'bandle',
                        puzzleNumber: parseInt(puzzleNum),
                        score: perfect ? '1/6 ðŸŽ¯' : (guesses + '/6'),
                        won: guesses !== 'X',
                        numericScore,
                        meta: { perfect }
                    };
                }
            },
            // ============ MATH/LOGIC GAMES ============
            {
                id: 'nerdle',
                // Matches: "nerdlegame 123 3/6" or "Nerdle #123"
                regex: /nerdle(?:game)?\s*#?(\d+).*?([1-6X])?\/6/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    const guessMatch = text.match(/([1-6X])\/6/);
                    const guesses = guessMatch ? guessMatch[1] : null;
                    const perfect = guesses === '1';
                    if (guesses) {
                        // Battle scoring: match Wordle philosophy
                        const scoreMap = { '1': 35, '2': 28, '3': 22, '4': 16, '5': 10, '6': 6 };
                        const numericScore = guesses === 'X' ? 0 : (scoreMap[guesses] || 15);
                        
                        return {
                            gameId: 'nerdle',
                            puzzleNumber: parseInt(puzzleNum),
                            score: perfect ? '1/6 ðŸŽ¯' : (guesses + '/6'),
                            won: guesses !== 'X',
                            numericScore,
                            meta: { perfect }
                        };
                    }
                    return { gameId: 'nerdle', puzzleNumber: parseInt(puzzleNum), score: 'Completed', won: true, numericScore: 15 };
                }
            },
            // ============ LINKEDIN GAMES (Enhanced) ============
            {
                id: 'queens',
                // Matches: "Queens #123" with optional time
                regex: /Queens\s*#?(\d+)|ðŸ‘‘.*Queens/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    const timeMatch = text.match(/(\d+):(\d+)/);
                    if (timeMatch) {
                        const mins = parseInt(timeMatch[1]);
                        const secs = parseInt(timeMatch[2]);
                        const totalSecs = mins * 60 + secs;
                        
                        // Battle scoring: smoother time curve
                        // <30s: 30, <1min: 26, <2min: 22, <3min: 18, <5min: 14, 5+min: 10
                        const fast = totalSecs <= 30;
                        const numericScore = fast ? 30 : Math.max(28 - Math.floor(totalSecs / 20), 10);
                        
                        return {
                            gameId: 'queens',
                            puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null,
                            score: fast ? `${mins}:${secs.toString().padStart(2, '0')} âš¡` : `${mins}:${secs.toString().padStart(2, '0')}`,
                            won: true,
                            numericScore,
                            meta: { seconds: totalSecs, fast }
                        };
                    }
                    return { gameId: 'queens', puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null, score: 'Completed', won: true, numericScore: 15 };
                }
            },
            {
                id: 'tango',
                regex: /Tango\s*#?(\d+)|ðŸ’ƒ.*Tango/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    const timeMatch = text.match(/(\d+):(\d+)/);
                    if (timeMatch) {
                        const mins = parseInt(timeMatch[1]);
                        const secs = parseInt(timeMatch[2]);
                        const totalSecs = mins * 60 + secs;
                        
                        // Battle scoring: smoother time curve (Tango is slightly longer)
                        // <45s: 30, <1.5min: 26, <2.5min: 22, <4min: 18, 4+min: 12
                        const fast = totalSecs <= 45;
                        const numericScore = fast ? 30 : Math.max(28 - Math.floor(totalSecs / 25), 12);
                        
                        return {
                            gameId: 'tango',
                            puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null,
                            score: fast ? `${mins}:${secs.toString().padStart(2, '0')} âš¡` : `${mins}:${secs.toString().padStart(2, '0')}`,
                            won: true,
                            numericScore,
                            meta: { seconds: totalSecs, fast }
                        };
                    }
                    return { gameId: 'tango', puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null, score: 'Completed', won: true, numericScore: 15 };
                }
            },
            {
                id: 'pinpoint',
                regex: /Pinpoint\s*#?(\d+)|ðŸ“.*Pinpoint/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    const guessMatch = text.match(/(\d+)\s*guess/i);
                    if (guessMatch) {
                        const guesses = parseInt(guessMatch[1]);
                        const perfect = guesses === 1;
                        
                        // Battle scoring: 5 clues, softer penalty
                        // 1 guess: 35, 2: 28, 3: 22, 4: 16, 5: 10
                        const scoreMap = { 1: 35, 2: 28, 3: 22, 4: 16, 5: 10 };
                        const numericScore = scoreMap[guesses] || Math.max(10 - (guesses - 5) * 2, 5);
                        
                        return {
                            gameId: 'pinpoint',
                            puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null,
                            score: perfect ? '1 guess ðŸŽ¯' : `${guesses} guesses`,
                            won: true,
                            numericScore,
                            meta: { guesses, perfect }
                        };
                    }
                    return { gameId: 'pinpoint', puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null, score: 'Completed', won: true, numericScore: 15 };
                }
            },
            {
                id: 'crossclimb',
                regex: /Crossclimb\s*#?(\d+)|ðŸ§—.*Crossclimb/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    const timeMatch = text.match(/(\d+):(\d+)/);
                    if (timeMatch) {
                        const mins = parseInt(timeMatch[1]);
                        const secs = parseInt(timeMatch[2]);
                        const totalSecs = mins * 60 + secs;
                        
                        // Battle scoring: Crossclimb is longer puzzle
                        // <1min: 30, <2min: 26, <3min: 22, <5min: 16, 5+min: 12
                        const fast = totalSecs <= 60;
                        const numericScore = fast ? 30 : Math.max(28 - Math.floor(totalSecs / 30), 12);
                        
                        return {
                            gameId: 'crossclimb',
                            puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null,
                            score: fast ? `${mins}:${secs.toString().padStart(2, '0')} âš¡` : `${mins}:${secs.toString().padStart(2, '0')}`,
                            won: true,
                            numericScore,
                            meta: { seconds: totalSecs, fast }
                        };
                    }
                    return { gameId: 'crossclimb', puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null, score: 'Completed', won: true, numericScore: 15 };
                }
            },
            {
                id: 'zip',
                // LinkedIn Zip game - find the path
                regex: /Zip\s*#?(\d+)|âš¡.*Zip/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    const timeMatch = text.match(/(\d+):(\d+)/);
                    if (timeMatch) {
                        const mins = parseInt(timeMatch[1]);
                        const secs = parseInt(timeMatch[2]);
                        const totalSecs = mins * 60 + secs;
                        
                        // Battle scoring: Zip is quick puzzle
                        // <15s: 30, <30s: 26, <45s: 22, <1min: 18, 1+min: 12
                        const fast = totalSecs <= 15;
                        const numericScore = fast ? 30 : Math.max(28 - Math.floor(totalSecs / 8), 12);
                        
                        return {
                            gameId: 'zip',
                            puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null,
                            score: fast ? `${mins}:${secs.toString().padStart(2, '0')} âš¡` : `${mins}:${secs.toString().padStart(2, '0')}`,
                            won: true,
                            numericScore,
                            meta: { seconds: totalSecs, fast }
                        };
                    }
                    return { gameId: 'zip', puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null, score: 'Completed', won: true, numericScore: 15 };
                }
            },
            // ============ SPORTS ============
            {
                id: 'immaculate-grid',
                // Matches: "Immaculate Grid 123" or score pattern
                regex: /Immaculate\s+Grid\s*#?(\d+)?|âš¾.*(\d+)\/9/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    const scoreMatch = text.match(/(\d+)\/9/);
                    // Also look for rarity score
                    const rarityMatch = text.match(/Rarity:\s*(\d+)/i);
                    if (scoreMatch) {
                        const score = parseInt(scoreMatch[1]);
                        const perfect = score === 9;
                        const rarity = rarityMatch ? parseInt(rarityMatch[1]) : null;
                        return {
                            gameId: 'immaculate-grid',
                            puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null,
                            score: perfect ? '9/9 ðŸŽ¯' : `${score}/9`,
                            won: score >= 5,
                            numericScore: perfect ? 35 : score * 3,
                            meta: { correct: score, rarity, perfect }
                        };
                    }
                    return { gameId: 'immaculate-grid', puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null, score: 'Completed', won: true, numericScore: 15 };
                }
            },
            // ============ MISC WORD GAMES ============
            {
                id: 'redactle',
                // Matches: "I solved Redactle #123 in 45 guesses"
                regex: /Redactle\s*(?:Unlimited)?\s*#?(\d+)?.*?(\d+)\s+guesses/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    const guesses = parseInt(match[2]);
                    const great = guesses <= 20;
                    const good = guesses <= 50;
                    return {
                        gameId: 'redactle',
                        puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null,
                        score: great ? `${guesses} ðŸŽ¯` : `${guesses} guesses`,
                        won: true,
                        numericScore: great ? 30 : (good ? 20 : Math.max(15 - Math.floor(guesses / 20), 5)),
                        meta: { guesses, great }
                    };
                }
            },
            {
                id: 'semantle',
                // Matches: "I solved Semantle #123 in 45 guesses"
                regex: /Semantle\s*#?(\d+)?.*?(\d+)\s+guesses/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    const guesses = parseInt(match[2]);
                    const great = guesses <= 30;
                    const good = guesses <= 100;
                    return {
                        gameId: 'semantle',
                        puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null,
                        score: great ? `${guesses} ðŸŽ¯` : `${guesses} guesses`,
                        won: true,
                        numericScore: great ? 30 : (good ? 20 : Math.max(15 - Math.floor(guesses / 50), 5)),
                        meta: { guesses, great }
                    };
                }
            },
            {
                id: 'costcodle',
                // Matches: "Costcodle #123 3/6"
                regex: /Costcodle\s*#?(\d+).*?([1-6X])\/6/i,
                extract: (match) => {
                    const puzzleNum = match[1];
                    const guesses = match[2];
                    const perfect = guesses === '1';
                    return {
                        gameId: 'costcodle',
                        puzzleNumber: parseInt(puzzleNum),
                        score: perfect ? '1/6 ðŸŽ¯' : (guesses + '/6'),
                        won: guesses !== 'X',
                        numericScore: guesses === 'X' ? 0 : (perfect ? 30 : (7 - parseInt(guesses)) * 4),
                        meta: { perfect }
                    };
                }
            },
            {
                id: 'wheretaken',
                // Matches: "WhereTaken #123 (date) 3/6"
                regex: /WhereTaken\s*(?:USA|World)?\s*#?(\d+).*?([1-6X])\/6/i,
                extract: (match) => {
                    const puzzleNum = match[1];
                    const guesses = match[2];
                    const perfect = guesses === '1';
                    return {
                        gameId: 'wheretaken',
                        puzzleNumber: parseInt(puzzleNum),
                        score: perfect ? '1/6 ðŸŽ¯' : (guesses + '/6'),
                        won: guesses !== 'X',
                        numericScore: guesses === 'X' ? 0 : (perfect ? 30 : (7 - parseInt(guesses)) * 4),
                        meta: { perfect }
                    };
                }
            },
            {
                id: 'foodguessr',
                // Matches: "FoodGuessr #123" with points
                regex: /FoodGuessr\s*#?(\d+)?/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    const scoreMatch = text.match(/(\d+)\s*points?/i);
                    if (scoreMatch) {
                        const points = parseInt(scoreMatch[1]);
                        const perfect = points >= 25000; // Max is 25000
                        return {
                            gameId: 'foodguessr',
                            puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null,
                            score: perfect ? `${points} ðŸŽ¯` : `${points} pts`,
                            won: true,
                            numericScore: Math.min(Math.floor(points / 1000), 25),
                            meta: { points, perfect }
                        };
                    }
                    return { gameId: 'foodguessr', puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null, score: 'Completed', won: true, numericScore: 15 };
                }
            },
            // ============ GAME SHELF ORIGINALS (Enhanced) ============
            {
                id: 'quotle',
                // Matches: "Quotle #123" with score pattern "2/4" or result emojis
                regex: /Quotle\s*#?(\d+)?/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    
                    // Battle scoring: 4-guess format with hole-in-one
                    // 1/4: 50 (rare!), 2/4: 30, 3/4: 20, 4/4: 12
                    const scoreMap = { '1': 50, '2': 30, '3': 20, '4': 12 };
                    
                    // Check for perfect first (1/4)
                    if (text.includes('1/4') && text.includes('ðŸŸ©')) {
                        return {
                            gameId: 'quotle',
                            puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null,
                            score: '1/4 ðŸŽ¯',
                            won: true,
                            numericScore: 50,
                            meta: { perfect: true }
                        };
                    }
                    // Match score pattern X/4
                    const scoreMatch = text.match(/([1-4X])\/4/);
                    if (scoreMatch) {
                        const guesses = scoreMatch[1];
                        const won = guesses !== 'X';
                        const great = won && parseInt(guesses) <= 2;
                        const numericScore = won ? (scoreMap[guesses] || 15) : 0;
                        
                        return {
                            gameId: 'quotle',
                            puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null,
                            score: great ? `${guesses}/4 â­` : `${guesses}/4`,
                            won,
                            numericScore,
                            meta: { guesses: won ? parseInt(guesses) : 4, great }
                        };
                    }
                    // Check for gave up (ðŸ³ï¸)
                    if (text.includes('ðŸ³ï¸')) {
                        return {
                            gameId: 'quotle',
                            puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null,
                            score: 'Gave up',
                            won: false,
                            numericScore: 0
                        };
                    }
                    return {
                        gameId: 'quotle',
                        puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null,
                        score: text.includes('âŒ') ? 'X/4' : 'Done',
                        won: !text.includes('âŒ'),
                        numericScore: text.includes('âŒ') ? 0 : 15
                    };
                }
            },
            {
                id: 'slate',
                // Matches: "Slate #123" with score pattern
                regex: /Slate\s*#?(\d+)?/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    // Check for Score: X pattern (actual share format)
                    const scoreMatch = text.match(/Score:\s*(\d+)/i);
                    // Check for DNF pattern
                    const dnfMatch = text.match(/DNF\s*\((\d+)\/8\)/i);
                    
                    if (scoreMatch) {
                        const score = parseInt(scoreMatch[1]);
                        // Lower score is better in Slate (0 = perfect)
                        const perfect = score === 0;
                        const great = score <= 8;
                        let displayScore = perfect ? '0 ðŸŽ¯' : (great ? `${score} â­` : `${score}`);
                        return {
                            gameId: 'slate',
                            puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null,
                            score: displayScore,
                            won: true,
                            numericScore: perfect ? 40 : Math.max(35 - score, 5),
                            meta: { score, perfect, great }
                        };
                    }
                    if (dnfMatch) {
                        const wordsCompleted = parseInt(dnfMatch[1]);
                        return {
                            gameId: 'slate',
                            puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null,
                            score: `DNF ${wordsCompleted}/8`,
                            won: false,
                            numericScore: wordsCompleted * 2,
                            meta: { wordsCompleted, dnf: true }
                        };
                    }
                    // Fallback - check for result emoji
                    const won = !text.includes('âŒ') && !text.includes('ðŸ’€');
                    return { 
                        gameId: 'slate', 
                        puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null, 
                        score: won ? 'Completed' : 'DNF', 
                        won, 
                        numericScore: won ? 15 : 5 
                    };
                }
            },
            {
                id: 'rungs',
                // Matches: "Rungs #123" with attempts pattern
                regex: /Rungs\s*#?(\d+)?/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    // Match X/4 pattern (actual share format)
                    const scoreMatch = text.match(/([0-4])\/4/);
                    // Check for bonus
                    const hasBonus = text.includes('Bonus') || text.includes('â­');
                    
                    if (scoreMatch) {
                        const attempts = parseInt(scoreMatch[1]);
                        const won = attempts > 0;
                        const perfect = won && attempts === 1 && hasBonus;
                        const great = won && attempts <= 2;
                        
                        let displayScore = `${attempts}/4`;
                        if (perfect) displayScore += ' ðŸŽ¯';
                        else if (hasBonus) displayScore += ' â­';
                        else if (great) displayScore += ' â­';
                        
                        // Battle scoring: softer penalty per attempt
                        // Perfect: 35, 2 attempts: 28, 3 attempts: 21, 4 attempts: 14
                        const numericScore = perfect ? 35 : (won ? Math.max(28 - (attempts - 1) * 7, 10) : 0);
                        
                        return {
                            gameId: 'rungs',
                            puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null,
                            score: displayScore,
                            won,
                            numericScore,
                            meta: { attempts, perfect, hasBonus }
                        };
                    }
                    // Fallback - check for result emoji
                    const won = text.includes('âœ…') || text.includes('ðŸŽ¯');
                    return { 
                        gameId: 'rungs', 
                        puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null, 
                        score: won ? 'Completed' : 'DNF', 
                        won, 
                        numericScore: won ? 15 : 0 
                    };
                }
            },
            {
                id: 'wordboxing',
                // Matches: "Word Boxing" with win/loss indicators
                regex: /Word\s*Boxing|ðŸ¥Š.*Boxing/i,
                extract: (match, text) => {
                    // Check for win indicators: ðŸ†, âœ…, or "won"
                    // Check for loss indicators: âŒ, or "lost"
                    const hasWinEmoji = text.includes('ðŸ†') || text.includes('âœ…');
                    const hasLossEmoji = text.includes('âŒ');
                    const won = hasWinEmoji || (!hasLossEmoji && !text.toLowerCase().includes('lost'));
                    
                    // Match score pattern X-Y
                    const scoreMatch = text.match(/(\d+)\s*-\s*(\d+)/);
                    let score = won ? 'Won! ðŸ†' : 'Lost';
                    let numericScore = won ? 25 : 10;
                    
                    if (scoreMatch) {
                        const myScore = parseInt(scoreMatch[1]);
                        const oppScore = parseInt(scoreMatch[2]);
                        score = `${myScore}-${oppScore}`;
                        if (won) {
                            score += ' ðŸ†';
                            // Bonus points for dominant wins
                            if (myScore >= 3 && oppScore === 0) numericScore = 35;
                            else if (myScore - oppScore >= 2) numericScore = 30;
                        }
                    }
                    return {
                        gameId: 'wordboxing',
                        score,
                        won,
                        numericScore,
                        meta: { won }
                    };
                }
            },
            // ============ MULTI-WORD VARIANTS ============
            {
                id: 'duotrigordle',
                // Matches: "Daily Duotrigordle #123"
                regex: /Daily\s+Duotrigordle\s+#?(\d+)/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    const failed = (text.match(/ðŸŸ¥/g) || []).length;
                    const solved = 32 - failed;
                    const perfect = failed === 0;
                    return {
                        gameId: 'duotrigordle',
                        puzzleNumber: parseInt(puzzleNum),
                        score: perfect ? '32/32 ðŸŽ¯' : `${solved}/32`,
                        won: failed < 16,
                        numericScore: perfect ? 40 : Math.max(35 - failed, 10),
                        meta: { solved, failed, perfect }
                    };
                }
            },
            {
                id: 'sedecordle',
                // Matches: "Daily Sedecordle #123"
                regex: /Daily\s+Sedecordle\s+#?(\d+)/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    const failed = (text.match(/ðŸŸ¥/g) || []).length;
                    const solved = 16 - failed;
                    const perfect = failed === 0;
                    return {
                        gameId: 'sedecordle',
                        puzzleNumber: parseInt(puzzleNum),
                        score: perfect ? '16/16 ðŸŽ¯' : `${solved}/16`,
                        won: failed < 8,
                        numericScore: perfect ? 30 : Math.max(25 - failed, 5),
                        meta: { solved, failed, perfect }
                    };
                }
            },
            // ============ OTHER GAMES ============
            {
                id: 'tiles',
                regex: /Tiles\s*#?(\d+)?|ðŸ”².*Tiles/i,
                extract: (match, text) => {
                    const puzzleNum = match ? match[1] : null;
                    const scoreMatch = text.match(/(\d+)\s*pts?/i);
                    if (scoreMatch) {
                        const points = parseInt(scoreMatch[1]);
                        return {
                            gameId: 'tiles',
                            puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null,
                            score: `${points} pts`,
                            won: true,
                            numericScore: Math.min(Math.floor(points / 10), 25)
                        };
                    }
                    return { gameId: 'tiles', puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null, score: 'Completed', won: true, numericScore: 15 };
                }
            },
            {
                id: 'timeguessr',
                regex: /TimeGuessr\s*#?(\d+)?/i,
                extract: (match, text) => {
                    const puzzleNum = match[1];
                    const scoreMatch = text.match(/(\d+)\s*pts?/i);
                    if (scoreMatch) {
                        const points = parseInt(scoreMatch[1]);
                        const great = points >= 20000;
                        return {
                            gameId: 'timeguessr',
                            puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null,
                            score: great ? `${points} ðŸŽ¯` : `${points} pts`,
                            won: true,
                            numericScore: Math.min(Math.floor(points / 1000), 25),
                            meta: { points, great }
                        };
                    }
                    return { gameId: 'timeguessr', puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null, score: 'Completed', won: true, numericScore: 15 };
                }
            },
            {
                id: 'vertex',
                regex: /Vertex\s*#?(\d+)?|I\s+solved\s+Vertex/i,
                extract: (match, text) => {
                    const puzzleNum = match ? match[1] : null;
                    const timeMatch = text.match(/(\d+):(\d+)/);
                    if (timeMatch) {
                        const mins = parseInt(timeMatch[1]);
                        const secs = parseInt(timeMatch[2]);
                        const totalSecs = mins * 60 + secs;
                        const fast = totalSecs <= 60;
                        return {
                            gameId: 'vertex',
                            puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null,
                            score: fast ? `${mins}:${secs.toString().padStart(2, '0')} âš¡` : `${mins}:${secs.toString().padStart(2, '0')}`,
                            won: true,
                            numericScore: fast ? 25 : 20,
                            meta: { seconds: totalSecs, fast }
                        };
                    }
                    return { gameId: 'vertex', puzzleNumber: puzzleNum ? parseInt(puzzleNum) : null, score: 'Completed', won: true, numericScore: 15 };
                }
            }
        ];
        
        // ============ DATA MANAGEMENT ============
        function loadData() {
            try {
                const stored = localStorage.getItem('gameShelfData');
                if (stored) {
                    const parsed = JSON.parse(stored);
                    // Merge with defaults to ensure all fields exist
                    const defaults = createDefaultData();
                    appData = {
                        ...defaults,
                        ...parsed,
                        // Deep merge nested objects
                        wallet: { ...defaults.wallet, ...(parsed.wallet || {}) },
                        settings: { ...defaults.settings, ...(parsed.settings || {}) },
                        referral: { ...defaults.referral, ...(parsed.referral || {}) },
                        // Ensure these are at least empty objects/arrays
                        stats: parsed.stats || {},
                        history: parsed.history || {},
                        games: parsed.games || [],
                        achievements: (parsed.achievements && !Array.isArray(parsed.achievements)) ? parsed.achievements : {},
                        activityLog: parsed.activityLog || [],
                        friends: parsed.friends || []
                    };
                    
                    // Safeguard: if games is empty, populate with defaults
                    if (!appData.games || appData.games.length === 0) {
                        appData.games = DEFAULT_SHELF.map(id => ({ id, addedAt: new Date().toISOString() }));
                        saveData();
                    }
                } else {
                    appData = createDefaultData();
                    saveData();
                }
            } catch (e) {
                console.error('Load error:', e);
                appData = createDefaultData();
            }
            return appData;
        }
        
        function createDefaultData() {
            return {
                games: DEFAULT_SHELF.map(id => ({ id, addedAt: new Date().toISOString() })),
                stats: {},
                history: {},
                wallet: { tokens: 50, coins: 0 },
                achievements: {},
                dailyGoal: 5,
                friends: [],
                settings: {
                    showActivitySummary: true
                },
                activityLog: [],
                lastVisit: Date.now(),
                lastSummaryShown: 0,
                referral: {
                    myCode: null,
                    referredBy: null,
                    invitesSent: 0,
                    friendsJoined: 0,
                    friendsEngaged: 0,
                    totalEarned: 0
                }
            };
        }
        
        function saveData() {
            try {
                // Prune old grids before saving (keep last 30 days)
                pruneOldGrids();
                localStorage.setItem('gameShelfData', JSON.stringify(appData));
            } catch (e) {
                console.error('Save error:', e);
            }
        }
        
        // Remove grid data from entries older than 31 days to save storage
        function pruneOldGrids() {
            if (!appData.history) return;
            
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - 31);
            const cutoffStr = cutoffDate.toISOString().split('T')[0];
            
            let pruned = 0;
            for (const dateStr of Object.keys(appData.history)) {
                if (dateStr < cutoffStr) {
                    // Remove grid and shareText from old entries
                    for (const gameId of Object.keys(appData.history[dateStr])) {
                        const entry = appData.history[dateStr][gameId];
                        if (entry.grid) {
                            delete entry.grid;
                            pruned++;
                        }
                        if (entry.shareText) {
                            delete entry.shareText;
                        }
                    }
                }
            }
            
            if (pruned > 0) {
                console.log(`[STORAGE] Pruned ${pruned} old grids (>31 days)`);
            }
        }
        
        // ============ ACTIVITY TRACKING ============
        function logActivity(type, data = {}) {
            if (!appData.activityLog) appData.activityLog = [];
            
            appData.activityLog.unshift({
                type,
                ...data,
                ts: Date.now()
            });
            
            // Keep only last 100 events
            if (appData.activityLog.length > 100) {
                appData.activityLog = appData.activityLog.slice(0, 100);
            }
        }
        
        function getActivitySince(timestamp) {
            if (!appData.activityLog) return [];
            const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
            const cutoff = Math.max(timestamp, sevenDaysAgo);
            return appData.activityLog.filter(a => a.ts > cutoff);
        }
        
        function generateActivitySummary() {
            const lastVisit = Number(appData.lastVisit) || Date.now();
            const activities = getActivitySince(lastVisit);
            
            // Get history from last 7 days for stats
            const sevenDaysAgo = new Date();
            sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
            
            const daysSinceVisit = Math.floor((Date.now() - lastVisit) / (24 * 60 * 60 * 1000));
            const summary = {
                daysSinceVisit: isNaN(daysSinceVisit) ? 0 : daysSinceVisit,
                gamesLogged: 0,
                totalPoints: 0,
                perfectGames: [],
                newAchievements: [],
                streakMilestones: [],
                battleUpdates: [],
                suggestions: []
            };
            
            // Count games and points from history (last 7 days)
            // v1.3.0: Use local time for history lookup, not UTC
            const now = new Date();
            for (let i = 0; i < 7; i++) {
                const d = new Date(now);
                d.setDate(d.getDate() - i);
                const dateStr = getLocalDateString(d);
                const dayHistory = appData.history[dateStr];
                if (dayHistory) {
                    Object.entries(dayHistory).forEach(([gameId, data]) => {
                        const logTime = new Date(data.time).getTime();
                        if (logTime > lastVisit) {
                            summary.gamesLogged++;
                            summary.totalPoints += data.numericScore || 0;
                            
                            // Check for perfect games
                            if (data.score?.includes('ðŸŽ¯') || data.score === '1/6' || data.score === '2/6') {
                                const game = GAMES[gameId];
                                summary.perfectGames.push({
                                    gameId,
                                    name: game?.name || gameId,
                                    icon: game?.icon || 'ðŸŽ®',
                                    score: data.score
                                });
                            }
                        }
                    });
                }
            }
            
            // Parse activity log for specific events
            activities.forEach(activity => {
                switch (activity.type) {
                    case 'achievement-unlocked':
                        summary.newAchievements.push(activity);
                        break;
                    case 'streak-milestone':
                        summary.streakMilestones.push(activity);
                        break;
                    case 'battle-won':
                    case 'battle-joined':
                    case 'battle-created':
                    case 'battle-invite':
                        summary.battleUpdates.push(activity);
                        break;
                }
            });
            
            // Generate suggestions
            summary.suggestions = generateSuggestions();
            
            return summary;
        }
        
        function generateSuggestions() {
            const suggestions = [];
            const now = new Date();
            const today = getTodayString();
            
            // Check for games not played recently
            appData.games.forEach(game => {
                const stats = appData.stats[game.id];
                if (stats?.lastPlayed) {
                    const lastPlayed = new Date(stats.lastPlayed);
                    if (isNaN(lastPlayed.getTime())) return; // Skip invalid dates
                    const daysSince = Math.floor((now - lastPlayed) / (24 * 60 * 60 * 1000));
                    
                    if (daysSince >= 5 && daysSince < 14 && !isNaN(daysSince)) {
                        const gameInfo = GAMES[game.id];
                        suggestions.push({
                            type: 'not-played',
                            icon: gameInfo?.icon || 'ðŸŽ®',
                            text: `You haven't played ${gameInfo?.name || game.id} in ${daysSince} days`
                        });
                    }
                }
            });
            
            // Check for streaks at risk
            appData.games.forEach(game => {
                const stats = appData.stats[game.id];
                if (stats?.currentStreak >= 3 && stats.lastPlayed !== today) {
                    const gameInfo = GAMES[game.id];
                    suggestions.push({
                        type: 'streak-risk',
                        icon: 'ðŸ”¥',
                        text: `Your ${stats.currentStreak}-day ${gameInfo?.name || game.id} streak is at risk!`
                    });
                }
            });
            
            // Check for approaching milestones
            appData.games.forEach(game => {
                const stats = appData.stats[game.id];
                if (stats?.currentStreak) {
                    const nextMilestone = [7, 14, 30, 50, 100].find(m => m > stats.currentStreak);
                    if (nextMilestone && (nextMilestone - stats.currentStreak) <= 2) {
                        const gameInfo = GAMES[game.id];
                        suggestions.push({
                            type: 'milestone-close',
                            icon: 'â­',
                            text: `${nextMilestone - stats.currentStreak} more day${nextMilestone - stats.currentStreak > 1 ? 's' : ''} to ${nextMilestone}-day ${gameInfo?.name || game.id} streak!`
                        });
                    }
                }
            });
            
            // Check for incomplete daily goal
            const todayPlayed = getGamesPlayedToday();
            const goal = appData.dailyGoal || 5;
            if (todayPlayed < goal && todayPlayed > 0) {
                suggestions.push({
                    type: 'daily-goal',
                    icon: 'ðŸŽ¯',
                    text: `${goal - todayPlayed} more game${goal - todayPlayed > 1 ? 's' : ''} to hit your daily goal!`
                });
            }
            
            // Limit to top 3 most relevant
            return suggestions.slice(0, 3);
        }
        
        // ============ GAME RECOMMENDATIONS ENGINE ============
        
        // Map game categories for similarity
        const GAME_SIMILARITY = {
            wordle: ['quordle', 'dordle', 'octordle', 'waffle'],
            connections: ['strands', 'queens', 'tango'],
            strands: ['connections', 'waffle', 'semantle'],
            mini: ['crossclimb', 'letterboxed'],
            'spelling-bee': ['redactle', 'contexto', 'semantle'],
            letterboxed: ['mini', 'waffle'],
            queens: ['tango', 'connections', 'pinpoint'],
            tango: ['queens', 'zip', 'connections'],
            pinpoint: ['contexto', 'queens', 'framed'],
            crossclimb: ['mini', 'zip'],
            zip: ['tango', 'crossclimb', 'nerdle'],
            quordle: ['wordle', 'octordle', 'dordle'],
            octordle: ['quordle', 'dordle', 'wordle'],
            waffle: ['wordle', 'strands', 'letterboxed'],
            redactle: ['semantle', 'contexto', 'spelling-bee'],
            semantle: ['contexto', 'redactle', 'spelling-bee'],
            nerdle: ['zip', 'mini', 'crossclimb'],
            contexto: ['semantle', 'pinpoint', 'redactle'],
            dordle: ['wordle', 'quordle', 'octordle'],
            worldle: ['globle', 'tradle', 'travle'],
            globle: ['worldle', 'travle', 'wheretaken'],
            tradle: ['worldle', 'globle', 'foodguessr'],
            wheretaken: ['globle', 'worldle', 'foodguessr'],
            foodguessr: ['tradle', 'wheretaken', 'globle'],
            travle: ['worldle', 'globle', 'wheretaken'],
            framed: ['moviedle', 'actorle', 'pinpoint'],
            actorle: ['framed', 'moviedle', 'heardle'],
            moviedle: ['framed', 'actorle', 'bandle'],
            heardle: ['bandle', 'actorle', 'moviedle'],
            bandle: ['heardle', 'moviedle', 'framed'],
            'immaculate-grid': ['costcodle', 'nerdle'],
            costcodle: ['immaculate-grid', 'foodguessr'],
            quotle: ['semantle', 'contexto', 'redactle'],
            slate: ['wordle', 'waffle', 'strands'],
            rungs: ['wordle', 'dordle', 'quordle'],
            wordboxing: ['wordle', 'quordle', 'slate']
        };
        
        function generateGameRecommendations() {
            const recommendations = [];
            const onShelf = new Set(appData.games.map(g => g.id));
            const allGameIds = Object.keys(GAMES);
            
            // 1. SIMILAR GAMES - Based on what user plays
            const similarGames = new Map(); // gameId -> { score, reasons }
            
            appData.games.forEach(userGame => {
                const similar = GAME_SIMILARITY[userGame.id] || [];
                similar.forEach((simId, index) => {
                    if (!onShelf.has(simId) && GAMES[simId]) {
                        const existing = similarGames.get(simId) || { score: 0, basedOn: [] };
                        existing.score += (3 - index); // Higher score for first suggestions
                        existing.basedOn.push(GAMES[userGame.id]?.name || userGame.id);
                        similarGames.set(simId, existing);
                    }
                });
            });
            
            // Convert to array and sort by score
            const similarSorted = Array.from(similarGames.entries())
                .sort((a, b) => b[1].score - a[1].score)
                .slice(0, 3);
            
            similarSorted.forEach(([gameId, data]) => {
                const game = GAMES[gameId];
                recommendations.push({
                    id: gameId,
                    type: 'similar',
                    game: game,
                    reason: `Because you play ${data.basedOn[0]}`,
                    reasonIcon: 'ðŸŽ¯',
                    priority: 10 + data.score
                });
            });
            
            // 2. FRIENDS PLAY THIS - Games friends have that user doesn't
            if (friendsData.length > 0 && Object.keys(friendsShelfData).length > 0) {
                const friendGameCounts = new Map(); // gameId -> { count, friends }
                
                Object.entries(friendsShelfData).forEach(([friendId, shelfData]) => {
                    const friend = friendsData.find(f => f.odataId === friendId);
                    if (!friend) return;
                    
                    // Check which games this friend tracks (from their public profile)
                    // We don't have their full shelf, but we can infer from activity
                    if (shelfData.lastActivity?.gameId) {
                        const gameId = shelfData.lastActivity.gameId;
                        if (!onShelf.has(gameId) && GAMES[gameId]) {
                            const existing = friendGameCounts.get(gameId) || { count: 0, friends: [] };
                            existing.count++;
                            existing.friends.push({
                                name: shelfData.displayName || friend.displayName || 'Friend',
                                initial: (shelfData.displayName || friend.displayName || 'F')[0].toUpperCase()
                            });
                            friendGameCounts.set(gameId, existing);
                        }
                    }
                });
                
                // Sort by friend count
                const friendGamesSorted = Array.from(friendGameCounts.entries())
                    .sort((a, b) => b[1].count - a[1].count)
                    .slice(0, 2);
                
                friendGamesSorted.forEach(([gameId, data]) => {
                    const game = GAMES[gameId];
                    const friendText = data.count === 1 
                        ? `${data.friends[0].name} plays this`
                        : `${data.count} friends play this`;
                    
                    recommendations.push({
                        id: gameId,
                        type: 'friends',
                        game: game,
                        reason: friendText,
                        reasonIcon: 'ðŸ‘¥',
                        friends: data.friends.slice(0, 3),
                        priority: 15 + data.count * 2
                    });
                });
            }
            
            // 3. COMPLETE THE SET - If user has most games in a category
            GAME_CATEGORIES.forEach(category => {
                const userHas = category.games.filter(id => onShelf.has(id));
                const missing = category.games.filter(id => !onShelf.has(id) && GAMES[id]);
                
                // If user has 50%+ of category but not all
                if (userHas.length >= category.games.length * 0.5 && missing.length > 0 && missing.length <= 2) {
                    missing.forEach(gameId => {
                        // Check if already in recommendations
                        if (!recommendations.find(r => r.id === gameId)) {
                            const game = GAMES[gameId];
                            recommendations.push({
                                id: gameId,
                                type: 'complete-set',
                                game: game,
                                reason: `Complete your ${category.name}`,
                                reasonIcon: 'ðŸ†',
                                badge: `${userHas.length}/${category.games.length}`,
                                priority: 12
                            });
                        }
                    });
                }
            });
            
            // 4. GAME SHELF ORIGINALS - If not playing any
            const originalsOnShelf = ['quotle', 'slate', 'rungs', 'wordboxing'].filter(id => onShelf.has(id));
            if (originalsOnShelf.length === 0) {
                // Recommend Quotle first
                if (!recommendations.find(r => r.id === 'quotle')) {
                    recommendations.push({
                        id: 'quotle',
                        type: 'featured',
                        game: GAMES['quotle'],
                        reason: 'Game Shelf Original',
                        reasonIcon: 'â­',
                        priority: 8
                    });
                }
            }
            
            // 5. POPULAR GAMES - Fallback if we don't have enough
            if (recommendations.length < 3) {
                POPULAR_GAMES.forEach(gameId => {
                    if (!onShelf.has(gameId) && GAMES[gameId] && !recommendations.find(r => r.id === gameId)) {
                        recommendations.push({
                            id: gameId,
                            type: 'popular',
                            game: GAMES[gameId],
                            reason: 'Popular game',
                            reasonIcon: 'ðŸ”¥',
                            priority: 5
                        });
                    }
                });
            }
            
            // Sort by priority and return top 3
            // v1.3.0: Add slight random factor to break ties and provide variety on refresh
            recommendations.forEach(r => {
                r.priority += Math.random() * 0.5;
            });
            recommendations.sort((a, b) => b.priority - a.priority);
            return recommendations.slice(0, 3);
        }
        
        function renderRecommendations() {
            // Render game recommendations to Games tab
            renderGameRecommendations();
            
            // Render battle recommendations to Social tab
            renderBattleRecommendations();
            
            // Render friend recommendations to Share tab
            renderFriendRecommendations();
        }
        
        function renderGameRecommendations() {
            const container = document.getElementById('recommendations-list');
            const section = document.getElementById('recommendations-section');
            
            if (!container || !section) return;
            
            const recommendations = generateGameRecommendations();
            
            if (recommendations.length === 0) {
                section.style.display = 'none';
                return;
            }
            
            section.style.display = 'block';
            
            container.innerHTML = recommendations.map(rec => {
                let friendAvatars = '';
                if (rec.friends && rec.friends.length > 0) {
                    friendAvatars = `
                        <div class="recommendation-friends">
                            ${rec.friends.slice(0, 3).map(f => 
                                `<div class="recommendation-friend-avatar">${f.initial}</div>`
                            ).join('')}
                            ${rec.friends.length > 3 ? `<div class="recommendation-friend-avatar more">+${rec.friends.length - 3}</div>` : ''}
                        </div>
                    `;
                }
                
                return `
                    <div class="recommendation-card" onclick="addRecommendedGame('${rec.id}')">
                        <div class="recommendation-icon">${rec.game.icon}</div>
                        <div class="recommendation-info">
                            <div class="recommendation-name">${rec.game.name}</div>
                            <div class="recommendation-reason">
                                <span class="reason-icon">${rec.reasonIcon}</span>
                                <span>${rec.reason}</span>
                                ${friendAvatars}
                            </div>
                        </div>
                        <button class="recommendation-action" onclick="event.stopPropagation(); addRecommendedGame('${rec.id}')">+ Add</button>
                    </div>
                `;
            }).join('');
        }
        
        function renderBattleRecommendations() {
            const container = document.getElementById('recommendations-list-social');
            const section = document.getElementById('recommendations-section-social');
            
            if (!container || !section) return;
            
            const recommendations = [];
            
            // 1. Public battles to join
            if (publicBattles && publicBattles.length > 0) {
                const joinableBattles = publicBattles
                    .filter(b => !b.participants?.includes(currentUser?.uid))
                    .slice(0, 2);
                    
                joinableBattles.forEach(battle => {
                    recommendations.push({
                        type: 'public-battle',
                        icon: battle.typeIcon || 'âš”ï¸',
                        title: battle.name || 'Public Battle',
                        subtitle: `${battle.participantCount || 0} players â€¢ ${battle.typeName || 'Battle'}`,
                        action: 'Join',
                        actionFn: `joinPublicBattle('${battle.id}')`
                    });
                });
            }
            
            // 2. Friends to challenge (active friends who played today)
            const activeFriends = (friends || [])
                .filter(f => f.todayGames && f.todayGames > 0)
                .slice(0, 2);
                
            activeFriends.forEach(friend => {
                recommendations.push({
                    type: 'challenge-friend',
                    icon: 'ðŸŽ¯',
                    title: `Challenge ${escapeHtml(friend.displayName?.split(' ')[0] || 'Friend')}`,
                    subtitle: `Played ${parseInt(friend.todayGames)} game${friend.todayGames > 1 ? 's' : ''} today`,
                    action: 'Challenge',
                    actionFn: `challengeFriend('${escapeAttr(friend.odataId)}')`
                });
            });
            
            // 3. Create a battle suggestion
            if (recommendations.length < 3) {
                recommendations.push({
                    type: 'create-battle',
                    icon: 'âš”ï¸',
                    title: 'Start a Battle',
                    subtitle: 'Challenge friends to compete',
                    action: 'Create',
                    actionFn: 'showCreateBattle()'
                });
            }
            
            if (recommendations.length === 0) {
                section.style.display = 'none';
                return;
            }
            
            section.style.display = 'block';
            
            container.innerHTML = recommendations.slice(0, 3).map(rec => `
                <div class="recommendation-card" onclick="${rec.actionFn}">
                    <div class="recommendation-icon">${rec.icon}</div>
                    <div class="recommendation-info">
                        <div class="recommendation-name">${rec.title}</div>
                        <div class="recommendation-reason">
                            <span>${rec.subtitle}</span>
                        </div>
                    </div>
                    <button class="recommendation-action" onclick="event.stopPropagation(); ${rec.actionFn}">${rec.action}</button>
                </div>
            `).join('');
        }
        
        function renderFriendRecommendations() {
            const container = document.getElementById('recommendations-list-share');
            const section = document.getElementById('recommendations-section-share');
            
            if (!container || !section) return;
            
            const recommendations = [];
            
            // 1. Friends who haven't played today (nudge them)
            const inactiveFriends = (friends || [])
                .filter(f => !f.todayGames || f.todayGames === 0)
                .slice(0, 2);
                
            inactiveFriends.forEach(friend => {
                recommendations.push({
                    type: 'nudge-friend',
                    icon: 'ðŸ‘‹',
                    title: `Nudge ${escapeHtml(friend.displayName?.split(' ')[0] || 'Friend')}`,
                    subtitle: "Hasn't played today yet",
                    action: 'Nudge',
                    actionFn: `sendNudge('${escapeAttr(friend.odataId)}')`
                });
            });
            
            // 2. Invite more friends suggestion
            if (recommendations.length < 3) {
                recommendations.push({
                    type: 'invite-friends',
                    icon: 'ðŸ“¨',
                    title: 'Invite Friends',
                    subtitle: 'Earn 110 tokens per friend!',
                    action: 'Invite',
                    actionFn: 'showReferralSheet()'
                });
            }
            
            // 3. Find from contacts
            if (recommendations.length < 3 && 'contacts' in navigator) {
                recommendations.push({
                    type: 'find-contacts',
                    icon: 'ðŸ“±',
                    title: 'Find Friends',
                    subtitle: 'Check who else is on Game Shelf',
                    action: 'Find',
                    actionFn: 'findFriendsFromContacts()'
                });
            }
            
            // 4. Share your profile
            if (recommendations.length < 3) {
                recommendations.push({
                    type: 'share-profile',
                    icon: 'ðŸ”—',
                    title: 'Share Your Profile',
                    subtitle: 'Let others find and add you',
                    action: 'Share',
                    actionFn: 'shareProfile()'
                });
            }
            
            if (recommendations.length === 0) {
                section.style.display = 'none';
                return;
            }
            
            section.style.display = 'block';
            
            container.innerHTML = recommendations.slice(0, 3).map(rec => `
                <div class="recommendation-card" onclick="${rec.actionFn}">
                    <div class="recommendation-icon">${rec.icon}</div>
                    <div class="recommendation-info">
                        <div class="recommendation-name">${rec.title}</div>
                        <div class="recommendation-reason">
                            <span>${rec.subtitle}</span>
                        </div>
                    </div>
                    <button class="recommendation-action" onclick="event.stopPropagation(); ${rec.actionFn}">${rec.action}</button>
                </div>
            `).join('');
        }
        
        // Share profile function
        function shareProfile() {
            if (!currentUser) {
                showToast('Sign in to share your profile');
                return;
            }
            const profileUrl = generateProfileLink(currentUser.uid);
            if (navigator.share) {
                navigator.share({
                    title: 'Add me on Game Shelf!',
                    text: 'Track your daily puzzles with me on Game Shelf ðŸŽ®',
                    url: profileUrl
                }).catch(() => {
                    // Share cancelled or failed, fall back to copy
                    navigator.clipboard.writeText(profileUrl).then(() => {
                        showToast('Profile link copied!', 'success');
                    }).catch(() => {
                        showToast('Could not copy link', 'error');
                    });
                });
            } else {
                navigator.clipboard.writeText(profileUrl).then(() => {
                    showToast('Profile link copied!', 'success');
                }).catch(() => {
                    showToast('Could not copy link', 'error');
                });
            }
        }
        
        // Challenge a specific friend to a battle
        function challengeFriend(friendUid) {
            const friend = getFriend(friendUid);
            const friendName = friend?.displayName?.split(' ')[0] || 'friend';
            showCreateBattle();
            showToast(`âš”ï¸ Create a battle to challenge ${friendName}!`);
        }
        
        // Toggle recommendations expanded/collapsed
        function toggleRecommendations(tab) {
            const suffixes = { games: '', social: '-social', share: '-share' };
            const suffix = suffixes[tab] || '';
            
            const header = document.querySelector(`#recommendations-section${suffix} .recommendations-header`);
            const list = document.getElementById(`recommendations-list${suffix}`);
            
            if (!header || !list) return;
            
            const isExpanded = header.classList.contains('expanded');
            
            if (isExpanded) {
                // Collapse
                header.classList.remove('expanded');
                list.classList.remove('expanded');
            } else {
                // Expand
                header.classList.add('expanded');
                list.classList.add('expanded');
            }
            
            // Save state
            const state = JSON.parse(localStorage.getItem('recsExpanded') || '{}');
            state[tab] = !isExpanded;
            localStorage.setItem('recsExpanded', JSON.stringify(state));
        }
        
        // Restore recommendations expanded state
        function restoreRecommendationsState() {
            const state = JSON.parse(localStorage.getItem('recsExpanded') || '{}');
            
            ['games', 'social', 'share'].forEach(tab => {
                if (state[tab]) {
                    const suffixes = { games: '', social: '-social', share: '-share' };
                    const suffix = suffixes[tab];
                    
                    const header = document.querySelector(`#recommendations-section${suffix} .recommendations-header`);
                    const list = document.getElementById(`recommendations-list${suffix}`);
                    
                    if (header && list) {
                        header.classList.add('expanded');
                        list.classList.add('expanded');
                    }
                }
            });
        }
        
        function addRecommendedGame(gameId) {
            const game = GAMES[gameId];
            if (!game) return;
            
            // Check if already on shelf
            if (appData.games.find(g => g.id === gameId)) {
                showToast(`${game.name} is already on your shelf!`);
                return;
            }
            
            // Add to shelf
            appData.games.push({
                id: gameId,
                addedAt: new Date().toISOString(),
                source: 'recommendation'
            });
            
            saveData();
            SoundManager.play('reward');
            showToast(`${game.icon} ${game.name} added to your shelf!`, 'success');
            
            // Re-render
            renderRecommendations();
            renderShelfGames();
            renderBrowseCategories();
            renderHomeGames();
            
            // Track for achievements
            logActivity('game-added', { gameId, source: 'recommendation' });
        }
        
        function refreshRecommendations() {
            // v1.3.0: Regenerate recommendations with new random factors
            renderRecommendations();
            SoundManager.play('click');
            showToast('âœ¨ Recommendations refreshed!');
        }
        
        function shouldShowActivitySummary() {
            // Check if feature is enabled
            if (appData.settings?.showActivitySummary === false) return false;
            
            // Check if summary was shown today already
            const lastShown = appData.lastSummaryShown || 0;
            const oneDayMs = 24 * 60 * 60 * 1000;
            if (Date.now() - lastShown < oneDayMs) return false;
            
            // Check if there's anything to show
            const lastVisit = appData.lastVisit || Date.now();
            const hoursSinceVisit = (Date.now() - lastVisit) / (60 * 60 * 1000);
            
            // Only show if away for at least 4 hours and have some activity
            if (hoursSinceVisit < 4) return false;
            
            return true;
        }
        
        function showActivitySummary() {
            if (!shouldShowActivitySummary()) {
                // Still update last visit
                appData.lastVisit = Date.now();
                saveData();
                return;
            }
            
            const summary = generateActivitySummary();
            
            // Build modal content
            let content = '';
            
            // Header with time away
            if (summary.daysSinceVisit > 0) {
                content += `<div class="summary-header">You were away ${summary.daysSinceVisit} day${summary.daysSinceVisit > 1 ? 's' : ''}</div>`;
            } else {
                content += `<div class="summary-header">Here's what's new</div>`;
            }
            
            // Quick stats
            if (summary.gamesLogged > 0) {
                content += `
                    <div class="summary-section">
                        <div class="summary-section-title">ðŸ“Š Quick Stats</div>
                        <div class="summary-stats">
                            <div class="summary-stat">
                                <div class="summary-stat-value">${summary.gamesLogged}</div>
                                <div class="summary-stat-label">Games</div>
                            </div>
                            <div class="summary-stat">
                                <div class="summary-stat-value">${summary.totalPoints}</div>
                                <div class="summary-stat-label">Points</div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Highlights (perfects, achievements, milestones)
            const highlights = [
                ...summary.perfectGames.map(p => ({ icon: p.icon, text: `Perfect ${p.name}! ${p.score}` })),
                ...summary.newAchievements.map(a => ({ icon: 'ðŸ†', text: `New achievement: ${a.name}` })),
                ...summary.streakMilestones.map(s => ({ icon: 'ðŸ”¥', text: `${s.streak}-day ${s.gameName} streak!` }))
            ];
            
            if (highlights.length > 0) {
                content += `
                    <div class="summary-section">
                        <div class="summary-section-title">â­ Highlights</div>
                        <div class="summary-list">
                            ${highlights.slice(0, 5).map(h => `
                                <div class="summary-list-item">
                                    <span class="summary-item-icon">${h.icon}</span>
                                    <span>${h.text}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }
            
            // Battle updates
            if (summary.battleUpdates.length > 0) {
                content += `
                    <div class="summary-section">
                        <div class="summary-section-title">âš”ï¸ Battles</div>
                        <div class="summary-list">
                            ${summary.battleUpdates.slice(0, 3).map(b => {
                                let text = '';
                                if (b.type === 'battle-won') text = `You won "${b.name}"! ðŸ†`;
                                else if (b.type === 'battle-joined') text = `Joined "${b.name}"`;
                                else if (b.type === 'battle-created') text = `Created "${b.name}"`;
                                else if (b.type === 'battle-invite') text = `New invite from ${b.from}`;
                                return `<div class="summary-list-item"><span class="summary-item-icon">âš”ï¸</span><span>${text}</span></div>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }
            
            // Suggestions
            if (summary.suggestions.length > 0) {
                content += `
                    <div class="summary-section">
                        <div class="summary-section-title">ðŸ’¡ Suggestions</div>
                        <div class="summary-list">
                            ${summary.suggestions.map(s => `
                                <div class="summary-list-item suggestion">
                                    <span class="summary-item-icon">${s.icon}</span>
                                    <span>${s.text}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }
            
            // If nothing to show, don't show modal
            if (!content || (summary.gamesLogged === 0 && highlights.length === 0 && summary.battleUpdates.length === 0 && summary.suggestions.length === 0)) {
                appData.lastVisit = Date.now();
                saveData();
                return;
            }
            
            // Show modal
            document.getElementById('activity-summary-content').innerHTML = content;
            document.getElementById('activity-summary-sheet').classList.add('active');
            
            // Update timestamps
            appData.lastSummaryShown = Date.now();
            appData.lastVisit = Date.now();
            saveData();
        }
        
        function closeActivitySummary() {
            document.getElementById('activity-summary-sheet').classList.remove('active');
        }
        
        function getTodayString() {
            // v1.2.72: Use local time, not UTC (fixes timezone bug where late-night plays recorded as next day)
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        
        // v1.3.0: Helper to convert any Date to local YYYY-MM-DD string
        // Use this instead of toISOString().split('T')[0] which returns UTC
        function getLocalDateString(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        
        function getTodayHistory() {
            const today = getTodayString();
            return appData.history[today] || {};
        }
        
        function getGamesPlayedToday() {
            return Object.keys(getTodayHistory()).length;
        }
        
        // ============ PARSE SHARE TEXT ============
        function parseShareText(text) {
            if (!text || typeof text !== 'string') return null;
            
            for (const parser of PARSERS) {
                const match = text.match(parser.regex);
                if (match) {
                    try {
                        return parser.extract(match, text);
                    } catch (e) {
                        console.error('Parse error:', e);
                    }
                }
            }
            return null;
        }
        
        // Parse multiple games from bulk text (e.g., multiple share texts pasted together)
        function parseMultipleGames(text) {
            if (!text || typeof text !== 'string') return [];
            
            const results = [];
            const foundIds = new Set();
            
            // Try each parser
            for (const parser of PARSERS) {
                if (foundIds.has(parser.id)) continue;
                
                const match = text.match(parser.regex);
                if (match) {
                    try {
                        const result = parser.extract(match, text);
                        if (result && !foundIds.has(result.gameId)) {
                            results.push(result);
                            foundIds.add(result.gameId);
                        }
                    } catch (e) {
                        console.error('Parse error:', e);
                    }
                }
            }
            
            return results;
        }
        
        // Quick-log: Log a game with a specific score without share text
        function quickLogGame(gameId, score, won = true) {
            const game = GAMES[gameId];
            if (!game) return false;
            
            const todayHistory = getTodayHistory();
            if (todayHistory[gameId]) {
                showToast(`${game.name} already logged today!`);
                return false;
            }
            
            // Calculate numeric score based on game type
            let numericScore = 15; // Default
            if (gameId === 'wordle' && score.includes('/6')) {
                const guesses = score.split('/')[0];
                numericScore = guesses === 'X' ? 0 : (7 - parseInt(guesses)) * 5;
            } else if (gameId === 'connections') {
                numericScore = score === 'Perfect! ðŸŽ¯' ? 35 : (score === 'Solved!' ? 25 : 10);
            } else if (gameId === 'strands') {
                const hintMatch = score.match(/(\d+)\s*hint/);
                numericScore = hintMatch ? Math.max(20 - parseInt(hintMatch[1]) * 4, 5) : 30;
            } else if (gameId === 'mini') {
                const timeMatch = score.match(/(\d+):(\d+)/);
                if (timeMatch) {
                    const secs = parseInt(timeMatch[1]) * 60 + parseInt(timeMatch[2]);
                    numericScore = Math.max(35 - Math.floor(secs / 10), 5);
                }
            }
            
            const result = {
                gameId,
                score,
                won,
                numericScore
            };
            
            if (logGame(result, 'quick-log')) {
                renderAll();
                showSuccessModal(game, result);
                return true;
            }
            return false;
        }
        
        // Get unplayed NYT games for quick-log (with score options)
        function getUnplayedNYTGames() {
            const nytGames = ['wordle', 'connections', 'strands', 'mini', 'spelling-bee', 'letterboxed'];
            const todayHistory = getTodayHistory();
            const userGames = appData.games.map(g => g.id);
            
            return nytGames.filter(id => 
                userGames.includes(id) && !todayHistory[id]
            );
        }
        
        // Get all unplayed shelf games (excluding NYT which have special handling)
        function getUnplayedOtherGames() {
            const nytGames = ['wordle', 'connections', 'strands', 'mini', 'spelling-bee', 'letterboxed'];
            const todayHistory = getTodayHistory();
            
            return appData.games.filter(g => 
                !nytGames.includes(g.id) && !todayHistory[g.id]
            ).map(g => g.id);
        }
        
        // Render quick-log buttons
        function renderQuickLogButtons() {
            const container = document.getElementById('quick-log-buttons');
            if (!container) return;
            
            const unplayedNYT = getUnplayedNYTGames();
            const unplayedOther = getUnplayedOtherGames();
            
            if (unplayedNYT.length === 0 && unplayedOther.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 10px;">All games logged! ðŸŽ‰</div>';
                return;
            }
            
            let html = '';
            
            // NYT games with score options
            if (unplayedNYT.length > 0) {
                html += unplayedNYT.map(gameId => {
                    const game = GAMES[gameId];
                    return `
                        <button class="quick-log-game-btn" data-game="${gameId}" onclick="showQuickLogOptions('${gameId}')">
                            <span class="quick-log-icon">${game?.icon || 'ðŸŽ®'}</span>
                            <span class="quick-log-name">${game?.name || gameId}</span>
                        </button>
                    `;
                }).join('');
            }
            
            // Other games with simple log button
            if (unplayedOther.length > 0) {
                if (unplayedNYT.length > 0) {
                    html += '<div style="width: 100%; border-top: 1px solid var(--border); margin: 12px 0 8px; padding-top: 12px;"><div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 8px;">Other Games</div></div>';
                }
                
                html += unplayedOther.map(gameId => {
                    const game = GAMES[gameId];
                    return `
                        <button class="quick-log-game-btn" data-game="${gameId}" onclick="quickLogGeneric('${gameId}')">
                            <span class="quick-log-icon">${game?.icon || 'ðŸŽ®'}</span>
                            <span class="quick-log-name">${game?.name || gameId}</span>
                            <span style="color: var(--accent-green); font-size: 0.7rem;">Tap to log</span>
                        </button>
                    `;
                }).join('');
            }
            
            container.innerHTML = html;
        }
        
        // Quick log for generic games (not NYT)
        // v1.2.7.6: Show confirmation instead of instant log
        function quickLogGeneric(gameId) {
            const game = GAMES[gameId];
            if (!game) return;
            
            // Show confirmation in the options area
            const container = document.getElementById('quick-log-options');
            if (!container) return;
            
            container.innerHTML = `
                <div class="quick-log-options-title">${game.icon} ${game.name}</div>
                <div style="color: var(--text-muted); font-size: 0.85rem; margin-bottom: 12px;">
                    Log as played today?
                </div>
                <div class="quick-log-scores">
                    <button class="quick-score-btn" style="flex: 1; background: var(--accent-green);" onclick="confirmQuickLogGeneric('${gameId}', true)">âœ“ Won</button>
                    <button class="quick-score-btn fail" style="flex: 1;" onclick="confirmQuickLogGeneric('${gameId}', false)">âœ— Lost</button>
                </div>
                <button onclick="document.getElementById('quick-log-options').style.display='none'" 
                    style="margin-top: 10px; padding: 8px; background: transparent; border: 1px solid var(--border); border-radius: 6px; color: var(--text-muted); width: 100%; cursor: pointer;">
                    Cancel
                </button>
            `;
            container.style.display = 'block';
        }
        
        function confirmQuickLogGeneric(gameId, won) {
            const game = GAMES[gameId];
            if (!game) return;
            
            const result = {
                gameId: gameId,
                score: won ? 'âœ“' : 'âœ—',
                won: won,
                raw: 'Quick log'
            };
            
            if (logGame(result, 'quick-log')) {
                SoundManager.play('success');
                showToast(`${game.icon} ${game.name} logged!`, 'success');
                closeLogSheet();
            }
        }
        
        // Show score options for quick-log
        function showQuickLogOptions(gameId) {
            const game = GAMES[gameId];
            const container = document.getElementById('quick-log-options');
            if (!container) return;
            
            let optionsHTML = '';
            
            switch(gameId) {
                case 'wordle':
                    optionsHTML = `
                        <div class="quick-log-options-title">${game.icon} ${game.name}</div>
                        <div class="quick-log-scores">
                            ${[1,2,3,4,5,6].map(n => `
                                <button class="quick-score-btn ${n <= 2 ? 'perfect' : ''}" onclick="quickLogGame('wordle', '${n}/6', true)">${n}/6</button>
                            `).join('')}
                            <button class="quick-score-btn fail" onclick="quickLogGame('wordle', 'X/6', false)">X/6</button>
                        </div>
                    `;
                    break;
                case 'connections':
                    optionsHTML = `
                        <div class="quick-log-options-title">${game.icon} ${game.name}</div>
                        <div class="quick-log-scores">
                            <button class="quick-score-btn perfect" onclick="quickLogGame('connections', 'Perfect! ðŸŽ¯', true)">Perfect ðŸŽ¯</button>
                            <button class="quick-score-btn" onclick="quickLogGame('connections', 'Solved!', true)">Solved</button>
                            <button class="quick-score-btn fail" onclick="quickLogGame('connections', 'Failed', false)">Failed</button>
                        </div>
                    `;
                    break;
                case 'strands':
                    optionsHTML = `
                        <div class="quick-log-options-title">${game.icon} ${game.name}</div>
                        <div class="quick-log-scores">
                            <button class="quick-score-btn perfect" onclick="quickLogGame('strands', 'Perfect! ðŸŽ¯', true)">No hints ðŸŽ¯</button>
                            <button class="quick-score-btn" onclick="quickLogGame('strands', '1 hint', true)">1 hint</button>
                            <button class="quick-score-btn" onclick="quickLogGame('strands', '2 hints', true)">2 hints</button>
                            <button class="quick-score-btn" onclick="quickLogGame('strands', '3+ hints', true)">3+ hints</button>
                        </div>
                    `;
                    break;
                case 'mini':
                    optionsHTML = `
                        <div class="quick-log-options-title">${game.icon} ${game.name}</div>
                        <div class="quick-log-time-input">
                            <input type="text" id="mini-time-input" placeholder="0:00" pattern="[0-9]+:[0-5][0-9]" maxlength="5" 
                                   style="width: 80px; text-align: center; font-size: 1.2rem; padding: 10px; border-radius: 8px; border: 1px solid var(--border); background: var(--bg-tertiary); color: var(--text-primary);">
                            <button class="quick-score-btn" onclick="submitMiniTime()" style="margin-left: 10px;">Log</button>
                        </div>
                        <div class="quick-log-presets" style="margin-top: 10px;">
                            <button class="quick-score-btn perfect" onclick="quickLogGame('mini', '0:30', true)">:30 âš¡</button>
                            <button class="quick-score-btn" onclick="quickLogGame('mini', '1:00', true)">1:00</button>
                            <button class="quick-score-btn" onclick="quickLogGame('mini', '2:00', true)">2:00</button>
                        </div>
                    `;
                    break;
                case 'spelling-bee':
                    optionsHTML = `
                        <div class="quick-log-options-title">${game.icon} ${game.name}</div>
                        <div class="quick-log-scores">
                            <button class="quick-score-btn perfect" onclick="quickLogGame('spelling-bee', 'Queen Bee! ðŸ‘‘', true)">Queen ðŸ‘‘</button>
                            <button class="quick-score-btn perfect" onclick="quickLogGame('spelling-bee', 'Genius!', true)">Genius</button>
                            <button class="quick-score-btn" onclick="quickLogGame('spelling-bee', 'Amazing!', true)">Amazing</button>
                            <button class="quick-score-btn" onclick="quickLogGame('spelling-bee', 'Great!', true)">Great</button>
                            <button class="quick-score-btn" onclick="quickLogGame('spelling-bee', 'Played', true)">Played</button>
                        </div>
                    `;
                    break;
                case 'letterboxed':
                    optionsHTML = `
                        <div class="quick-log-options-title">${game.icon} ${game.name}</div>
                        <div class="quick-log-scores">
                            <button class="quick-score-btn perfect" onclick="quickLogGame('letterboxed', '2 words! ðŸŽ¯', true)">2 words ðŸŽ¯</button>
                            <button class="quick-score-btn" onclick="quickLogGame('letterboxed', '3 words', true)">3 words</button>
                            <button class="quick-score-btn" onclick="quickLogGame('letterboxed', '4 words', true)">4 words</button>
                            <button class="quick-score-btn" onclick="quickLogGame('letterboxed', '5+ words', true)">5+ words</button>
                        </div>
                    `;
                    break;
            }
            
            container.innerHTML = optionsHTML;
            container.style.display = 'block';
            
            // Close log sheet when done
            document.querySelectorAll('.quick-score-btn').forEach(btn => {
                const originalClick = btn.onclick;
                btn.onclick = function(e) {
                    if (originalClick) originalClick.call(this, e);
                    setTimeout(() => closeLogSheet({ target: { id: 'log-sheet' } }), 100);
                };
            });
        }
        
        function submitMiniTime() {
            const input = document.getElementById('mini-time-input');
            if (!input) return;
            
            let time = input.value.trim();
            // Handle formats: "30" -> "0:30", "1:30" stays "1:30"
            if (!time.includes(':')) {
                time = `0:${time.padStart(2, '0')}`;
            }
            
            if (!/^\d+:\d{2}$/.test(time)) {
                showToast('Enter time as M:SS', 'error');
                return;
            }
            
            quickLogGame('mini', time, true);
            closeLogSheet({ target: { id: 'log-sheet' } });
        }
        
        // Bulk import: log multiple games at once
        function bulkImport() {
            const input = document.getElementById('log-input').value;
            const results = parseMultipleGames(input);
            
            if (results.length === 0) {
                showToast('No games detected. Try pasting share text.', 'error');
                return;
            }
            
            const todayHistory = getTodayHistory();
            let logged = 0;
            let skipped = 0;
            
            for (const result of results) {
                if (todayHistory[result.gameId]) {
                    skipped++;
                    continue;
                }
                if (logGame(result, 'paste')) {
                    logged++;
                }
            }
            
            closeLogSheet({ target: { id: 'log-sheet' } });
            renderAll();
            
            if (logged > 0) {
                showToast(`âœ… Logged ${logged} game${logged > 1 ? 's' : ''}${skipped > 0 ? ` (${skipped} already done)` : ''}`);
            } else if (skipped > 0) {
                showToast(`All ${skipped} game${skipped > 1 ? 's' : ''} already logged today`);
            }
        }
        
        // ============ LOG GAME ============
        function logGame(result, logMethod = 'unknown') {
            if (!result || !result.gameId) return false;
            
            const today = getTodayString();
            const gameInfo = GAMES[result.gameId];
            
            // Track detection failures - did we miss auto-detecting this?
            trackGameLog(result, logMethod);
            
            // Clear active game state if this was the game being tracked
            // This clears both memory and localStorage
            if (typeof lastLaunchedGame !== 'undefined' && lastLaunchedGame === result.gameId) {
                clearActiveGame();
            }
            
            // Also dismiss return prompt if visible for this game
            dismissReturnPromptIfShowing(result.gameId);
            
            // Update history
            if (!appData.history[today]) {
                appData.history[today] = {};
            }
            appData.history[today][result.gameId] = {
                score: result.score,
                won: result.won,
                numericScore: result.numericScore || 0,
                time: new Date().toISOString(),
                grid: result.grid || null,  // Save the emoji grid for sharing
                shareText: result.shareText || null  // Save original share text if available
            };
            
            // Update stats
            if (!appData.stats[result.gameId]) {
                appData.stats[result.gameId] = {
                    gamesPlayed: 0,
                    gamesWon: 0,
                    currentStreak: 0,
                    maxStreak: 0,
                    lastPlayed: null
                };
            }
            
            const stats = appData.stats[result.gameId];
            const oldStreak = stats.currentStreak;
            const oldLastPlayed = stats.lastPlayed;  // v1.3.0: Save BEFORE updating
            stats.gamesPlayed++;
            if (result.won) stats.gamesWon++;
            
            // v1.3.0: Streak calculation - fixed order bug where lastPlayed was updated before check
            // Also fixed timezone: use local time for yesterday (was using UTC)
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const yesterdayStr = `${yesterday.getFullYear()}-${String(yesterday.getMonth() + 1).padStart(2, '0')}-${String(yesterday.getDate()).padStart(2, '0')}`;
            
            if (oldLastPlayed === yesterdayStr) {
                // Played yesterday - continue streak
                stats.currentStreak++;
            } else if (oldLastPlayed === today) {
                // Already played today - don't change streak
            } else {
                // First play ever, or missed day(s) - start/reset streak to 1
                stats.currentStreak = 1;
            }
            
            if (stats.currentStreak > stats.maxStreak) {
                stats.maxStreak = stats.currentStreak;
            }
            
            stats.lastPlayed = today;  // v1.3.0: Update AFTER calculation
            
            // Log activity
            logActivity('game-logged', {
                gameId: result.gameId,
                gameName: gameInfo?.name || result.gameId,
                icon: gameInfo?.icon || 'ðŸŽ®',
                score: result.score,
                won: result.won,
                points: result.numericScore || 0,
                isPerfect: result.score?.includes('ðŸŽ¯') || result.meta?.perfect
            });
            
            // Check for streak milestones and show celebration
            const milestones = [7, 14, 30, 50, 100, 200, 365];
            if (milestones.includes(stats.currentStreak) && stats.currentStreak > oldStreak) {
                logActivity('streak-milestone', {
                    gameId: result.gameId,
                    gameName: gameInfo?.name || result.gameId,
                    streak: stats.currentStreak
                });
                
                // Show milestone celebration (after a short delay to let success modal show first)
                setTimeout(() => {
                    checkStreakMilestone(result.gameId, stats.currentStreak, oldStreak);
                }, 500);
            }
            
            // Award tokens
            const isFirstToday = getGamesPlayedToday() === 1;
            if (isFirstToday) {
                appData.wallet.tokens += 10;
            } else {
                appData.wallet.tokens += 5;
            }
            
            // Check achievements
            checkTimeAchievements();
            checkAndUnlockAchievements();
            
            // Check engagement rewards (tokens)
            checkFiveDayStreakReward();
            checkAllGsGamesReward();
            
            // Update battle scores if in active battle (pass full result for win/perfect tracking)
            updateBattleScore(result.gameId, result.numericScore || 1, result);
            
            saveData();
            syncToCloud();
            publishPublicProfile(); // Update public profile for friends
            return true;
        }
        
        // ============ CLOUD SYNC ============
        // v1.3.0: Track consecutive sync failures for user feedback
        let syncFailureCount = 0;
        
        async function syncToCloud() {
            if (!currentUser) return;
            
            try {
                await db.ref(`users/${currentUser.uid}/shelf`).set(appData);
                console.log('Synced to cloud');
                syncFailureCount = 0; // Reset on success
            } catch (e) {
                console.error('Sync error:', e);
                syncFailureCount++;
                
                // v1.3.0: Show subtle feedback after repeated failures
                if (syncFailureCount === 3) {
                    showToast('âš ï¸ Sync issue - your data is saved locally', 'warning');
                }
            }
        }
        
        async function loadFromCloud() {
            if (!currentUser) return;
            
            try {
                const snapshot = await db.ref(`users/${currentUser.uid}/shelf`).once('value');
                const cloudData = snapshot.val();
                
                if (cloudData) {
                    console.log('[SYNC] Merging cloud data with local...');
                    
                    // Deep merge history (date by date, game by game)
                    // Local data preserved, cloud wins for same date+game conflicts
                    if (cloudData.history) {
                        if (!appData.history) appData.history = {};
                        Object.entries(cloudData.history).forEach(([date, games]) => {
                            if (!appData.history[date]) {
                                appData.history[date] = games;
                            } else {
                                // Merge games for this date - cloud wins conflicts
                                appData.history[date] = { ...appData.history[date], ...games };
                            }
                        });
                    }
                    
                    // Deep merge stats (game by game)
                    // Local preserved, cloud wins for same game conflicts
                    if (cloudData.stats) {
                        if (!appData.stats) appData.stats = {};
                        Object.entries(cloudData.stats).forEach(([gameId, stats]) => {
                            // Cloud wins but preserve local if not in cloud
                            appData.stats[gameId] = { ...(appData.stats[gameId] || {}), ...stats };
                        });
                    }
                    
                    // Merge myShelf (union of arrays)
                    if (cloudData.myShelf && Array.isArray(cloudData.myShelf)) {
                        if (!appData.myShelf) appData.myShelf = [];
                        const combined = new Set([...appData.myShelf, ...cloudData.myShelf]);
                        appData.myShelf = Array.from(combined);
                    }
                    
                    // Merge achievements (union)
                    if (cloudData.achievements) {
                        appData.achievements = { ...(appData.achievements || {}), ...cloudData.achievements };
                    }
                    
                    // Merge settings (cloud wins)
                    if (cloudData.settings) {
                        appData.settings = { ...(appData.settings || {}), ...cloudData.settings };
                    }
                    
                    // Merge launchPrefs (cloud wins)
                    if (cloudData.launchPrefs) {
                        appData.launchPrefs = { ...(appData.launchPrefs || {}), ...cloudData.launchPrefs };
                    }
                    
                    // Copy other fields from cloud if not already set locally
                    ['dailyGoal', 'friendCode', 'displayName', 'photoURL', 'friends'].forEach(key => {
                        if (cloudData[key] !== undefined && appData[key] === undefined) {
                            appData[key] = cloudData[key];
                        }
                    });
                    
                    // CRITICAL: Merge wallet from cloud (cloud wins for coins since server adds them)
                    if (cloudData.wallet) {
                        if (!appData.wallet) appData.wallet = { tokens: 0, coins: 0 };
                        // Cloud wins for coins (purchases happen server-side)
                        appData.wallet.coins = cloudData.wallet.coins || 0;
                        // For tokens, take the higher value (could be earned locally or from cloud)
                        appData.wallet.tokens = Math.max(appData.wallet.tokens || 0, cloudData.wallet.tokens || 0);
                        console.log('[SYNC] Wallet synced from cloud:', appData.wallet);
                    }
                    
                    console.log('[SYNC] Merge complete. Saving...');
                    saveData();
                    
                    // Push merged data back to cloud to ensure consistency
                    saveToCloud();
                } else {
                    console.log('[SYNC] No cloud data found - pushing local to cloud');
                    // No cloud data - push local data to cloud
                    saveToCloud();
                }
            } catch (e) {
                console.error('Load from cloud error:', e);
            }
        }
        
        // ============ GAME SHELF GAMES SYNC ============
        // Sync results from Game Shelf games (Quotle, Slate, Rungs, Word Boxing)
        const GAMESHELF_GAME_IDS = ['quotle', 'slate', 'rungs', 'wordboxing'];
        
        function syncGameShelfGames() {
            const today = getTodayString();
            const todayHistory = appData.history[today] || {};
            let synced = 0;
            
            GAMESHELF_GAME_IDS.forEach(gameId => {
                // Skip if already logged today
                if (todayHistory[gameId]) return;
                
                // Check for result from the game
                try {
                    const latestKey = `gameshelf_${gameId}_latest`;
                    const stored = localStorage.getItem(latestKey);
                    if (!stored) return;
                    
                    const payload = JSON.parse(stored);
                    
                    // Check if it's from today
                    if (payload.date !== today && payload.puzzleId !== today) return;
                    
                    // Import the result
                    const result = {
                        gameId: gameId,
                        score: payload.scoreLine || payload.result?.score || 'Done',
                        won: payload.result?.won ?? true,
                        numericScore: calculateNumericScore(gameId, payload)
                    };
                    
                    // Log it (this updates history, stats, achievements)
                    logGame(result, 'auto-sync');
                    synced++;
                    console.log(`ðŸŽ® Synced ${gameId} result from Game Shelf`);
                    
                } catch (e) {
                    console.error(`Error syncing ${gameId}:`, e);
                }
            });
            
            if (synced > 0) {
                renderHome();
                showToast(`Synced ${synced} game${synced > 1 ? 's' : ''} from Game Shelf`);
            }
            
            return synced;
        }
        
        function calculateNumericScore(gameId, payload) {
            const result = payload.result || {};
            
            switch (gameId) {
                case 'quotle':
                    if (!result.won) return 0;
                    if (result.perfect) return 40;
                    return Math.max(5, (5 - (result.attempts || 4)) * 10);
                    
                case 'slate':
                    if (!result.won) return 0;
                    // Lower score is better in Slate
                    const score = result.score ?? 50;
                    return Math.max(5, 30 - Math.floor(score / 2));
                    
                case 'rungs':
                    if (!result.won) return 0;
                    return 20; // Base score for completion
                    
                case 'wordboxing':
                    return result.won ? 25 : 10;
                    
                default:
                    return result.won ? 15 : 5;
            }
        }
        
        // Sync when app becomes visible (user returns from playing a game)
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                // Small delay to let localStorage settle
                setTimeout(syncGameShelfGames, 500);
            }
        });
        
        // Also listen for focus events (PWA specific)
        window.addEventListener('focus', () => {
            setTimeout(syncGameShelfGames, 500);
        });
        
        // ============ AUTH ============
        // Track if this is the initial auth state (page load) vs actual sign-in
        let isInitialAuthCheck = true;
        
        auth.onAuthStateChanged(async (user) => {
            console.log('[AUTH] onAuthStateChanged:', user ? user.email : 'null');
            currentUser = user;
            updateAuthUI();
            
            // Clear return prompt state on auth changes to prevent spurious prompts
            if (typeof lastLaunchedGame !== 'undefined' && lastLaunchedGame) {
                clearActiveGame();
            }
            
            if (user) {
                // Only show toast for actual sign-ins, not page load restoration
                if (!isInitialAuthCheck) {
                    showToast('Signed in: ' + user.email);
                }
                
                await loadFromCloud();
                loadUserBattles();
                
                // Load friends data
                await loadFriendsData();
                
                // Check for received nudges
                checkReceivedNudges();
                
                // Publish public profile
                publishPublicProfile();
                
                // Publish contact hashes for friend discovery
                publishContactHashes();
                
                // Check for pending friend request
                checkPendingFriend();
                
                // Process referral signup (if they came from a referral link)
                processReferralSignup();
                
                // Check for pending referral rewards
                checkPendingReferralRewards();
                
                // Sync any locally stored issues to Firebase
                syncPendingIssues();
                
                // Unlock cloud sync achievement
                if (!appData.achievements) appData.achievements = {};
                if (!appData.achievements['cloud-sync']) {
                    unlockAchievement('cloud-sync');
                }
            }
            
            isInitialAuthCheck = false;
            renderAll();
        });
        
        // Handle redirect result (for PWA standalone mode)
        auth.getRedirectResult().then(async result => {
            console.log('[AUTH] getRedirectResult:', result?.user?.email || 'no user');
            
            if (result && result.user) {
                console.log('[AUTH] Redirect sign-in successful');
                currentUser = result.user;
                updateAuthUI();
                showToast('Welcome ' + (result.user.displayName || result.user.email));
                await loadFromCloud();
                loadUserBattles();
                await loadFriendsData();
                checkReceivedNudges();
                publishPublicProfile();
                publishContactHashes();
                checkPendingFriend();
                renderAll();
            }
            // No alert if no user - that's normal on regular page load
        }).catch(e => {
            console.log('[AUTH] getRedirectResult error:', e.code);
            
            // Only show alert for real errors, not expected ones
            if (e.code !== 'auth/no-auth-event') {
                if (isStandalone()) {
                    alert('Auth Error:\n' + e.code + '\n' + e.message);
                }
                showToast('Auth error: ' + e.code, 'error');
            }
        });
        
        function signInWithGoogle() {
            const provider = new firebase.auth.GoogleAuthProvider();
            
            // Always try popup first - it works better for session persistence
            // Even in standalone PWA, popup sometimes works on newer iOS
            console.log('[AUTH] Attempting signInWithPopup...');
            
            auth.signInWithPopup(provider).then(result => {
                console.log('[AUTH] Popup success:', result.user.email);
                showToast('Welcome ' + (result.user.displayName || result.user.email));
            }).catch(e => {
                console.log('[AUTH] Popup failed:', e.code);
                
                // If popup blocked/closed, try redirect as fallback
                if (e.code === 'auth/popup-blocked' || 
                    e.code === 'auth/popup-closed-by-user' ||
                    e.code === 'auth/cancelled-popup-request') {
                    console.log('[AUTH] Falling back to redirect...');
                    showToast('Opening Google sign-in...');
                    auth.signInWithRedirect(provider);
                } else {
                    showToast('Sign in failed: ' + e.code, 'error');
                }
            });
        }
        
        function signOut() {
            auth.signOut();
            closeAccountModal();
            showToast('Signed out');
        }
        
        function updateAuthUI() {
            const authMenuText = document.getElementById('auth-menu-text');
            const menuAccountSection = document.getElementById('menu-account-section');
            
            if (currentUser) {
                if (authMenuText) authMenuText.textContent = 'Sign Out (' + (currentUser.displayName || currentUser.email || 'User') + ')';
                if (menuAccountSection) {
                    menuAccountSection.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 12px; padding: 12px 0;">
                            <div style="width: 40px; height: 40px; border-radius: 50%; background: linear-gradient(135deg, #667eea, #764ba2); display: flex; align-items: center; justify-content: center; font-weight: 600;">
                                ${escapeHtml((currentUser.displayName || currentUser.email || '?')[0].toUpperCase())}
                            </div>
                            <div style="flex: 1;">
                                <div style="font-weight: 600;">${escapeHtml(currentUser.displayName || 'User')}</div>
                                <div style="font-size: 0.8rem; color: var(--text-muted);">${escapeHtml(currentUser.email || '')}</div>
                            </div>
                        </div>
                        <a class="settings-link" onclick="signOut()" style="color: var(--accent-red);">
                            <span class="icon">ðŸšª</span>
                            Sign Out
                        </a>
                    `;
                }
            } else {
                if (authMenuText) authMenuText.textContent = 'Sign in with Google';
                if (menuAccountSection) {
                    menuAccountSection.innerHTML = `
                        <a class="settings-link" onclick="signInWithGoogle()">
                            <span class="icon">ðŸ”</span>
                            <span>Sign in with Google</span>
                        </a>
                        <p class="settings-desc">Save progress across devices</p>
                    `;
                }
            }
        }
        
        // ============ SETTINGS MENU ============
        function toggleSettingsMenu() {
            const menu = document.getElementById('settings-menu');
            const overlay = document.getElementById('settings-overlay');
            const isOpening = !menu.classList.contains('active');
            
            // Refresh auth UI every time menu is opened
            if (isOpening) {
                // Check current Firebase auth state directly
                const user = auth.currentUser;
                if (user !== currentUser) {
                    console.log('Auth state mismatch, syncing. Firebase:', user?.email, 'Local:', currentUser?.email);
                    currentUser = user;
                }
                updateAuthUI();
            }
            
            menu.classList.toggle('active');
            overlay.classList.toggle('active');
        }
        
        function toggleSettingsSubmenu() {
            const toggle = document.getElementById('settings-submenu-toggle');
            const content = document.getElementById('settings-submenu-content');
            toggle.classList.toggle('expanded');
            content.classList.toggle('expanded');
        }
        
        function handleAuthAction() {
            if (currentUser) {
                signOut();
            } else {
                signInWithGoogle();
            }
        }
        
        function setTheme(theme) {
            document.body.classList.remove('light-mode', 'dark-mode');
            if (theme === 'light') {
                document.body.classList.add('light-mode');
            }
            document.getElementById('theme-dark').classList.toggle('active', theme === 'dark');
            document.getElementById('theme-light').classList.toggle('active', theme === 'light');
            appData.settings.theme = theme;
            saveData();
        }
        
        function toggleSound(enabled) {
            SoundManager.setEnabled(enabled);
            appData.settings.soundEnabled = enabled;
            saveData();
            showToast(enabled ? 'ðŸ”” Sound enabled' : 'ðŸ”• Sound disabled');
            if (enabled) SoundManager.playSound('chime1');
        }
        
        function setVolume(value) {
            SoundManager.setVolume(value / 100);
        }
        
        function toggleActivitySummary(enabled) {
            if (!appData.settings) appData.settings = {};
            appData.settings.showActivitySummary = enabled;
            saveData();
            showToast(enabled ? 'ðŸ“Š Welcome summary enabled' : 'ðŸ“Š Welcome summary disabled');
        }
        
        // NEW: Toggle auto-log mode
        function toggleAutoLog(enabled) {
            if (!appData.settings) appData.settings = {};
            appData.settings.autoLog = enabled;
            saveData();
            showToast(enabled ? 'âš¡ Auto-log enabled - results logged automatically' : 'ðŸ“‹ Manual mode - confirm each log');
        }
        
        function toggleTestMode(enabled) {
            // Don't allow toggling when auto-enabled
            if (isTestModeAutoEnabled()) {
                showToast('ðŸ§ª Test Mode is auto-enabled on test builds', 'info');
                return;
            }
            localStorage.setItem('gameshelf_test_mode', enabled ? 'true' : 'false');
            showToast(enabled ? 'ðŸ§ª Test Mode ON - using test repos for GS Originals' : 'ðŸš€ Test Mode OFF - using production repos');
        }
        
        function initTestModeToggle() {
            const toggle = document.getElementById('test-mode-toggle');
            if (toggle) {
                toggle.checked = isTestModeEnabled();
                // v1.2.7.6: Disable toggle when auto-enabled from gameshelftest/
                if (isTestModeAutoEnabled()) {
                    toggle.disabled = true;
                    toggle.parentElement.style.opacity = '0.6';
                    toggle.parentElement.title = 'Test Mode auto-enabled on test builds';
                }
            }
            
            // Show indicator if on test Game Shelf
            if (isTestGameShelf()) {
                console.log('ðŸ§ª Running from TEST Game Shelf - test mode auto-enabled');
                
                // Show TEST badge
                const testBadge = document.getElementById('test-gameshelf-badge');
                if (testBadge) {
                    testBadge.style.display = 'block';
                }
                
                // Add [TEST] to header title
                const headerTitle = document.querySelector('.header-title');
                if (headerTitle && !headerTitle.innerHTML.includes('[TEST]')) {
                    headerTitle.innerHTML = headerTitle.innerHTML + ' <span style="color:#f90;font-size:0.6em;">[TEST]</span>';
                }
            }
        }
        
        // ============ FEEDBACK MODE SYSTEM ============
        let feedbackDebugLog = []; // Stores recent actions for debug reports
        const FEEDBACK_LOG_MAX = 50; // Max entries to keep
        
        // Debug logging is enabled when help button is visible (for better issue reports)
        function isFeedbackModeEnabled() {
            // Check new key first, fall back to old key
            const newSetting = localStorage.getItem('gameshelf_help_button');
            if (newSetting !== null) {
                return newSetting === 'true';
            }
            return localStorage.getItem('gameshelf_feedback_mode') === 'true';
        }
        
        function toggleHelpButton(enabled) {
            localStorage.setItem('gameshelf_help_button', enabled ? 'true' : 'false');
            
            // Update UI elements
            const helpBtn = document.getElementById('floating-help-btn');
            
            if (helpBtn) {
                helpBtn.classList.toggle('hidden', !enabled);
            }
            
            showToast(enabled ? 'â“ Help button visible' : 'â“ Help button hidden');
        }
        
        // Legacy alias for backwards compatibility
        function toggleFeedbackMode(enabled) {
            toggleHelpButton(enabled);
        }
        
        function isHelpButtonEnabled() {
            // Check new key first, fall back to old key for migration
            const newSetting = localStorage.getItem('gameshelf_help_button');
            if (newSetting !== null) {
                return newSetting === 'true';
            }
            // Migrate from old setting
            const oldSetting = localStorage.getItem('gameshelf_feedback_mode');
            return oldSetting === 'true';
        }
        
        function initHelpButton() {
            const toggle = document.getElementById('feedback-mode-toggle');
            const helpBtn = document.getElementById('floating-help-btn');
            const isEnabled = isHelpButtonEnabled();
            
            if (toggle) {
                toggle.checked = isEnabled;
            }
            if (helpBtn) {
                helpBtn.classList.toggle('hidden', !isEnabled);
            }
        }
        
        function feedbackLog(action) {
            if (!isFeedbackModeEnabled()) return;
            
            feedbackDebugLog.unshift({
                time: new Date().toISOString(),
                action: action,
                tab: document.querySelector('.nav-tab.active')?.dataset?.tab || 'unknown'
            });
            
            if (feedbackDebugLog.length > FEEDBACK_LOG_MAX) {
                feedbackDebugLog = feedbackDebugLog.slice(0, FEEDBACK_LOG_MAX);
            }
        }
        
        function captureDebugContext() {
            const now = new Date();
            const recentActivity = (appData.activityLog || []).slice(0, 5);
            
            const context = {
                // App state
                appVersion: document.querySelector('meta[name="version"]')?.content || 'unknown',
                currentTab: document.querySelector('.nav-tab.active')?.dataset?.tab || 'unknown',
                
                // User state
                gamesCount: (appData.games || []).length,
                walletTokens: appData.wallet?.tokens ?? 0,
                walletCoins: appData.wallet?.coins ?? 0,
                currentStreak: calculateStreak(),
                
                // Session info
                timestamp: now.toISOString(),
                sessionDuration: Math.round((now - new Date(appData.lastVisit || now)) / 1000 / 60) + ' mins',
                
                // Device info
                platform: getPlatformInfo(),
                screenSize: `${window.innerWidth}x${window.innerHeight}`,
                userAgent: navigator.userAgent.substring(0, 100),
                
                // Recent activity (last 5 items from app's activity log)
                recentActivity: recentActivity.map(a => ({
                    action: a.action,
                    time: new Date(a.ts).toLocaleTimeString()
                })),
                
                // Feedback debug log (actions captured this session)
                debugLog: feedbackDebugLog.slice(0, 10),
                
                // Console errors captured
                consoleErrors: feedbackDebugLog.filter(l => l.action.startsWith('ERROR:')).slice(0, 5)
            };
            
            return context;
        }
        
        function getPlatformInfo() {
            const ua = navigator.userAgent;
            if (/iPhone/.test(ua)) return 'iPhone';
            if (/iPad/.test(ua)) return 'iPad';
            if (/Android/.test(ua)) return /Mobile/.test(ua) ? 'Android' : 'Android Tablet';
            if (/Mac/.test(ua)) return 'Mac';
            if (/Windows/.test(ua)) return 'Windows';
            return 'Unknown';
        }
        
        function calculateStreak() {
            // v1.3.0: Use local time for history lookup, not UTC
            let streak = 0;
            let checkDate = new Date();
            while (true) {
                const dateStr = getLocalDateString(checkDate);
                const dayHistory = appData.history?.[dateStr];
                if (dayHistory && Object.keys(dayHistory).length > 0) {
                    streak++;
                    checkDate.setDate(checkDate.getDate() - 1);
                } else {
                    break;
                }
            }
            return streak;
        }
        
        function openFeedback() {
            // Log the feedback open action
            feedbackLog('Opened feedback form');
            
            // Show/populate the debug section
            const debugSection = document.getElementById('feedback-debug-section');
            const debugPreview = document.getElementById('debug-log-preview');
            
            if (isFeedbackModeEnabled() && debugSection && debugPreview) {
                debugSection.style.display = 'block';
                
                const context = captureDebugContext();
                let html = `
                    <div class="log-entry"><span class="log-time">ðŸ“±</span><span class="log-action">Tab: ${context.currentTab} | v${context.appVersion}</span></div>
                    <div class="log-entry"><span class="log-time">ðŸ’Ž</span><span class="log-action">${context.walletTokens} tokens | ðŸª™ ${context.walletCoins} coins | ðŸ”¥ ${context.currentStreak} streak</span></div>
                    <div class="log-entry"><span class="log-time">ðŸŽ®</span><span class="log-action">${context.gamesCount} games tracked</span></div>
                    <div class="log-entry"><span class="log-time">ðŸ“±</span><span class="log-action">${context.platform} | ${context.screenSize}</span></div>
                `;
                
                if (context.recentActivity.length > 0) {
                    html += '<div class="log-entry" style="margin-top: 8px; font-weight: bold;">Recent Activity:</div>';
                    context.recentActivity.forEach(a => {
                        html += `<div class="log-entry"><span class="log-time">${a.time}</span><span class="log-action">${a.action}</span></div>`;
                    });
                }
                
                if (context.consoleErrors.length > 0) {
                    html += '<div class="log-entry" style="margin-top: 8px; font-weight: bold; color: #ef4444;">Console Errors:</div>';
                    context.consoleErrors.forEach(e => {
                        html += `<div class="log-entry" style="color: #ef4444;"><span class="log-action">${e.action}</span></div>`;
                    });
                }
                
                debugPreview.innerHTML = html;
            }
            
            // Open the issue sheet
            reportIssue();
        }
        
        // ============ REFERRAL SYSTEM ============
        const REFERRAL_REWARDS = {
            sent: 10,        // Tier 1: Send referral email
            joined: 50,      // Tier 2: Friend creates Firebase account
            purchased: 100   // Tier 3: Friend buys first coin
        };
        
        // Use the utility function defined in URL UTILITIES section
        const REFERRAL_BASE_URL = getReferralBaseUrl();
        
        function generateReferralCode() {
            // Generate unique 8-char code based on user ID or random
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 8; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }
        
        function getReferralCode() {
            if (!appData.referral) {
                appData.referral = {
                    myCode: null,
                    referredBy: null,
                    invitesSent: 0,
                    friendsJoined: 0,
                    friendsEngaged: 0,
                    totalEarned: 0
                };
            }
            
            if (!appData.referral.myCode) {
                appData.referral.myCode = generateReferralCode();
                saveData();
                
                // Store in Firebase if signed in
                if (currentUser) {
                    db.ref(`referralCodes/${appData.referral.myCode}`).set({
                        ownerId: currentUser.uid,
                        ownerName: currentUser.displayName || 'Player',
                        created: Date.now(),
                        referees: {}
                    }).catch(e => console.error('Error saving referral code:', e));
                }
            }
            
            return appData.referral.myCode;
        }
        
        function getReferralLink() {
            const code = getReferralCode();
            return `${REFERRAL_BASE_URL}/#ref=${code}`;
        }
        
        function showReferralSheet() {
            // Update display values
            const referral = appData.referral || {};
            document.getElementById('referral-total-earned').textContent = referral.totalEarned || 0;
            document.getElementById('referral-invites-sent').textContent = referral.invitesSent || 0;
            document.getElementById('referral-friends-joined').textContent = referral.friendsJoined || 0;
            document.getElementById('referral-friends-engaged').textContent = referral.friendsEngaged || 0;
            document.getElementById('referral-link-display').textContent = getReferralLink();
            
            document.getElementById('referral-sheet').classList.add('active');
        }
        
        function closeReferralSheet() {
            document.getElementById('referral-sheet').classList.remove('active');
        }
        
        // Add friend by code from referral sheet
        async function addFriendFromReferralSheet() {
            const code = document.getElementById('referral-friend-code-input').value.trim().toUpperCase();
            const errorEl = document.getElementById('referral-friend-error');
            
            if (code.length !== 8) {
                errorEl.textContent = 'Enter an 8-character code';
                errorEl.style.display = 'block';
                return;
            }
            
            if (code === getReferralCode()) {
                errorEl.textContent = "That's your own code!";
                errorEl.style.display = 'block';
                return;
            }
            
            errorEl.style.display = 'none';
            showToast('ðŸ” Looking up friend...');
            
            try {
                // Look up by referral code
                const snapshot = await db.ref(`referralCodes/${code}`).once('value');
                const referralData = snapshot.val();
                
                if (!referralData) {
                    errorEl.textContent = 'Code not found. Check and try again.';
                    errorEl.style.display = 'block';
                    return;
                }
                
                const friendUid = referralData.ownerId;
                
                // Check if already friends
                const existingFriend = friendsData.find(f => f.odataId === friendUid);
                if (existingFriend) {
                    errorEl.textContent = 'Already connected!';
                    errorEl.style.display = 'block';
                    return;
                }
                
                // Get their profile
                const profileSnapshot = await db.ref('gameshelf-public/' + friendUid).once('value');
                const profileData = profileSnapshot.val() || { displayName: referralData.ownerName || 'Player' };
                
                // Close referral sheet and show confirmation
                closeReferralSheet();
                showFriendConfirm(friendUid, profileData);
                
            } catch (e) {
                console.error('Friend lookup error:', e);
                errorEl.textContent = 'Could not find friend. Try again.';
                errorEl.style.display = 'block';
            }
        }
        
        function copyReferralLink() {
            const link = getReferralLink();
            navigator.clipboard.writeText(link).then(() => {
                showToast('ðŸ“‹ Link copied!');
                trackInviteSent();
            }).catch(e => {
                showToast('Could not copy link', 'error');
            });
        }
        
        function shareReferral(platform) {
            const link = getReferralLink();
            const message = `Join me on Game Shelf! Track your daily puzzle games, compete in battles, and more. ${link}`;
            const encodedMessage = encodeURIComponent(message);
            const encodedLink = encodeURIComponent(link);
            
            let url;
            switch (platform) {
                case 'sms':
                    url = `sms:?body=${encodedMessage}`;
                    break;
                case 'email':
                    url = `mailto:?subject=${encodeURIComponent('Join me on Game Shelf!')}&body=${encodedMessage}`;
                    break;
                case 'twitter':
                    url = `https://twitter.com/intent/tweet?text=${encodedMessage}`;
                    break;
                case 'native':
                    if (navigator.share) {
                        navigator.share({
                            title: 'Join Game Shelf',
                            text: 'Track your daily puzzle games, compete in battles, and more!',
                            url: link
                        }).then(() => {
                            trackInviteSent();
                        }).catch(e => console.log('Share cancelled'));
                        return;
                    }
                    // Fallback to copy
                    copyReferralLink();
                    return;
                default:
                    return;
            }
            
            window.open(url, '_blank');
            trackInviteSent();
        }
        
        function trackInviteSent() {
            if (!appData.referral) {
                appData.referral = { invitesSent: 0, friendsJoined: 0, friendsEngaged: 0, totalEarned: 0 };
            }
            
            // Only award once per session to prevent spam
            const lastInvite = sessionStorage.getItem('lastInviteSent');
            const now = Date.now();
            if (lastInvite && now - parseInt(lastInvite) < 60000) {
                return; // Less than 1 minute since last invite
            }
            
            sessionStorage.setItem('lastInviteSent', now.toString());
            appData.referral.invitesSent++;
            appData.referral.totalEarned += REFERRAL_REWARDS.sent;
            appData.wallet.tokens += REFERRAL_REWARDS.sent;
            
            saveData();
            renderWallet();
            showToast(`+${REFERRAL_REWARDS.sent} ðŸŽŸï¸ tokens for sharing!`);
            
            // Log activity
            logActivity('referral-invite', { tokens: REFERRAL_REWARDS.sent });
        }
        
        function checkReferralParam() {
            // Check URL for referral/invite code (supports both ?ref= and #ref=)
            const refCode = getDeepLinkParam('ref');
            
            if (refCode && refCode.length === 8) {
                cleanDeepLinkUrl();
                
                // If already signed in, treat as friend connection
                if (currentUser) {
                    handleInviteLinkForExistingUser(refCode);
                } else {
                    // Store for later (when they sign up)
                    sessionStorage.setItem('referralCode', refCode);
                    showToast('ðŸŽ Invite link applied! Sign in to connect.');
                }
            }
        }
        
        // Handle invite link for users who are already signed in
        async function handleInviteLinkForExistingUser(refCode) {
            try {
                // Look up referrer by code
                const snapshot = await db.ref(`referralCodes/${refCode}`).once('value');
                const referrerData = snapshot.val();
                
                if (!referrerData) {
                    showToast('Invalid invite code');
                    return;
                }
                
                const referrerId = referrerData.ownerId;
                
                if (referrerId === currentUser.uid) {
                    showToast("That's your own invite link!");
                    return;
                }
                
                // Check if already friends
                const existingFriend = friendsData.find(f => f.odataId === referrerId);
                if (existingFriend) {
                    showToast('Already connected!');
                    return;
                }
                
                // Get referrer's public profile
                const profileSnapshot = await db.ref('gameshelf-public/' + referrerId).once('value');
                const profileData = profileSnapshot.val() || { displayName: referrerData.ownerName || 'Player' };
                
                // Show friend confirm (reuse existing flow)
                showFriendConfirm(referrerId, profileData);
                
            } catch (e) {
                console.error('Error handling invite link:', e);
                showToast('Could not process invite');
            }
        }
        
        function checkBattleParam() {
            // Check URL for battle join code (supports both ?battle= and #battle=)
            const battleCode = getDeepLinkParam('battle');
            
            if (battleCode && battleCode.length === 6) {
                cleanDeepLinkUrl();
                
                // Wait for app to initialize, then open join battle
                setTimeout(() => {
                    showJoinBattle();
                    document.getElementById('join-code-input').value = battleCode.toUpperCase();
                    // Auto-lookup the battle
                    setTimeout(() => {
                        lookupBattleCode();
                    }, 300);
                }, 500);
            }
        }
        
        async function processReferralSignup() {
            if (!currentUser) return;
            
            // Check if already referred
            if (appData.referral?.referredBy) return;
            
            const refCode = sessionStorage.getItem('referralCode');
            if (!refCode) return;
            
            try {
                // Look up referrer
                const snapshot = await db.ref(`referralCodes/${refCode}`).once('value');
                const referrerData = snapshot.val();
                
                if (!referrerData || referrerData.ownerId === currentUser.uid) {
                    // Invalid code or self-referral
                    sessionStorage.removeItem('referralCode');
                    return;
                }
                
                const referrerId = referrerData.ownerId;
                
                // Record referral
                if (!appData.referral) {
                    appData.referral = { invitesSent: 0, friendsJoined: 0, friendsEngaged: 0, totalEarned: 0 };
                }
                appData.referral.referredBy = refCode;
                
                // New users already get 50 tokens from default wallet
                // Just save the referral connection
                saveData();
                showToast('ðŸŽ‰ Welcome! You have 50 bonus tokens to get started!');
                
                // Update referrer's data in Firebase
                await db.ref(`referralCodes/${refCode}/referees/${currentUser.uid}`).set({
                    joinedAt: Date.now(),
                    tier: 2,
                    displayName: currentUser.displayName || 'Friend'
                });
                
                // Award referrer (they'll see it next time they load)
                await db.ref(`users/${referrerData.ownerId}/pendingReferralRewards`).push({
                    type: 'joined',
                    tokens: REFERRAL_REWARDS.joined,
                    fromName: currentUser.displayName || 'A friend',
                    timestamp: Date.now()
                });
                
                // === AUTO-ADD AS FRIENDS ===
                // Get referrer's profile for friend data
                const referrerProfile = await db.ref('gameshelf-public/' + referrerId).once('value');
                const referrerProfileData = referrerProfile.val() || {};
                
                // Add referrer to my friends list
                await db.ref('friends/' + currentUser.uid + '/' + referrerId).set({
                    odataId: referrerId,
                    displayName: referrerProfileData.displayName || referrerData.ownerName || 'Friend',
                    photoURL: referrerProfileData.photoURL || null,
                    addedAt: Date.now(),
                    viaReferral: true
                });
                
                // Add me to referrer's friends list
                await db.ref('friends/' + referrerId + '/' + currentUser.uid).set({
                    odataId: currentUser.uid,
                    displayName: currentUser.displayName || 'Friend',
                    photoURL: currentUser.photoURL || null,
                    addedAt: Date.now(),
                    viaReferral: true
                });
                
                // Reload friends data
                await loadFriendsData();
                
                sessionStorage.removeItem('referralCode');
                
                setTimeout(() => {
                    showToast('ðŸ‘¥ You and ' + (referrerProfileData.displayName || 'your friend') + ' are now connected!');
                }, 1500);
                
            } catch (e) {
                console.error('Error processing referral:', e);
            }
        }
        
        async function checkPendingReferralRewards() {
            if (!currentUser) return;
            
            try {
                const snapshot = await db.ref(`users/${currentUser.uid}/pendingReferralRewards`).once('value');
                const rewards = snapshot.val();
                
                if (!rewards) return;
                
                let totalTokens = 0;
                const messages = [];
                
                Object.entries(rewards).forEach(([key, reward]) => {
                    totalTokens += reward.tokens;
                    
                    if (reward.type === 'joined') {
                        if (!appData.referral) appData.referral = { friendsJoined: 0, friendsEngaged: 0, totalEarned: 0 };
                        appData.referral.friendsJoined++;
                        messages.push(`${reward.fromName} joined!`);
                    } else if (reward.type === 'engaged') {
                        if (!appData.referral) appData.referral = { friendsJoined: 0, friendsEngaged: 0, totalEarned: 0 };
                        appData.referral.friendsEngaged++;
                        messages.push(`${reward.fromName} got engaged!`);
                    }
                });
                
                if (totalTokens > 0) {
                    appData.wallet.tokens += totalTokens;
                    if (!appData.referral) appData.referral = { totalEarned: 0 };
                    appData.referral.totalEarned += totalTokens;
                    saveData();
                    renderWallet();
                    
                    // v1.2.77: Play coin drop sound for referral rewards
                    playSound('walletAdd');
                    
                    showToast(`ðŸŽ +${totalTokens} tokens from referrals!`);
                    logActivity('referral-reward', { tokens: totalTokens, friends: messages });
                    
                    // Clear pending rewards
                    await db.ref(`users/${currentUser.uid}/pendingReferralRewards`).remove();
                }
                
            } catch (e) {
                console.error('Error checking referral rewards:', e);
            }
        }
        
        async function triggerReferralEngagement(feature) {
            // Called when user uses advanced feature (battle or share hub)
            if (!currentUser || !appData.referral?.referredBy) return;
            
            // Check if already triggered
            if (appData.referral.engagementTriggered) return;
            
            const refCode = appData.referral.referredBy;
            
            try {
                // Look up referrer
                const snapshot = await db.ref(`referralCodes/${refCode}`).once('value');
                const referrerData = snapshot.val();
                
                if (!referrerData) return;
                
                // Check if already marked as engaged
                const refereeData = referrerData.referees?.[currentUser.uid];
                if (refereeData?.tier >= 3) return;
                
                // Update to tier 3
                await db.ref(`referralCodes/${refCode}/referees/${currentUser.uid}/tier`).set(3);
                await db.ref(`referralCodes/${refCode}/referees/${currentUser.uid}/engagedAt`).set(Date.now());
                await db.ref(`referralCodes/${refCode}/referees/${currentUser.uid}/feature`).set(feature);
                
                // Award referrer
                await db.ref(`users/${referrerData.ownerId}/pendingReferralRewards`).push({
                    type: 'engaged',
                    tokens: REFERRAL_REWARDS.engaged,
                    fromName: currentUser.displayName || 'A friend',
                    feature: feature,
                    timestamp: Date.now()
                });
                
                // Award the new user too
                appData.wallet.tokens += 10;
                appData.referral.engagementTriggered = true;
                saveData();
                renderWallet();
                showToast('ðŸŽ +10 tokens for trying ' + feature + '!');
                
            } catch (e) {
                console.error('Error triggering referral engagement:', e);
            }
        }
        
        // ============ SOUND SYSTEM ============
        const SoundManager = {
            ctx: null,
            enabled: localStorage.getItem('gameshelfSound') !== 'false',
            volume: parseFloat(localStorage.getItem('gameshelfVolume') || '0.5') || 0.5,
            
            // Sound Events - all places where sounds can play
            events: {
                achievement: { name: 'Achievement Unlocked', icon: 'ðŸ†', description: 'When you earn an achievement' },
                coin: { name: 'Earn Tokens', icon: 'ðŸª™', description: 'When you earn tokens from games' },
                walletAdd: { name: 'Coins to Wallet', icon: 'ðŸ’°', description: 'When coins are added to your wallet' },
                hint: { name: 'Hint Received', icon: 'ðŸ’¡', description: 'When you receive an AI hint' },
                streak: { name: 'Streak Bonus', icon: 'ðŸ”¥', description: 'When your streak increases' },
                gameComplete: { name: 'Game Complete', icon: 'âœ…', description: 'When you complete a game' },
                levelUp: { name: 'Level Up', icon: 'â¬†ï¸', description: 'When you reach a new level' },
                click: { name: 'Button Click', icon: 'ðŸ‘†', description: 'When clicking buttons' },
                toggle: { name: 'Toggle Switch', icon: 'ðŸ”˜', description: 'When toggling settings' },
                success: { name: 'Success', icon: 'âœ¨', description: 'General success actions' },
                error: { name: 'Error', icon: 'âŒ', description: 'When something goes wrong' },
                notification: { name: 'Notification', icon: 'ðŸ””', description: 'General notifications' },
                sync: { name: 'Cloud Sync', icon: 'â˜ï¸', description: 'When data syncs' }
            },
            
            // Sound Library - available sounds to choose from
            library: {
                // Chimes & Bells
                chime1: { name: 'Gentle Chime', category: 'Chimes', icon: 'ðŸ””' },
                chime2: { name: 'Crystal Bell', category: 'Chimes', icon: 'ðŸ””' },
                chime3: { name: 'Wind Chime', category: 'Chimes', icon: 'ðŸŽ' },
                
                // Retro Game Sounds
                coin8bit: { name: '8-bit Coin', category: 'Retro', icon: 'ðŸŽ®' },
                coinDrop: { name: 'Slot Machine Coins', category: 'Retro', icon: 'ðŸŽ°' },
                powerup: { name: 'Power Up', category: 'Retro', icon: 'âš¡' },
                levelup8bit: { name: '8-bit Level Up', category: 'Retro', icon: 'ðŸ†™' },
                blip: { name: 'Blip', category: 'Retro', icon: 'ðŸ“Ÿ' },
                victory8bit: { name: '8-bit Victory', category: 'Retro', icon: 'ðŸ†' },
                
                // Modern UI
                pop: { name: 'Pop', category: 'Modern', icon: 'ðŸ’«' },
                whoosh: { name: 'Whoosh', category: 'Modern', icon: 'ðŸ’¨' },
                ding: { name: 'Ding', category: 'Modern', icon: 'ðŸ›Žï¸' },
                click1: { name: 'Soft Click', category: 'Modern', icon: 'ðŸ‘†' },
                click2: { name: 'Crisp Click', category: 'Modern', icon: 'ðŸ‘†' },
                
                // Musical
                fanfare: { name: 'Fanfare', category: 'Musical', icon: 'ðŸŽº' },
                harp: { name: 'Harp Gliss', category: 'Musical', icon: 'ðŸŽµ' },
                marimba: { name: 'Marimba', category: 'Musical', icon: 'ðŸŽ¹' },
                xylophone: { name: 'Xylophone', category: 'Musical', icon: 'ðŸŽ¼' },
                
                // Notifications
                notify1: { name: 'Gentle Notify', category: 'Notify', icon: 'ðŸ“£' },
                notify2: { name: 'Alert', category: 'Notify', icon: 'âš ï¸' },
                complete: { name: 'Task Complete', category: 'Notify', icon: 'âœ…' },
                lightbulb: { name: 'Lightbulb Moment', category: 'Notify', icon: 'ðŸ’¡' },
                
                // Fun
                sparkle: { name: 'Sparkle', category: 'Fun', icon: 'âœ¨' },
                magic: { name: 'Magic', category: 'Fun', icon: 'ðŸª„' },
                bounce: { name: 'Bounce', category: 'Fun', icon: 'ðŸ€' },
                
                // Silent
                none: { name: 'Silent', category: 'Other', icon: 'ðŸ”‡' }
            },
            
            // Default sound assignments
            defaults: {
                achievement: 'fanfare',
                coin: 'coin8bit',
                walletAdd: 'coinDrop',
                hint: 'lightbulb',
                streak: 'powerup',
                gameComplete: 'complete',
                levelUp: 'levelup8bit',
                click: 'click1',
                toggle: 'blip',
                success: 'chime1',
                error: 'notify2',
                notification: 'ding',
                sync: 'whoosh'
            },
            
            // User preferences
            preferences: {},
            
            init() {
                const saved = localStorage.getItem('gameshelfSoundPrefs');
                this.preferences = saved ? JSON.parse(saved) : { ...this.defaults };
                if (!this.ctx) {
                    try {
                        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                        console.log('ðŸ”Š AudioContext created, state:', this.ctx.state);
                    } catch (e) {
                        console.log('ðŸ”Š AudioContext creation failed:', e);
                    }
                }
                return this.ctx;
            },
            
            // v1.2.77: Async resume for iOS
            async ensureResumed() {
                if (!this.ctx) this.init();
                if (this.ctx && this.ctx.state === 'suspended') {
                    try {
                        await this.ctx.resume();
                        console.log('ðŸ”Š AudioContext resumed, state:', this.ctx.state);
                    } catch (e) {
                        console.log('ðŸ”Š AudioContext resume failed:', e);
                    }
                }
                return this.ctx?.state === 'running';
            },
            
            getSoundForEvent(eventId) {
                return this.preferences[eventId] || this.defaults[eventId] || 'chime1';
            },
            
            setSoundForEvent(eventId, soundId) {
                this.preferences[eventId] = soundId;
                localStorage.setItem('gameshelfSoundPrefs', JSON.stringify(this.preferences));
            },
            
            async playEvent(eventId) {
                if (!this.enabled) return;
                const soundEnabled = appData?.settings?.soundEnabled !== false;
                if (!soundEnabled) return;
                const soundId = this.getSoundForEvent(eventId);
                if (soundId === 'none') return;
                await this.playSound(soundId);
            },
            
            async playSound(soundId) {
                const soundEnabled = appData?.settings?.soundEnabled !== false;
                if (!this.enabled && soundId !== 'preview') return;
                if (!soundEnabled && soundId !== 'preview') return;
                
                try {
                    const ctx = this.init();
                    if (!ctx) return;
                    
                    // v1.2.77: Must await resume on iOS
                    if (ctx.state === 'suspended') {
                        await ctx.resume();
                    }
                    
                    // Double-check we're running
                    if (ctx.state !== 'running') {
                        console.log('ðŸ”Š AudioContext not running:', ctx.state);
                        return;
                    }
                    
                    const masterGain = ctx.createGain();
                    masterGain.gain.value = this.volume;
                    masterGain.connect(ctx.destination);
                    
                    switch(soundId) {
                        case 'chime1':
                            this._playTone(ctx, masterGain, [
                                { freq: 659, time: 0, dur: 0.3, type: 'sine' },
                                { freq: 880, time: 0.1, dur: 0.25, type: 'sine' }
                            ]);
                            break;
                        case 'chime2':
                            this._playTone(ctx, masterGain, [
                                { freq: 1047, time: 0, dur: 0.4, type: 'sine' },
                                { freq: 1319, time: 0.15, dur: 0.3, type: 'sine' },
                                { freq: 1568, time: 0.3, dur: 0.2, type: 'sine' }
                            ]);
                            break;
                        case 'chime3':
                            this._playTone(ctx, masterGain, [
                                { freq: 523, time: 0, dur: 0.5, type: 'sine' },
                                { freq: 698, time: 0.1, dur: 0.4, type: 'sine' },
                                { freq: 880, time: 0.2, dur: 0.3, type: 'sine' },
                                { freq: 1047, time: 0.3, dur: 0.2, type: 'sine' }
                            ]);
                            break;
                        case 'coin8bit':
                            this._playTone(ctx, masterGain, [
                                { freq: 988, time: 0, dur: 0.08, type: 'square', vol: 0.3 },
                                { freq: 1319, time: 0.08, dur: 0.15, type: 'square', vol: 0.3 }
                            ]);
                            break;
                        case 'coinDrop':
                            // Slot machine coin drop - multiple coins falling
                            this._playTone(ctx, masterGain, [
                                // First wave of coins
                                { freq: 2200, time: 0, dur: 0.04, type: 'square', vol: 0.25 },
                                { freq: 1800, time: 0.05, dur: 0.04, type: 'square', vol: 0.2 },
                                { freq: 2400, time: 0.1, dur: 0.04, type: 'square', vol: 0.25 },
                                { freq: 2000, time: 0.15, dur: 0.04, type: 'square', vol: 0.2 },
                                // Second wave
                                { freq: 2600, time: 0.2, dur: 0.04, type: 'square', vol: 0.22 },
                                { freq: 1900, time: 0.25, dur: 0.04, type: 'square', vol: 0.18 },
                                { freq: 2300, time: 0.3, dur: 0.04, type: 'square', vol: 0.2 },
                                { freq: 2100, time: 0.35, dur: 0.04, type: 'square', vol: 0.18 },
                                // Final coins settling
                                { freq: 2500, time: 0.4, dur: 0.03, type: 'square', vol: 0.15 },
                                { freq: 2000, time: 0.45, dur: 0.03, type: 'square', vol: 0.12 },
                                { freq: 2200, time: 0.5, dur: 0.05, type: 'square', vol: 0.1 }
                            ]);
                            break;
                        case 'lightbulb':
                            // Lightbulb moment - bright ascending sparkle
                            this._playTone(ctx, masterGain, [
                                { freq: 600, time: 0, dur: 0.1, type: 'sine', vol: 0.2 },
                                { freq: 900, time: 0.08, dur: 0.12, type: 'sine', vol: 0.25 },
                                { freq: 1200, time: 0.18, dur: 0.15, type: 'sine', vol: 0.3 },
                                { freq: 1600, time: 0.3, dur: 0.2, type: 'sine', vol: 0.25 }
                            ]);
                            break;
                        case 'powerup':
                            this._playSweep(ctx, masterGain, 200, 800, 0.3, 'square', 0.3);
                            break;
                        case 'levelup8bit':
                            this._playTone(ctx, masterGain, [
                                { freq: 262, time: 0, dur: 0.1, type: 'square', vol: 0.3 },
                                { freq: 330, time: 0.1, dur: 0.1, type: 'square', vol: 0.3 },
                                { freq: 392, time: 0.2, dur: 0.1, type: 'square', vol: 0.3 },
                                { freq: 523, time: 0.3, dur: 0.2, type: 'square', vol: 0.3 }
                            ]);
                            break;
                        case 'blip':
                            this._playTone(ctx, masterGain, [
                                { freq: 600, time: 0, dur: 0.05, type: 'square', vol: 0.2 }
                            ]);
                            break;
                        case 'victory8bit':
                            this._playTone(ctx, masterGain, [
                                { freq: 523, time: 0, dur: 0.12, type: 'square', vol: 0.25 },
                                { freq: 523, time: 0.15, dur: 0.12, type: 'square', vol: 0.25 },
                                { freq: 523, time: 0.3, dur: 0.12, type: 'square', vol: 0.25 },
                                { freq: 698, time: 0.45, dur: 0.4, type: 'square', vol: 0.25 }
                            ]);
                            break;
                        case 'pop':
                            this._playSweep(ctx, masterGain, 400, 600, 0.08, 'sine', 0.4);
                            break;
                        case 'whoosh':
                            this._playNoise(ctx, masterGain, 0.15, 'lowpass', 2000);
                            break;
                        case 'ding':
                            this._playTone(ctx, masterGain, [
                                { freq: 880, time: 0, dur: 0.3, type: 'sine', vol: 0.5 }
                            ]);
                            break;
                        case 'click1':
                            this._playTone(ctx, masterGain, [
                                { freq: 400, time: 0, dur: 0.03, type: 'sine', vol: 0.3 }
                            ]);
                            break;
                        case 'click2':
                            this._playTone(ctx, masterGain, [
                                { freq: 800, time: 0, dur: 0.02, type: 'triangle', vol: 0.4 }
                            ]);
                            break;
                        case 'fanfare':
                            this._playTone(ctx, masterGain, [
                                { freq: 440, time: 0, dur: 0.15, type: 'sawtooth', vol: 0.2 },
                                { freq: 554, time: 0.12, dur: 0.15, type: 'sawtooth', vol: 0.2 },
                                { freq: 659, time: 0.24, dur: 0.15, type: 'sawtooth', vol: 0.2 },
                                { freq: 880, time: 0.36, dur: 0.4, type: 'sawtooth', vol: 0.25 }
                            ]);
                            break;
                        case 'harp':
                            this._playTone(ctx, masterGain, [
                                { freq: 262, time: 0, dur: 0.4, type: 'sine', vol: 0.3 },
                                { freq: 330, time: 0.05, dur: 0.35, type: 'sine', vol: 0.3 },
                                { freq: 392, time: 0.1, dur: 0.3, type: 'sine', vol: 0.3 },
                                { freq: 523, time: 0.15, dur: 0.25, type: 'sine', vol: 0.3 }
                            ]);
                            break;
                        case 'marimba':
                            this._playTone(ctx, masterGain, [
                                { freq: 440, time: 0, dur: 0.2, type: 'triangle', vol: 0.4 },
                                { freq: 554, time: 0.1, dur: 0.2, type: 'triangle', vol: 0.35 }
                            ]);
                            break;
                        case 'xylophone':
                            this._playTone(ctx, masterGain, [
                                { freq: 1047, time: 0, dur: 0.15, type: 'sine', vol: 0.4 },
                                { freq: 1319, time: 0.08, dur: 0.12, type: 'sine', vol: 0.35 }
                            ]);
                            break;
                        case 'notify1':
                            this._playTone(ctx, masterGain, [
                                { freq: 523, time: 0, dur: 0.15, type: 'sine', vol: 0.3 },
                                { freq: 659, time: 0.15, dur: 0.15, type: 'sine', vol: 0.25 }
                            ]);
                            break;
                        case 'notify2':
                            this._playTone(ctx, masterGain, [
                                { freq: 200, time: 0, dur: 0.15, type: 'sawtooth', vol: 0.3 },
                                { freq: 150, time: 0.1, dur: 0.15, type: 'sawtooth', vol: 0.25 }
                            ]);
                            break;
                        case 'complete':
                            this._playTone(ctx, masterGain, [
                                { freq: 523, time: 0, dur: 0.1, type: 'sine', vol: 0.3 },
                                { freq: 659, time: 0.1, dur: 0.1, type: 'sine', vol: 0.3 },
                                { freq: 784, time: 0.2, dur: 0.2, type: 'sine', vol: 0.35 }
                            ]);
                            break;
                        case 'sparkle':
                            this._playTone(ctx, masterGain, [
                                { freq: 1200, time: 0, dur: 0.1, type: 'sine', vol: 0.2 },
                                { freq: 1500, time: 0.05, dur: 0.1, type: 'sine', vol: 0.15 },
                                { freq: 1800, time: 0.1, dur: 0.1, type: 'sine', vol: 0.1 },
                                { freq: 2100, time: 0.15, dur: 0.1, type: 'sine', vol: 0.05 }
                            ]);
                            break;
                        case 'magic':
                            this._playSweep(ctx, masterGain, 300, 1200, 0.4, 'sine', 0.3);
                            this._playTone(ctx, masterGain, [
                                { freq: 800, time: 0.2, dur: 0.3, type: 'sine', vol: 0.2 },
                                { freq: 1000, time: 0.25, dur: 0.25, type: 'sine', vol: 0.15 }
                            ]);
                            break;
                        case 'bounce':
                            this._playTone(ctx, masterGain, [
                                { freq: 300, time: 0, dur: 0.08, type: 'sine', vol: 0.4 },
                                { freq: 400, time: 0.1, dur: 0.06, type: 'sine', vol: 0.3 },
                                { freq: 500, time: 0.18, dur: 0.04, type: 'sine', vol: 0.2 }
                            ]);
                            break;
                        case 'none':
                        default:
                            break;
                    }
                } catch (e) {
                    console.log('Audio error:', e);
                }
            },
            
            _playTone(ctx, destination, notes) {
                notes.forEach(note => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = note.type || 'sine';
                    osc.frequency.value = note.freq;
                    gain.gain.setValueAtTime(note.vol || 0.3, ctx.currentTime + note.time);
                    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + note.time + note.dur);
                    osc.connect(gain);
                    gain.connect(destination);
                    osc.start(ctx.currentTime + note.time);
                    osc.stop(ctx.currentTime + note.time + note.dur + 0.1);
                });
            },
            
            _playSweep(ctx, destination, startFreq, endFreq, duration, type, vol) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = type || 'sine';
                osc.frequency.setValueAtTime(startFreq, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(endFreq, ctx.currentTime + duration);
                gain.gain.setValueAtTime(vol || 0.3, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(destination);
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + duration + 0.1);
            },
            
            _playNoise(ctx, destination, duration, filterType, filterFreq) {
                const bufferSize = ctx.sampleRate * duration;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = ctx.createBufferSource();
                noise.buffer = buffer;
                const filter = ctx.createBiquadFilter();
                filter.type = filterType;
                filter.frequency.value = filterFreq;
                const gain = ctx.createGain();
                gain.gain.setValueAtTime(0.3, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(destination);
                noise.start();
                noise.stop(ctx.currentTime + duration);
            },
            
            setVolume(vol) {
                this.volume = Math.max(0, Math.min(1, vol));
                localStorage.setItem('gameshelfVolume', this.volume);
            },
            
            setEnabled(enabled) {
                this.enabled = enabled;
                localStorage.setItem('gameshelfSound', enabled);
            }
        };
        
        // Initialize sound manager
        SoundManager.init();
        
        function playSound(soundId) {
            // Map old sound IDs to new event-based sounds
            const eventMap = {
                'achievement': 'achievement',
                'coin': 'coin',
                'success': 'success',
                'complete': 'gameComplete',
                'click': 'click',
                'toggle': 'toggle',
                'error': 'error',
                'streak': 'streak',
                'levelup': 'levelUp'
            };
            const eventId = eventMap[soundId] || soundId;
            SoundManager.playEvent(eventId);
        }
        
        function previewSound(soundId) {
            // For preview, play directly bypassing enabled check
            const oldEnabled = SoundManager.enabled;
            SoundManager.enabled = true;
            SoundManager.playSound(soundId);
            SoundManager.enabled = oldEnabled;
            
            // v1.2.77: Show mute reminder after a short delay
            // (browsers can't detect hardware mute, so we remind users)
            setTimeout(() => {
                showToast('ðŸ”‡ No sound? Check if your device is muted', 'info', 3000);
            }, 800);
        }
        
        function showSoundCustomizer() {
            renderSoundCustomizer();
            document.getElementById('sound-customizer-modal').classList.add('active');
        }
        
        function closeSoundCustomizer() {
            document.getElementById('sound-customizer-modal').classList.remove('active');
        }
        
        function renderSoundCustomizer() {
            const container = document.getElementById('sound-events-list');
            if (!container) return;
            
            container.innerHTML = Object.entries(SoundManager.events).map(([eventId, event]) => {
                const currentSound = SoundManager.getSoundForEvent(eventId);
                const soundInfo = SoundManager.library[currentSound] || { name: 'Unknown', icon: '?' };
                
                return `
                    <div class="sound-event-row">
                        <div class="sound-event-info">
                            <span class="sound-event-icon">${event.icon}</span>
                            <div>
                                <div class="sound-event-name">${event.name}</div>
                                <div class="sound-event-desc">${event.description}</div>
                            </div>
                        </div>
                        <div class="sound-event-selector">
                            <select onchange="setEventSound('${eventId}', this.value)">
                                ${Object.entries(SoundManager.library).map(([soundId, sound]) => `
                                    <option value="${soundId}" ${currentSound === soundId ? 'selected' : ''}>
                                        ${sound.icon} ${sound.name}
                                    </option>
                                `).join('')}
                            </select>
                            <button class="preview-btn" onclick="previewSound('${currentSound}')" title="Preview">â–¶ï¸</button>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function setEventSound(eventId, soundId) {
            SoundManager.setSoundForEvent(eventId, soundId);
            previewSound(soundId);
            renderSoundCustomizer();
        }
        
        function resetSoundDefaults() {
            if (confirm('Reset all sounds to defaults?')) {
                SoundManager.preferences = { ...SoundManager.defaults };
                localStorage.setItem('gameshelfSoundPrefs', JSON.stringify(SoundManager.preferences));
                renderSoundCustomizer();
                showToast('ðŸ”Š Sounds reset to defaults');
            }
        }
        
        function resetDailyGoal() {
            const goal = prompt('Set your daily game goal (1-10):', appData.dailyGoal || 5);
            if (goal && !isNaN(goal)) {
                appData.dailyGoal = Math.min(10, Math.max(1, parseInt(goal)));
                saveData();
                renderProgress();
                showToast(`Daily goal set to ${appData.dailyGoal}`);
            }
        }
        
        // Confirmation Modal Functions
        let confirmModalCallback = null;
        let confirmModalAltCallback = null;
        let confirmModalThirdCallback = null;
        
        function showConfirmModal(options) {
            const { icon, title, message, confirmText, confirmStyle, onConfirm, altText, altStyle, onAlt, thirdText, thirdStyle, onThird } = options;
            
            document.getElementById('confirm-modal-icon').textContent = icon || 'âš ï¸';
            document.getElementById('confirm-modal-title').textContent = title || 'Are you sure?';
            document.getElementById('confirm-modal-message').textContent = message || 'This action cannot be undone.';
            
            const actionBtn = document.getElementById('confirm-modal-action');
            actionBtn.textContent = confirmText || 'Confirm';
            actionBtn.className = 'confirm-modal-btn ' + (confirmStyle || 'danger');
            
            // v1.2.7.6: Optional alt/third button
            const altBtn = document.getElementById('confirm-modal-alt');
            if (altText && onAlt) {
                altBtn.textContent = altText;
                altBtn.className = 'confirm-modal-btn ' + (altStyle || 'secondary');
                altBtn.style.display = 'block';
                confirmModalAltCallback = onAlt;
            } else {
                altBtn.style.display = 'none';
                confirmModalAltCallback = null;
            }
            
            // v1.2.47: Optional third button (for View Stats)
            const thirdBtn = document.getElementById('confirm-modal-third');
            if (thirdText && onThird) {
                thirdBtn.textContent = thirdText;
                thirdBtn.className = 'confirm-modal-btn ' + (thirdStyle || 'secondary');
                thirdBtn.style.display = 'block';
                confirmModalThirdCallback = onThird;
            } else {
                thirdBtn.style.display = 'none';
                confirmModalThirdCallback = null;
            }
            
            confirmModalCallback = onConfirm;
            document.getElementById('confirm-modal-overlay').classList.add('active');
        }
        
        function closeConfirmModal() {
            document.getElementById('confirm-modal-overlay').classList.remove('active');
            confirmModalCallback = null;
            confirmModalAltCallback = null;
            confirmModalThirdCallback = null;
        }
        
        function confirmModalAction() {
            if (confirmModalCallback) {
                confirmModalCallback();
            }
            closeConfirmModal();
        }
        
        function confirmModalAltAction() {
            if (confirmModalAltCallback) {
                confirmModalAltCallback();
            }
            closeConfirmModal();
        }
        
        function confirmModalThirdAction() {
            if (confirmModalThirdCallback) {
                confirmModalThirdCallback();
            }
            closeConfirmModal();
        }
        
        function clearAllData() {
            showConfirmModal({
                icon: 'ðŸ—‘ï¸',
                title: 'Reset All Data?',
                message: 'This will delete all your games, stats, history, and settings. This cannot be undone.',
                confirmText: 'Reset Everything',
                confirmStyle: 'danger',
                onConfirm: () => {
                    localStorage.removeItem('gameshelf-pwa-data');
                    localStorage.removeItem('installBannerDismissed');
                    localStorage.removeItem('gameshelf_setup_complete');
                    localStorage.removeItem('gameshelf_games');
                    appData = {
                        games: [...DEFAULT_SHELF.map(id => ({ id, addedAt: Date.now() }))],
                        stats: {},
                        history: {},
                        wallet: { tokens: 0, coins: 0 },
                        achievements: [],
                        dailyGoal: 5,
                        friends: [],
                        settings: {}
                    };
                    renderAll();
                    showToast('Data cleared', 'success');
                }
            });
        }
        
        async function resetPurchaseLimits() {
            if (!currentUser) {
                showToast('Sign in to reset purchase limits', 'error');
                return;
            }
            
            // Check wallet state first
            const tokens = appData.wallet?.tokens || 0;
            const coins = appData.wallet?.coins || 0;
            
            if (tokens > 50 || coins > 0) {
                showToast('Reset your data first (wallet must be at default)', 'error');
                return;
            }
            
            showConfirmModal({
                icon: 'ðŸ§¹',
                title: 'Reset Purchase Limits?',
                message: 'This clears your purchase history so you can test the purchase flow again. Only works after resetting your data.',
                confirmText: 'Reset Limits',
                confirmStyle: 'warning',
                onConfirm: async () => {
                    try {
                        showToast('ðŸ”„ Resetting purchase limits...');
                        const resetPurchaseHistory = firebase.functions().httpsCallable('resetPurchaseHistory');
                        const result = await resetPurchaseHistory();
                        showToast(`âœ… ${result.data.message}`, 'success');
                    } catch (e) {
                        console.error('Reset purchase limits error:', e);
                        showToast(e.message || 'Failed to reset limits', 'error');
                    }
                }
            });
        }
        
        function exportData() {
            const dataStr = JSON.stringify(appData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'gameshelf-backup-' + getTodayString() + '.json';
            a.click();
            URL.revokeObjectURL(url);
            showToast('ðŸ“¤ Data exported');
        }
        
        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const importedData = JSON.parse(event.target.result);
                        if (importedData.games && importedData.history) {
                            appData = { ...appData, ...importedData };
                            saveData();
                            renderAll();
                            showToast('ðŸ“¥ Data imported successfully');
                        } else {
                            showToast('Invalid backup file', 'error');
                        }
                    } catch (err) {
                        showToast('Failed to import data', 'error');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
        
        // ============ WHAT'S NEW SYSTEM ============
        const APP_VERSION = '1.3.4';
        
        const RELEASE_NOTES = {
            '1.3.4': [
                { icon: 'ðŸ¤–', title: 'AI Help', desc: 'Ask questions about Game Shelf and get instant answers' },
                { icon: 'ðŸ’¡', title: 'Smart Context', desc: 'AI knows what you searched and viewed in FAQs' },
                { icon: 'ðŸ’Ž', title: 'Token-Powered', desc: '5 tokens per question (can be adjusted based on feedback)' }
            ],
            '1.3.3': [
                { icon: 'â“', title: 'Help Center', desc: 'Searchable FAQs, tutorials, and support all in one place' },
                { icon: 'ðŸ”', title: 'Smart Search', desc: 'Find answers instantly as you type' }
            ],
            '1.3.2': [
                { icon: 'ðŸŽ‰', title: "What's New Feature", desc: "See what changed after each update" },
                { icon: 'ðŸ“‹', title: 'Improved Menus', desc: 'Reorganized menu for easier access' },
                { icon: 'âœ¨', title: 'Better Modals', desc: 'Prettier dialogs throughout the app' }
            ],
            '1.3.1': [
                { icon: 'ðŸ“±', title: 'Quick Game Long-Press', desc: 'Quick game buttons now support long-press for options' },
                { icon: 'ðŸ”¥', title: 'Current Streak Display', desc: 'Progress shows your current streak, not all-time best' },
                { icon: 'âœ¨', title: 'Visual Feedback', desc: 'Cards glow purple when holding for long-press' },
                { icon: 'ðŸ‘¥', title: 'Friend Names', desc: 'First names shown below friend avatars' },
                { icon: 'âš”ï¸', title: 'Battle Widget', desc: 'Shows multiple battles and better time display' }
            ],
            '1.3.0': [
                { icon: 'ðŸ—‘ï¸', title: 'Remove Games', desc: 'Long-press any game to remove it from your shelf' },
                { icon: 'ðŸ”', title: 'Better Search', desc: 'Search by category, see streaks in results' },
                { icon: 'ðŸ”„', title: 'Better Recommendations', desc: 'Refresh button now provides real variety' }
            ]
        };
        
        function getLastSeenVersion() {
            return localStorage.getItem('gs_last_seen_version') || '0.0.0';
        }
        
        function setLastSeenVersion(version) {
            localStorage.setItem('gs_last_seen_version', version);
        }
        
        function hasUnseenUpdate() {
            return getLastSeenVersion() !== APP_VERSION;
        }
        
        function checkForWhatsNew() {
            if (hasUnseenUpdate()) {
                // Show badge on menu
                updateWhatsNewBadge(true);
                // Auto-show What's New after brief delay (let app render first)
                setTimeout(() => {
                    showWhatsNew(true); // true = auto-triggered
                }, 1500);
            }
        }
        
        function updateWhatsNewBadge(show) {
            const badge = document.getElementById('whats-new-badge');
            const menuBadge = document.getElementById('whats-new-menu-badge');
            if (badge) {
                badge.style.display = show ? 'inline' : 'none';
            }
            if (menuBadge) {
                menuBadge.style.display = show ? 'inline' : 'none';
            }
        }
        
        function showWhatsNew(autoTriggered = false) {
            const lastSeen = getLastSeenVersion();
            const notes = [];
            
            // Collect notes for versions newer than last seen
            Object.keys(RELEASE_NOTES).forEach(version => {
                if (compareVersions(version, lastSeen) > 0) {
                    notes.push({ version, items: RELEASE_NOTES[version] });
                }
            });
            
            // Sort by version descending
            notes.sort((a, b) => compareVersions(b.version, a.version));
            
            // If no new notes, show current version notes
            if (notes.length === 0 && RELEASE_NOTES[APP_VERSION]) {
                notes.push({ version: APP_VERSION, items: RELEASE_NOTES[APP_VERSION] });
            }
            
            let content = '<div style="padding: 16px; max-height: 60vh; overflow-y: auto;">';
            
            notes.forEach((release, idx) => {
                if (idx > 0) {
                    content += '<div style="border-top: 1px solid var(--border); margin: 16px 0;"></div>';
                }
                content += `<div style="font-size: 0.8rem; color: var(--accent-purple); font-weight: 600; margin-bottom: 12px;">Version ${release.version}</div>`;
                
                release.items.forEach(item => {
                    content += `
                        <div style="display: flex; gap: 12px; margin-bottom: 14px;">
                            <span style="font-size: 1.3rem;">${item.icon}</span>
                            <div>
                                <div style="font-weight: 600; margin-bottom: 2px;">${item.title}</div>
                                <div style="color: var(--text-muted); font-size: 0.9rem;">${item.desc}</div>
                            </div>
                        </div>
                    `;
                });
            });
            
            content += `
                <button onclick="markWhatsNewSeen(); closeGenericSheet();" style="
                    width: 100%; padding: 14px; margin-top: 16px;
                    background: var(--accent-purple); border: none; border-radius: 10px;
                    color: white; font-weight: 600; font-size: 1rem; cursor: pointer;
                ">
                    ${autoTriggered ? "Let's Go!" : 'Got it'}
                </button>
            </div>`;
            
            showGenericSheet({
                title: "ðŸŽ‰ What's New",
                content: content
            });
        }
        
        function markWhatsNewSeen() {
            setLastSeenVersion(APP_VERSION);
            updateWhatsNewBadge(false);
        }
        
        function compareVersions(a, b) {
            const partsA = a.split('.').map(Number);
            const partsB = b.split('.').map(Number);
            for (let i = 0; i < 3; i++) {
                const diff = (partsA[i] || 0) - (partsB[i] || 0);
                if (diff !== 0) return diff;
            }
            return 0;
        }
        
        // ============ ABOUT ============
        function showAbout() {
            showGenericSheet({
                title: 'ðŸ§© About Game Shelf',
                content: `
                    <div style="padding: 20px; text-align: center;">
                        <div style="font-size: 4rem; margin-bottom: 16px;">ðŸŽ®</div>
                        <div style="font-size: 1.2rem; font-weight: 700; margin-bottom: 8px;">Game Shelf</div>
                        <div style="color: var(--text-muted); margin-bottom: 20px;">Version ${APP_VERSION}</div>
                        
                        <div style="text-align: left; background: var(--bg-tertiary); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                            <div style="font-weight: 600; margin-bottom: 12px;">âœ¨ Features</div>
                            <div style="color: var(--text-muted); font-size: 0.9rem; line-height: 1.6;">
                                â€¢ Track 36+ daily puzzle games<br>
                                â€¢ Compete with friends in battles<br>
                                â€¢ AI-powered hints when you're stuck<br>
                                â€¢ Earn tokens & achievements<br>
                                â€¢ Share your victories
                            </div>
                        </div>
                        
                        <div style="color: var(--text-muted); font-size: 0.85rem;">
                            Made with â¤ï¸ for puzzle enthusiasts
                        </div>
                        
                        <button onclick="closeGenericSheet();" style="
                            width: 100%; padding: 14px; margin-top: 20px;
                            background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 10px;
                            color: var(--text-primary); font-weight: 600; font-size: 1rem; cursor: pointer;
                        ">
                            Close
                        </button>
                    </div>
                `
            });
        }
        
        // ============ HELP SYSTEM ============
        let faqData = null;
        let faqSearchTimeout = null;
        let expandedCategories = new Set();
        let expandedFaqs = new Set();
        const FAQ_SEARCH_DEBOUNCE = 300;

        function getFaqData() {
            if (!faqData) {
                try {
                    const el = document.getElementById('faq-data');
                    faqData = JSON.parse(el.textContent);
                } catch (e) {
                    console.error('Failed to load FAQ data:', e);
                    faqData = { categories: [] };
                }
            }
            return faqData;
        }

        // Lightweight markdown renderer
        function renderFaqMarkdown(text) {
            if (!text) return '';
            return text
                // Bold: **text**
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                // Code: `text`
                .replace(/`(.+?)`/g, '<code>$1</code>')
                // Links: [text](url)
                .replace(/\[(.+?)\]\((.+?)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>')
                // Paragraphs: double newline
                .replace(/\n\n/g, '</p><p>')
                // Line breaks: single newline
                .replace(/\n/g, '<br>')
                // Wrap in paragraph
                .replace(/^(.+)$/s, '<p>$1</p>');
        }

        function showHelp() {
            // Reset state
            expandedFaqs.clear();
            const searchInput = document.getElementById('help-search-input');
            if (searchInput) searchInput.value = '';
            
            // Render categories
            renderHelpCategories();
            
            // Update What's New badge in help sheet
            updateHelpWhatsNewBadge();
            
            // Mark FAQ as seen (for badge)
            markFaqSeen();
            
            // Close settings menu if open
            const settingsEl = document.getElementById('settings-panel');
            if (settingsEl && settingsEl.classList.contains('active')) {
                toggleSettingsMenu();
            }
            
            // Show sheet
            document.getElementById('help-sheet-overlay').classList.add('active');
        }

        function closeHelpSheet() {
            document.getElementById('help-sheet-overlay').classList.remove('active');
        }

        function renderHelpCategories() {
            const data = getFaqData();
            const container = document.getElementById('help-content');
            if (!container) return;
            
            const sortedCategories = [...data.categories].sort((a, b) => a.order - b.order);
            
            container.innerHTML = sortedCategories.map(cat => `
                <div class="help-category ${expandedCategories.has(cat.id) ? 'expanded' : ''}" 
                     data-category="${cat.id}">
                    <div class="help-category-header" onclick="toggleHelpCategory('${cat.id}')">
                        <div class="help-category-title">
                            <span class="help-category-icon">${cat.icon}</span>
                            <span>${escapeHtml(cat.name)}</span>
                        </div>
                        <span class="help-category-arrow">â–¶</span>
                    </div>
                    <div class="help-category-questions">
                        ${cat.questions.map(faq => renderFaqItem(faq, cat.id)).join('')}
                    </div>
                </div>
            `).join('');
        }

        function renderFaqItem(faq, categoryId) {
            const isExpanded = expandedFaqs.has(faq.id);
            return `
                <div class="help-faq-item ${isExpanded ? 'expanded' : ''}" data-faq="${faq.id}">
                    <div class="help-faq-question" onclick="toggleFaq('${faq.id}', '${categoryId}')">
                        <span>${escapeHtml(faq.q)}</span>
                        <span>${isExpanded ? 'âˆ’' : '+'}</span>
                    </div>
                    <div class="help-faq-answer">
                        ${renderFaqMarkdown(faq.a)}
                    </div>
                </div>
            `;
        }

        function toggleHelpCategory(categoryId) {
            if (expandedCategories.has(categoryId)) {
                expandedCategories.delete(categoryId);
            } else {
                expandedCategories.add(categoryId);
            }
            
            const el = document.querySelector(`.help-category[data-category="${categoryId}"]`);
            if (el) {
                el.classList.toggle('expanded', expandedCategories.has(categoryId));
            }
        }

        function toggleFaq(faqId, categoryId) {
            const wasExpanded = expandedFaqs.has(faqId);
            
            if (wasExpanded) {
                expandedFaqs.delete(faqId);
            } else {
                expandedFaqs.add(faqId);
                // Track view for analytics
                trackFaqView(faqId, categoryId);
                // Track for AI Help hybrid context
                trackViewedFaq(faqId);
            }
            
            const el = document.querySelector(`.help-faq-item[data-faq="${faqId}"]`);
            if (el) {
                el.classList.toggle('expanded', !wasExpanded);
            }
        }

        function handleHelpSearch(query) {
            clearTimeout(faqSearchTimeout);
            
            faqSearchTimeout = setTimeout(() => {
                const trimmed = query.trim();
                
                if (trimmed.length === 0) {
                    renderHelpCategories();
                    return;
                }
                
                if (trimmed.length < 2) {
                    return; // Wait for more chars
                }
                
                const results = searchFaq(trimmed);
                renderSearchResults(results, trimmed);
                
                // Track search
                trackFaqSearch(trimmed, results.length);
            }, FAQ_SEARCH_DEBOUNCE);
        }

        function searchFaq(query) {
            const data = getFaqData();
            const q = query.toLowerCase();
            const results = [];
            
            data.categories.forEach(cat => {
                cat.questions.forEach(faq => {
                    const score = getFaqMatchScore(faq, q);
                    if (score > 0) {
                        results.push({
                            ...faq,
                            categoryId: cat.id,
                            categoryName: cat.name,
                            categoryIcon: cat.icon,
                            score
                        });
                    }
                });
            });
            
            return results.sort((a, b) => b.score - a.score);
        }

        function getFaqMatchScore(faq, query) {
            let score = 0;
            const qLower = faq.q.toLowerCase();
            const aLower = faq.a.toLowerCase();
            
            // Exact phrase in question = highest
            if (qLower.includes(query)) score += 10;
            
            // Exact phrase in answer = medium
            if (aLower.includes(query)) score += 5;
            
            // Keyword match
            if (faq.keywords?.some(k => k.includes(query) || query.includes(k))) {
                score += 4;
            }
            
            // Word-by-word matching
            const words = query.split(/\s+/).filter(w => w.length > 2);
            words.forEach(word => {
                if (qLower.includes(word)) score += 2;
                if (aLower.includes(word)) score += 1;
                if (faq.keywords?.some(k => k.includes(word))) score += 1;
            });
            
            return score;
        }

        function renderSearchResults(results, query) {
            const container = document.getElementById('help-content');
            if (!container) return;
            
            if (results.length === 0) {
                container.innerHTML = `
                    <div class="help-no-results">
                        <div class="help-no-results-icon">ðŸ”</div>
                        <div>No results for "${escapeHtml(query)}"</div>
                        <div style="margin-top:8px;font-size:13px;">Try different keywords or ask AI below</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = `
                <div class="help-search-results">
                    <div class="help-search-results-header">${results.length} result${results.length !== 1 ? 's' : ''}</div>
                    ${results.map(faq => `
                        <div class="help-faq-item ${expandedFaqs.has(faq.id) ? 'expanded' : ''}" data-faq="${faq.id}">
                            <div class="help-faq-question" onclick="toggleFaq('${faq.id}', '${faq.categoryId}')">
                                <span>${faq.categoryIcon} ${escapeHtml(faq.q)}</span>
                                <span>${expandedFaqs.has(faq.id) ? 'âˆ’' : '+'}</span>
                            </div>
                            <div class="help-faq-answer">
                                ${renderFaqMarkdown(faq.a)}
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Help sheet action handlers
        function helpReportIssue() {
            closeHelpSheet();
            reportIssue();
        }

        function helpStartTutorial() {
            closeHelpSheet();
            startTutorial();
        }

        function helpShowAbout() {
            closeHelpSheet();
            showAbout();
        }

        function helpShowWhatsNew() {
            closeHelpSheet();
            showWhatsNew();
        }

        // ============ AI HELP SYSTEM ============
        
        // Track which FAQs user has viewed in this session (for hybrid context)
        let viewedFaqIds = [];
        let lastHelpSearchQuery = '';
        
        function trackViewedFaq(faqId) {
            if (faqId && !viewedFaqIds.includes(faqId)) {
                viewedFaqIds.push(faqId);
                // Keep only last 5
                if (viewedFaqIds.length > 5) {
                    viewedFaqIds = viewedFaqIds.slice(-5);
                }
            }
        }
        
        function showAskAI() {
            // Get current search query if any
            const searchInput = document.getElementById('help-search-input');
            lastHelpSearchQuery = searchInput?.value?.trim() || '';
            
            // Track click
            trackAskAIClicked(lastHelpSearchQuery);
            
            // Close help sheet
            closeHelpSheet();
            
            // Check if signed in
            if (!currentUser) {
                showToast('Sign in to use AI Help', 'info');
                setTimeout(() => showAccountSheet(), 500);
                return;
            }
            
            // Check token balance
            const tokens = appData.wallet?.tokens || 0;
            if (tokens < 5) {
                showToast('Not enough tokens (need 5)', 'error');
                return;
            }
            
            // Reset AI Help sheet state
            resetAIHelp();
            
            // Pre-fill with search query if present
            if (lastHelpSearchQuery) {
                document.getElementById('ai-help-input').value = lastHelpSearchQuery;
            }
            
            // Update token display
            updateAIHelpTokenDisplay();
            
            // Show sheet
            document.getElementById('ai-help-sheet-overlay').classList.add('active');
            
            // Focus input
            setTimeout(() => {
                document.getElementById('ai-help-input').focus();
            }, 300);
        }
        
        function closeAIHelpSheet() {
            document.getElementById('ai-help-sheet-overlay').classList.remove('active');
        }
        
        function resetAIHelp() {
            // Show input, hide response
            document.getElementById('ai-help-intro').style.display = 'block';
            document.getElementById('ai-help-input-area').style.display = 'block';
            document.getElementById('ai-help-response-area').classList.remove('visible');
            
            // Clear input
            document.getElementById('ai-help-input').value = '';
            
            // Reset button state
            const btn = document.getElementById('ai-help-submit-btn');
            btn.disabled = false;
            btn.innerHTML = '<span>Ask</span><span>â†’</span>';
            
            // Update token display
            updateAIHelpTokenDisplay();
        }
        
        function updateAIHelpTokenDisplay() {
            const tokens = appData.wallet?.tokens || 0;
            const costEl = document.getElementById('ai-help-cost');
            if (costEl) {
                if (tokens < 5) {
                    costEl.innerHTML = `<span style="color: #ef4444;">ðŸ’Ž ${tokens} tokens (need 5)</span>`;
                } else {
                    costEl.textContent = `ðŸ’Ž 5 tokens (${tokens} available)`;
                }
            }
        }
        
        async function submitAIHelp() {
            const input = document.getElementById('ai-help-input');
            const question = input.value.trim();
            
            if (!question) {
                showToast('Please enter a question', 'info');
                return;
            }
            
            // Check auth again
            if (!currentUser) {
                showToast('Please sign in first', 'error');
                closeAIHelpSheet();
                return;
            }
            
            // Check tokens again
            const tokens = appData.wallet?.tokens || 0;
            if (tokens < 5) {
                showToast('Not enough tokens (need 5)', 'error');
                return;
            }
            
            // Show loading state
            const btn = document.getElementById('ai-help-submit-btn');
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner"></span><span>Thinking...</span>';
            
            // Hide intro, show response area with loading
            document.getElementById('ai-help-intro').style.display = 'none';
            document.getElementById('ai-help-response-area').classList.add('visible');
            document.getElementById('ai-help-response-text').innerHTML = '<div class="ai-help-loading"><span class="spinner"></span> Thinking...</div>';
            
            try {
                // Build hybrid context
                const hybridContext = {
                    searchQuery: lastHelpSearchQuery || null,
                    viewedFaqs: viewedFaqIds.length > 0 ? viewedFaqIds : null
                };
                
                // Call dedicated AI Help function
                const getAIHelpFn = firebase.functions().httpsCallable('getAIHelp');
                const result = await getAIHelpFn({
                    question: question,
                    hybridContext: hybridContext
                });
                
                const answer = result.data.answer || 'Sorry, I couldn\'t generate a response.';
                
                // Deduct tokens (client-side)
                const HELP_COST = 5;
                appData.wallet.tokens = (appData.wallet?.tokens || 0) - HELP_COST;
                saveData();
                renderWallet();
                
                // Show response
                document.getElementById('ai-help-response-text').innerHTML = formatAIHelpResponse(answer);
                
                // Hide input area after successful response
                document.getElementById('ai-help-input-area').style.display = 'none';
                
                // Play success sound
                playSound('success');
                
                // Log remaining
                if (result.data.remaining !== undefined) {
                    console.log(`AI Help: ${result.data.remaining} requests remaining today`);
                }
                
            } catch (error) {
                console.error('AI Help error:', error);
                
                let errorMsg = 'Something went wrong. Please try again.';
                if (error.code === 'unauthenticated') {
                    errorMsg = 'Please sign in to use AI Help.';
                } else if (error.code === 'resource-exhausted') {
                    errorMsg = error.message || 'Daily limit reached. Try again tomorrow.';
                } else if (error.message) {
                    errorMsg = error.message;
                }
                
                document.getElementById('ai-help-response-text').innerHTML = `<div class="ai-help-error">${escapeHtml(errorMsg)}</div>`;
                
                // Show input area again on error
                document.getElementById('ai-help-input-area').style.display = 'block';
            }
            
            // Reset button (but keep disabled if showing response)
            btn.innerHTML = '<span>Ask</span><span>â†’</span>';
            btn.disabled = document.getElementById('ai-help-input-area').style.display === 'none';
        }
        
        function formatAIHelpResponse(text) {
            // Simple markdown-like formatting
            let formatted = escapeHtml(text);
            
            // Bold: **text**
            formatted = formatted.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
            
            // Bullet points at start of lines
            formatted = formatted.replace(/^[â€¢\-]\s+/gm, 'â€¢ ');
            
            // Preserve line breaks
            formatted = formatted.replace(/\n/g, '<br>');
            
            return formatted;
        }

        // Badge system
        function checkFaqBadge() {
            const data = getFaqData();
            const lastSeenVersion = localStorage.getItem('faq_seen_version');
            return !lastSeenVersion || lastSeenVersion !== data.version;
        }

        function markFaqSeen() {
            const data = getFaqData();
            localStorage.setItem('faq_seen_version', data.version);
            updateHelpMenuBadge();
        }

        function updateHelpMenuBadge() {
            const badge = document.getElementById('help-menu-badge');
            const faqBadge = document.getElementById('faq-menu-badge');
            const showBadge = checkFaqBadge();
            if (badge) badge.style.display = showBadge ? 'inline-block' : 'none';
            if (faqBadge) faqBadge.style.display = showBadge ? 'inline-block' : 'none';
        }

        function updateHelpWhatsNewBadge() {
            const badge = document.getElementById('help-whats-new-badge');
            if (badge) {
                const hasUnseenUpdate = checkForUnseenWhatsNew();
                badge.style.display = hasUnseenUpdate ? 'inline-block' : 'none';
            }
        }

        function checkForUnseenWhatsNew() {
            const lastSeen = getLastSeenVersion();
            return !lastSeen || compareVersions(APP_VERSION, lastSeen) > 0;
        }

        // Analytics tracking
        function trackFaqView(faqId, categoryId) {
            if (!currentUser?.uid || !db) return;
            
            try {
                const ref = db.ref(`faq-analytics/${currentUser.uid}/views`).push();
                ref.set({
                    faqId,
                    categoryId,
                    timestamp: Date.now(),
                    appVersion: APP_VERSION
                });
            } catch (e) {
                console.error('Failed to track FAQ view:', e);
            }
        }

        function trackFaqSearch(query, resultCount) {
            if (!currentUser?.uid || !db) return;
            
            try {
                const ref = db.ref(`faq-analytics/${currentUser.uid}/searches`).push();
                ref.set({
                    query: query.substring(0, 100),
                    resultCount,
                    timestamp: Date.now(),
                    appVersion: APP_VERSION
                });
            } catch (e) {
                console.error('Failed to track FAQ search:', e);
            }
        }

        function trackAskAIClicked(searchQuery) {
            if (!currentUser?.uid || !db) return;
            
            try {
                const ref = db.ref(`faq-analytics/${currentUser.uid}/askAI`).push();
                ref.set({
                    searchQuery: searchQuery?.substring(0, 100) || null,
                    timestamp: Date.now(),
                    appVersion: APP_VERSION
                });
            } catch (e) {
                console.error('Failed to track Ask AI:', e);
            }
        }

        // ============ ISSUE REPORTING ============
        let issueScreenshotData = null;
        
        function reportIssue() {
            // Reset form
            document.getElementById('issue-report-form').reset();
            clearIssueScreenshot();
            // Show sheet
            document.getElementById('issue-sheet').classList.add('active');
        }
        
        function closeIssueSheet() {
            document.getElementById('issue-sheet').classList.remove('active');
        }
        
        function handleIssueScreenshot(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (file.size > 5 * 1024 * 1024) {
                showToast('Image too large (max 5MB)', 'error');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                issueScreenshotData = e.target.result;
                showIssueScreenshotPreview(issueScreenshotData);
            };
            reader.readAsDataURL(file);
        }
        
        function showIssueScreenshotPreview(dataUrl) {
            const preview = document.getElementById('issue-screenshot-preview');
            const placeholder = document.getElementById('issue-screenshot-placeholder');
            placeholder.style.display = 'none';
            
            // Remove existing image if any
            const existingImg = preview.querySelector('img');
            if (existingImg) existingImg.remove();
            const existingBtn = preview.querySelector('.remove-screenshot-btn');
            if (existingBtn) existingBtn.remove();
            
            const img = document.createElement('img');
            img.src = dataUrl;
            img.style.cssText = 'max-width: 100%; max-height: 200px; object-fit: contain;';
            preview.appendChild(img);
            
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-screenshot-btn';
            removeBtn.innerHTML = 'Ã—';
            removeBtn.style.cssText = 'position: absolute; top: 8px; right: 8px; background: var(--accent-red); color: white; border: none; border-radius: 50%; width: 28px; height: 28px; cursor: pointer; font-size: 1.2rem; display: flex; align-items: center; justify-content: center;';
            removeBtn.onclick = (e) => { e.stopPropagation(); clearIssueScreenshot(); };
            preview.appendChild(removeBtn);
            
            preview.style.borderStyle = 'solid';
            preview.style.borderColor = 'var(--accent-green)';
        }
        
        function clearIssueScreenshot() {
            issueScreenshotData = null;
            const preview = document.getElementById('issue-screenshot-preview');
            const placeholder = document.getElementById('issue-screenshot-placeholder');
            
            const img = preview.querySelector('img');
            if (img) img.remove();
            const btn = preview.querySelector('.remove-screenshot-btn');
            if (btn) btn.remove();
            
            placeholder.style.display = 'block';
            preview.style.borderStyle = 'dashed';
            preview.style.borderColor = 'var(--border-color)';
            document.getElementById('issue-screenshot-input').value = '';
        }
        
        // Handle paste for screenshots
        document.addEventListener('paste', (e) => {
            const issueSheet = document.getElementById('issue-sheet');
            if (!issueSheet || !issueSheet.classList.contains('active')) return;
            
            const items = e.clipboardData?.items;
            if (!items) return;
            
            for (const item of items) {
                if (item.type.startsWith('image/')) {
                    const file = item.getAsFile();
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        issueScreenshotData = ev.target.result;
                        showIssueScreenshotPreview(issueScreenshotData);
                    };
                    reader.readAsDataURL(file);
                    break;
                }
            }
        });
        
        async function submitIssueReport(event) {
            event.preventDefault();
            
            const btn = document.getElementById('issue-submit-btn');
            btn.disabled = true;
            btn.textContent = 'â³ Submitting...';
            
            // Get device info
            const ua = navigator.userAgent;
            let platform = 'unknown';
            if (/iPhone/.test(ua)) platform = 'iphone';
            else if (/iPad/.test(ua)) platform = 'ipad';
            else if (/Android/.test(ua)) platform = /Mobile/.test(ua) ? 'android' : 'android-tablet';
            else if (/Mac/.test(ua)) platform = /Chrome/.test(ua) ? 'mac-chrome' : 'mac';
            else if (/Windows/.test(ua)) platform = 'windows';
            
            const issue = {
                type: document.getElementById('issue-type').value,
                section: document.getElementById('issue-section').value,
                severity: document.getElementById('issue-severity').value,
                title: document.getElementById('issue-title').value.trim(),
                description: document.getElementById('issue-description').value.trim() || null,
                screenshotUrl: issueScreenshotData || null,
                platform: platform,
                reporterName: appData.displayName || 'Anonymous',
                status: 'open',
                timestamp: Date.now(),
                appVersion: document.querySelector('meta[name="version"]')?.content || 'unknown',
                source: 'pwa'
            };
            
            // Include debug context if Feedback mode is enabled and checkbox is checked
            const includeDebugLog = document.getElementById('include-debug-log')?.checked;
            if (isFeedbackModeEnabled() && includeDebugLog) {
                issue.debugContext = captureDebugContext();
                issue.source = 'pwa-feedback';
            }
            
            // Log the submission
            feedbackLog('Submitted feedback: ' + issue.type + ' - ' + issue.title);
            
            // Try Firebase, but always acknowledge regardless of result
            try {
                await firebase.database().ref('reported-issues').push(issue);
            } catch (e) {
                console.log('Issue saved locally - will sync later');
                // Store locally as backup
                const pending = JSON.parse(localStorage.getItem('pendingIssues') || '[]');
                pending.push(issue);
                localStorage.setItem('pendingIssues', JSON.stringify(pending));
            }
            
            // Always show success and close
            showToast('âœ… Thanks for the feedback!', 'success');
            document.getElementById('issue-report-form').reset();
            clearIssueScreenshot();
            issueScreenshotData = null;
            
            // Hide debug section
            const debugSection = document.getElementById('feedback-debug-section');
            if (debugSection) debugSection.style.display = 'none';
            
            closeIssueSheet();
            btn.disabled = false;
            btn.textContent = 'ðŸ“¤ Submit';
        }
        
        // ============ MERCH STORE ============
        
        // Sync any pending issues that were stored locally
        async function syncPendingIssues() {
            if (!currentUser || typeof firebase === 'undefined') return;
            
            const localIssues = JSON.parse(localStorage.getItem('pendingIssues') || '[]');
            if (localIssues.length === 0) return;
            
            console.log(`Syncing ${localIssues.length} pending issues...`);
            const synced = [];
            
            for (const issue of localIssues) {
                try {
                    // Update reporter info now that user is logged in
                    issue.reporterId = currentUser.uid;
                    issue.reporterName = currentUser.displayName || currentUser.email?.split('@')[0] || issue.reporterName;
                    issue.reporterEmail = currentUser.email || issue.reporterEmail;
                    
                    await firebase.database().ref('reported-issues').push(issue);
                    synced.push(issue);
                } catch (e) {
                    console.error('Failed to sync issue:', e);
                }
            }
            
            if (synced.length > 0) {
                // Remove synced issues from local storage
                const remaining = localIssues.filter(i => !synced.includes(i));
                localStorage.setItem('pendingIssues', JSON.stringify(remaining));
                showToast(`âœ… Synced ${synced.length} issue${synced.length > 1 ? 's' : ''} to cloud`);
                console.log(`Synced ${synced.length} issues to Firebase`);
            }
        }
        
        // Call syncPendingIssues when user logs in (add to auth state change handler)
        
        const MERCH_CATALOG = [
            // Virtual Rewards
            { id: 'frame-bronze', name: 'Bronze Profile Frame', category: 'virtual', image: 'ðŸ¥‰', description: 'Sleek bronze frame', reward: true, earnedBy: 'Win any Brain Battle' },
            { id: 'frame-silver', name: 'Silver Profile Frame', category: 'virtual', image: 'ðŸ¥ˆ', description: 'Polished silver frame', reward: true, earnedBy: 'Win 5 Brain Battles' },
            { id: 'frame-gold', name: 'Gold Profile Frame', category: 'virtual', image: 'ðŸ¥‡', description: 'Prestigious gold frame', reward: true, earnedBy: 'Win a tournament' },
            { id: 'badge-champion', name: 'Champion Badge', category: 'virtual', image: 'ðŸ†', description: 'Brain Battle Champion', reward: true, earnedBy: 'Top 3 in tournament' },
            { id: 'badge-streak', name: 'Streak Master Badge', category: 'virtual', image: 'ðŸ”¥', description: 'Daily puzzle dedication', reward: true, earnedBy: '30-day streak' },
            { id: 'title-warrior', name: '"Brain Warrior" Title', category: 'virtual', image: 'âš”ï¸', description: 'Title under your name', reward: true, earnedBy: 'Win 10 Brain Battles' },
            // Physical Gifts
            { id: 'goody-15', name: '$15 Gift of Choice', category: 'physical', image: 'ðŸŽ', description: '50+ gifts: snacks, treats', price: 15 },
            { id: 'goody-30', name: '$30 Gift of Choice', category: 'physical', image: 'ðŸŽ', description: '100+ gifts: coffee, candles', price: 30, popular: true },
            { id: 'goody-50', name: '$50 Gift of Choice', category: 'physical', image: 'ðŸŽ', description: '150+ gifts: premium items', price: 50 },
            { id: 'goody-75', name: '$75 Gift of Choice', category: 'physical', image: 'ðŸŽ', description: '200+ gifts: tech, apparel', price: 75 },
            { id: 'goody-100', name: '$100 Gift of Choice', category: 'physical', image: 'ðŸŽ', description: '250+ gifts: luxury items', price: 100 }
        ];
        
        let currentMerchFilter = 'all';
        
        function showMerchStore() {
            document.getElementById('merch-balance').textContent = appData.wallet?.coins || 0;
            renderMerchCatalog();
            document.getElementById('merch-sheet').classList.add('active');
        }
        
        function closeMerchStore() {
            document.getElementById('merch-sheet').classList.remove('active');
        }
        
        function filterMerch(filter) {
            currentMerchFilter = filter;
            document.querySelectorAll('.merch-tab').forEach(tab => {
                tab.classList.toggle('active', tab.textContent.toLowerCase().includes(filter) || (filter === 'all' && tab.textContent === 'All'));
            });
            renderMerchCatalog();
        }
        
        function renderMerchCatalog() {
            const container = document.getElementById('merch-catalog');
            const coins = appData.wallet?.coins || 0;
            const owned = appData.ownedMerch || [];
            
            let items = MERCH_CATALOG;
            if (currentMerchFilter === 'virtual') {
                items = items.filter(i => i.category === 'virtual');
            } else if (currentMerchFilter === 'physical') {
                items = items.filter(i => i.category === 'physical');
            }
            
            const virtualItems = items.filter(i => i.category === 'virtual');
            const physicalItems = items.filter(i => i.category === 'physical');
            
            let html = '';
            
            if (virtualItems.length > 0 && currentMerchFilter !== 'physical') {
                html += `<div class="merch-section-header">ðŸ† Rewards<br><span class="merch-earn-hint">Earned through battles & achievements</span></div>`;
                virtualItems.forEach(item => {
                    const isOwned = owned.includes(item.id);
                    html += `
                        <div class="merch-card ${isOwned ? 'owned' : ''}" onclick="showMerchDetails('${item.id}')">
                            <div class="merch-image">${item.image}</div>
                            <div class="merch-info">
                                <div class="merch-name">${item.name}</div>
                                <div class="merch-desc">${item.description}</div>
                                <div class="merch-footer">
                                    ${isOwned ? '<span class="merch-owned">âœ“ Owned</span>' : `<span class="merch-earn-hint">${item.earnedBy}</span>`}
                                </div>
                            </div>
                        </div>
                    `;
                });
            }
            
            if (physicalItems.length > 0 && currentMerchFilter !== 'virtual') {
                html += `<div class="merch-section-header">ðŸŽ Gift of Choice<br><span style="font-size: 0.75rem; font-weight: 400; color: var(--text-muted);">Redeem coins for real gifts via Goody</span></div>`;
                physicalItems.forEach(item => {
                    const canAfford = coins >= item.price;
                    html += `
                        <div class="merch-card ${canAfford ? '' : 'unaffordable'}" onclick="showMerchDetails('${item.id}')">
                            <div class="merch-image">${item.image}${item.popular ? 'â­' : ''}</div>
                            <div class="merch-info">
                                <div class="merch-name">${item.name}</div>
                                <div class="merch-desc">${item.description}</div>
                                <div class="merch-footer">
                                    <span class="merch-price ${canAfford ? '' : 'too-expensive'}">ðŸª™ ${item.price}</span>
                                </div>
                            </div>
                        </div>
                    `;
                });
            }
            
            container.innerHTML = html || '<div style="grid-column: 1/-1; text-align: center; color: var(--text-muted); padding: 20px;">No items found</div>';
        }
        
        function showMerchDetails(itemId) {
            const item = MERCH_CATALOG.find(m => m.id === itemId);
            if (!item) return;
            
            const coins = appData.wallet?.coins || 0;
            const owned = (appData.ownedMerch || []).includes(itemId);
            
            let content = `
                <div style="padding: 20px; text-align: center;">
                    <div style="font-size: 4rem; margin-bottom: 12px;">${item.image}</div>
                    <div style="font-size: 1.2rem; font-weight: 700; margin-bottom: 8px;">${item.name}</div>
                    <div style="color: var(--text-muted); margin-bottom: 20px;">${item.description}</div>
            `;
            
            if (item.category === 'virtual') {
                // Virtual item (earned, not purchased)
                if (owned) {
                    content += `
                        <div style="background: var(--accent-green); color: white; padding: 12px; border-radius: 10px; font-weight: 600;">
                            âœ“ You own this!
                        </div>
                    `;
                } else {
                    content += `
                        <div style="background: var(--bg-tertiary); padding: 16px; border-radius: 10px; text-align: left;">
                            <div style="font-weight: 600; margin-bottom: 4px;">How to earn:</div>
                            <div style="color: var(--text-muted);">${item.earnedBy}</div>
                        </div>
                    `;
                }
            } else {
                // Physical item (purchased with coins)
                if (owned) {
                    content += `
                        <div style="background: var(--accent-green); color: white; padding: 12px; border-radius: 10px; font-weight: 600;">
                            âœ“ Already redeemed!
                        </div>
                    `;
                } else if (coins >= item.price) {
                    content += `
                        <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 10px; margin-bottom: 16px;">
                            <span style="font-size: 1.1rem;">ðŸª™ ${item.price}</span>
                            <span style="color: var(--text-muted); margin-left: 8px;">You have: ðŸª™ ${coins}</span>
                        </div>
                        <button onclick="closeGenericSheet(); confirmRedeemMerch('${itemId}');" style="
                            width: 100%; padding: 14px;
                            background: linear-gradient(135deg, var(--accent-gold), #e6c200);
                            border: none; border-radius: 10px;
                            color: #1a1a2e; font-weight: 600; font-size: 1rem; cursor: pointer;
                        ">
                            Redeem Now
                        </button>
                    `;
                } else {
                    content += `
                        <div style="background: var(--bg-tertiary); padding: 16px; border-radius: 10px;">
                            <div style="font-size: 1.1rem; margin-bottom: 8px;">ðŸª™ ${item.price} needed</div>
                            <div style="color: var(--accent-red);">You have: ðŸª™ ${coins}</div>
                            <div style="color: var(--text-muted); font-size: 0.85rem; margin-top: 8px;">
                                Need ${item.price - coins} more coins
                            </div>
                        </div>
                    `;
                }
            }
            
            content += `
                <button onclick="closeGenericSheet();" style="
                    width: 100%; padding: 12px; margin-top: 12px;
                    background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 10px;
                    color: var(--text-primary); font-size: 0.95rem; cursor: pointer;
                ">
                    Close
                </button>
            </div>`;
            
            showGenericSheet({
                title: `${item.image} ${item.name}`,
                content: content
            });
        }
        
        function confirmRedeemMerch(itemId) {
            const item = MERCH_CATALOG.find(m => m.id === itemId);
            if (!item) return;
            
            showConfirmModal({
                icon: 'ðŸŽ',
                title: 'Redeem Gift?',
                message: `Redeem ${item.name} for ðŸª™ ${item.price} coins?`,
                confirmText: 'Redeem',
                confirmStyle: 'primary',
                onConfirm: () => redeemMerch(itemId)
            });
        }
        
        function redeemMerch(itemId) {
            const item = MERCH_CATALOG.find(m => m.id === itemId);
            if (!item || item.category !== 'physical') return;
            
            const coins = appData.wallet?.coins || 0;
            if (coins < item.price) {
                showToast('Not enough coins', 'error');
                return;
            }
            
            // Deduct coins
            appData.wallet.coins -= item.price;
            
            // Add to owned
            if (!appData.ownedMerch) appData.ownedMerch = [];
            appData.ownedMerch.push(itemId);
            
            saveData();
            renderWallet();
            document.getElementById('merch-balance').textContent = appData.wallet.coins;
            renderMerchCatalog();
            
            showToast(`ðŸŽ Redeemed ${item.name}!`);
            
            // Show success modal
            showGenericSheet({
                title: 'ðŸŽ‰ Gift Redeemed!',
                content: `
                    <div style="padding: 20px; text-align: center;">
                        <div style="font-size: 4rem; margin-bottom: 16px;">${item.image}</div>
                        <div style="font-size: 1.1rem; font-weight: 600; margin-bottom: 16px;">${item.name}</div>
                        
                        <div style="background: var(--bg-tertiary); padding: 16px; border-radius: 12px; margin-bottom: 20px; text-align: left;">
                            <div style="color: var(--text-muted); font-size: 0.9rem; line-height: 1.5;">
                                ðŸ“§ You'll receive an email from Goody to choose your gift.<br><br>
                                <span style="font-size: 0.8rem; color: var(--text-muted);">(Demo mode - no actual email sent)</span>
                            </div>
                        </div>
                        
                        <button onclick="closeGenericSheet();" style="
                            width: 100%; padding: 14px;
                            background: var(--accent-purple); border: none; border-radius: 10px;
                            color: white; font-weight: 600; font-size: 1rem; cursor: pointer;
                        ">
                            Awesome!
                        </button>
                    </div>
                `
            });
        }
        
        // ============ UI RENDERING ============
        
        // ============ ACHIEVEMENTS ============
        const ACHIEVEMENTS = [
            { id: 'first-game', name: 'First Steps', icon: 'ðŸ‘¶', desc: 'Log your first game', check: (d) => getTotalGamesPlayed(d) >= 1 },
            { id: 'streak-3', name: 'Hat Trick', icon: 'ðŸŽ©', desc: '3-day streak', check: (d) => getMaxStreak(d) >= 3 },
            { id: 'streak-7', name: 'Week Warrior', icon: 'âš”ï¸', desc: '7-day streak', check: (d) => getMaxStreak(d) >= 7 },
            { id: 'streak-30', name: 'Monthly Master', icon: 'ðŸ‘‘', desc: '30-day streak', check: (d) => getMaxStreak(d) >= 30 },
            { id: 'games-5', name: 'Collector', icon: 'ðŸ“š', desc: 'Track 5 different games', check: (d) => Object.keys(d.games || {}).length >= 5 },
            { id: 'games-10', name: 'Enthusiast', icon: 'ðŸŽ®', desc: 'Track 10 different games', check: (d) => Object.keys(d.games || {}).length >= 10 },
            { id: 'total-10', name: 'Getting Started', icon: 'ðŸŒ±', desc: 'Complete 10 games total', check: (d) => getTotalGamesPlayed(d) >= 10 },
            { id: 'total-50', name: 'Dedicated', icon: 'ðŸ’ª', desc: 'Complete 50 games total', check: (d) => getTotalGamesPlayed(d) >= 50 },
            { id: 'total-100', name: 'Centurion', icon: 'ðŸ›ï¸', desc: 'Complete 100 games total', check: (d) => getTotalGamesPlayed(d) >= 100 },
            { id: 'early-bird', name: 'Early Bird', icon: 'ðŸ¦', desc: 'Log a game before 7 AM', check: (d) => d.achievements?.['early-bird'] },
            { id: 'night-owl', name: 'Night Owl', icon: 'ðŸ¦‰', desc: 'Log a game after 11 PM', check: (d) => d.achievements?.['night-owl'] },
            { id: 'social', name: 'Social Butterfly', icon: 'ðŸ¦‹', desc: 'Share your results', check: (d) => d.achievements?.['social'] },
            { id: 'cloud-sync', name: 'Cloud Gamer', icon: 'â˜ï¸', desc: 'Sign in and sync', check: (d) => d.achievements?.['cloud-sync'] },
            { id: 'battle-join', name: 'Challenger', icon: 'âš”ï¸', desc: 'Join a Brain Battle', check: (d) => d.achievements?.['battle-join'] },
        ];
        
        function getTotalGamesPlayed(data) {
            let total = 0;
            Object.values(data.stats || {}).forEach(stat => {
                total += Number(stat.gamesPlayed) || 0;
            });
            return isNaN(total) ? 0 : total;
        }
        
        function getMaxStreak(data) {
            const statsObj = data?.stats || appData?.stats || {};
            let maxStreak = 0;
            Object.values(statsObj).forEach(stat => {
                const current = Number(stat.currentStreak) || 0;
                const max = Number(stat.maxStreak) || 0;
                if (current > maxStreak) maxStreak = current;
                if (max > maxStreak) maxStreak = max;
            });
            return isNaN(maxStreak) ? 0 : maxStreak;
        }
        
        // v1.3.1: Get highest CURRENT streak (not all-time best) for home screen display
        function getCurrentMaxStreak(data) {
            const statsObj = data?.stats || appData?.stats || {};
            let maxCurrent = 0;
            Object.values(statsObj).forEach(stat => {
                const current = Number(stat.currentStreak) || 0;
                if (current > maxCurrent) maxCurrent = current;
            });
            return isNaN(maxCurrent) ? 0 : maxCurrent;
        }
        
        // v1.3.0: Validate streaks on app startup
        // Reset any streaks where the user missed a day (lastPlayed is not today or yesterday)
        function validateStreaksOnStartup() {
            if (!appData.stats || Object.keys(appData.stats).length === 0) return;
            
            const today = getTodayString();
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const yesterdayStr = `${yesterday.getFullYear()}-${String(yesterday.getMonth() + 1).padStart(2, '0')}-${String(yesterday.getDate()).padStart(2, '0')}`;
            
            let resetCount = 0;
            
            Object.keys(appData.stats).forEach(gameId => {
                const stats = appData.stats[gameId];
                if (stats.currentStreak > 0 && stats.lastPlayed) {
                    // If lastPlayed is not today and not yesterday, streak is broken
                    if (stats.lastPlayed !== today && stats.lastPlayed !== yesterdayStr) {
                        console.log(`ðŸ”¥ Resetting broken streak for ${gameId}: was ${stats.currentStreak}, lastPlayed ${stats.lastPlayed}`);
                        stats.currentStreak = 0;
                        resetCount++;
                    }
                }
            });
            
            if (resetCount > 0) {
                console.log(`ðŸ”¥ Reset ${resetCount} broken streak(s) on startup`);
                saveData();
            }
        }
        
        function checkTimeAchievements() {
            const hour = new Date().getHours();
            if (hour < 7 && !appData.achievements?.['early-bird']) {
                unlockAchievement('early-bird');
            }
            if (hour >= 23 && !appData.achievements?.['night-owl']) {
                unlockAchievement('night-owl');
            }
        }
        
        function unlockAchievement(id) {
            if (!appData.achievements) appData.achievements = {};
            if (appData.achievements[id]) return; // Already unlocked
            
            appData.achievements[id] = getTodayString();
            const achievement = ACHIEVEMENTS.find(a => a.id === id);
            if (achievement) {
                playSound('achievement');
                showToast(`ðŸ† ${achievement.icon} ${achievement.name} unlocked!`);
                
                // Log activity
                logActivity('achievement-unlocked', {
                    achievementId: id,
                    name: achievement.name,
                    icon: achievement.icon
                });
                
                // Award coins
                const coins = getAchievementCoins(id);
                if (coins > 0) {
                    appData.wallet.coins = (appData.wallet?.coins || 0) + coins;
                    setTimeout(() => showToast(`+${coins} coins!`), 1000);
                }
            }
            saveData();
            renderAchievements();
        }
        
        function getAchievementCoins(id) {
            const hard = ['streak-30', 'total-100'];
            const medium = ['streak-7', 'total-50', 'games-10', 'early-bird', 'night-owl'];
            if (hard.includes(id)) return 50;
            if (medium.includes(id)) return 20;
            return 10;
        }
        
        function checkAndUnlockAchievements() {
            if (!appData.achievements) appData.achievements = {};
            
            let newUnlocks = [];
            
            ACHIEVEMENTS.forEach(achievement => {
                if (!appData.achievements[achievement.id] && achievement.check(appData)) {
                    appData.achievements[achievement.id] = getTodayString();
                    newUnlocks.push(achievement);
                }
            });
            
            if (newUnlocks.length > 0) {
                saveData();
                renderAchievements();
                
                newUnlocks.forEach((a, i) => {
                    setTimeout(() => {
                        showToast(`ðŸ† ${a.icon} ${a.name} unlocked!`);
                        const coins = getAchievementCoins(a.id);
                        if (coins > 0) {
                            appData.wallet.coins = (appData.wallet?.coins || 0) + coins;
                            renderWallet();
                        }
                    }, i * 1500);
                });
            }
        }
        
        function showAchievements() {
            renderAchievements();
            document.getElementById('achievements-sheet').classList.add('active');
        }
        
        function closeAchievements() {
            document.getElementById('achievements-sheet').classList.remove('active');
        }
        
        function renderAchievements() {
            const grid = document.getElementById('achievements-grid');
            const countEl = document.getElementById('achievements-count');
            const fillEl = document.getElementById('achievements-fill');
            
            if (!grid) return;
            
            let unlockedCount = 0;
            
            grid.innerHTML = ACHIEVEMENTS.map(achievement => {
                const isUnlocked = appData.achievements && appData.achievements[achievement.id];
                if (isUnlocked) unlockedCount++;
                
                return `
                    <div class="achievement-card ${isUnlocked ? 'unlocked' : 'locked'}">
                        <span class="achievement-icon">${achievement.icon}</span>
                        <div class="achievement-name">${achievement.name}</div>
                        <div class="achievement-desc">${isUnlocked ? 'âœ“ Unlocked' : achievement.desc}</div>
                    </div>
                `;
            }).join('');
            
            const percentage = ACHIEVEMENTS.length > 0 ? (unlockedCount / ACHIEVEMENTS.length) * 100 : 0;
            if (fillEl) fillEl.style.width = (isNaN(percentage) ? 0 : percentage) + '%';
            if (countEl) countEl.textContent = `${unlockedCount}/${ACHIEVEMENTS.length}`;
        }
        
        // ============ BATTLES ============
        let userBattles = [];
        let currentBattleId = null;
        
        // Game-specific data collection requirements
        const GAME_RULES = {
            wordle: {
                name: 'Wordle',
                icon: 'ðŸŸ©',
                howToSubmit: 'Paste share text (tap Share â†’ Copy) or use Quick Log',
                validScore: 'Score 1-6 or X (fail)',
                perfectScore: '1/6 or 2/6',
                dailyReset: '12:00 AM ET',
                example: 'Wordle 1,234 3/6'
            },
            connections: {
                name: 'Connections',
                icon: 'ðŸ”—',
                howToSubmit: 'Paste share text with colored grid',
                validScore: 'All 4 categories found',
                perfectScore: 'No mistakes (4 correct guesses)',
                dailyReset: '12:00 AM ET',
                example: 'Connections Puzzle #123 ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨...'
            },
            strands: {
                name: 'Strands',
                icon: 'ðŸ§µ',
                howToSubmit: 'Paste share text showing hints used',
                validScore: 'Puzzle completed',
                perfectScore: '0 hints used',
                dailyReset: '2:00 AM ET',
                example: 'Strands #123 ðŸ”µðŸ”µðŸ”µðŸŸ¡'
            },
            mini: {
                name: 'Mini Crossword',
                icon: 'ðŸ“',
                howToSubmit: 'Paste completion message with time',
                validScore: 'Any completion time',
                perfectScore: 'Under 30 seconds',
                dailyReset: '10:00 PM ET (day before)',
                example: 'I solved...Mini in 1:23'
            },
            'spelling-bee': {
                name: 'Spelling Bee',
                icon: 'ðŸ',
                howToSubmit: 'Paste share text showing rank achieved',
                validScore: 'Any rank (Beginner to Queen Bee)',
                perfectScore: 'Queen Bee (all words found)',
                dailyReset: '3:00 AM ET',
                example: 'Spelling Bee: Genius!'
            },
            quordle: {
                name: 'Quordle',
                icon: '4ï¸âƒ£',
                howToSubmit: 'Paste share text with grid',
                validScore: 'At least 1 of 4 words found',
                perfectScore: 'All 4 words found',
                dailyReset: '12:00 AM ET',
                example: 'Daily Quordle 123'
            }
        };
        
        // Battle type definitions with scoring logic
        const BATTLE_TYPES = {
            'total-score': {
                name: 'Total Score',
                icon: 'ðŸ†',
                shortDesc: 'Highest combined score wins',
                scoring: (result) => result.numericScore || 0,
                getRules: (games, duration) => [
                    `Play any of the selected games each day for ${duration} days`,
                    'Your score from each game adds to your total',
                    'Higher scores = more points (e.g., Wordle 1/6 = 30 pts, 6/6 = 5 pts)',
                    'You can play each game once per day',
                    'Highest total score at the end wins!'
                ]
            },
            'streak': {
                name: 'Streak Challenge',
                icon: 'ðŸ”¥',
                shortDesc: 'Daily consistency matters',
                scoring: (result, dayStreak) => (result.numericScore || 0) + (dayStreak * 10),
                getRules: (games, duration) => [
                    `Play ALL selected games EVERY day for ${duration} days`,
                    'Each day you complete all games = +10 bonus points',
                    'âš ï¸ Missing ANY game on a day = streak broken, lose bonus',
                    'Must log results before midnight (your local time)',
                    'Final score = game scores + streak bonuses'
                ]
            },
            'wins': {
                name: 'Most Wins',
                icon: 'âœ…',
                shortDesc: 'Each game won = 1 point',
                scoring: (result) => result.won ? 1 : 0,
                getRules: (games, duration) => [
                    'Each game you WIN = 1 point',
                    'Losses and fails do NOT count against you',
                    'Win conditions vary by game:',
                    '  â€¢ Wordle: Solve in 6 guesses or less',
                    '  â€¢ Connections: Find all 4 categories',
                    '  â€¢ Mini: Complete the puzzle',
                    'Most total wins at the end wins!'
                ]
            },
            'perfect': {
                name: 'Perfect Hunter',
                icon: 'ðŸŽ¯',
                shortDesc: 'Only perfect scores count',
                scoring: (result) => result.meta?.perfect ? 1 : 0,
                getRules: (games, duration) => [
                    'â­ ONLY perfect scores count!',
                    'Perfect score definitions:',
                    '  â€¢ Wordle: 1/6 or 2/6',
                    '  â€¢ Connections: No mistakes (4 correct guesses)',
                    '  â€¢ Strands: 0 hints used',
                    '  â€¢ Mini: Under 30 seconds',
                    '  â€¢ Quordle: All 4 words, no fails',
                    'Non-perfect results = 0 points',
                    'Most perfect games wins!'
                ]
            }
        };
        
        // Generate full rules text for a battle
        function generateBattleRules(battleType, selectedGames, duration, callbackFn = 'updateRulesAgreement') {
            const type = BATTLE_TYPES[battleType] || BATTLE_TYPES['total-score'];
            const games = selectedGames.map(g => GAME_RULES[g]).filter(Boolean);
            
            let rules = [];
            
            // Header
            rules.push(`<div class="rules-section-title">ðŸ“‹ ${type.name} Rules</div>`);
            rules.push('<div class="rules-list">');
            type.getRules(selectedGames, duration).forEach(r => {
                rules.push(`<div class="rules-item">${r}</div>`);
            });
            rules.push('</div>');
            
            // Data submission requirements
            rules.push('<div class="rules-section-title">ðŸ“¤ How to Submit Results</div>');
            rules.push('<div class="rules-list">');
            rules.push('<div class="rules-item">Log results in Game Shelf using ONE of these methods:</div>');
            rules.push('<div class="rules-item">  1. <b>Paste share text</b> - Copy from game, paste in Log tab</div>');
            rules.push('<div class="rules-item">  2. <b>Quick Log</b> - Tap game, select your score</div>');
            rules.push('<div class="rules-item">  3. <b>Auto-detect</b> - Copy share text, open app</div>');
            rules.push('</div>');
            
            // Game-specific requirements
            if (games.length > 0) {
                rules.push('<div class="rules-section-title">ðŸŽ® Game Requirements</div>');
                games.forEach(game => {
                    rules.push(`<div class="rules-game">`);
                    rules.push(`<div class="rules-game-header">${game.icon} ${game.name}</div>`);
                    rules.push(`<div class="rules-game-detail"><b>Submit:</b> ${game.howToSubmit}</div>`);
                    rules.push(`<div class="rules-game-detail"><b>Valid:</b> ${game.validScore}</div>`);
                    if (battleType === 'perfect') {
                        rules.push(`<div class="rules-game-detail"><b>Perfect:</b> ${game.perfectScore}</div>`);
                    }
                    rules.push(`<div class="rules-game-detail"><b>Resets:</b> ${game.dailyReset}</div>`);
                    rules.push(`</div>`);
                });
            }
            
            // Disqualification rules
            rules.push('<div class="rules-section-title">âš ï¸ Fair Play</div>');
            rules.push('<div class="rules-list rules-warning">');
            rules.push('<div class="rules-item">Playing a game but NOT logging it = does not count</div>');
            rules.push('<div class="rules-item">Logging fake/edited results = immediate disqualification</div>');
            rules.push('<div class="rules-item">Logging after battle ends = does not count</div>');
            if (battleType === 'streak') {
                rules.push('<div class="rules-item">Missing a day = streak bonus lost for entire battle</div>');
            }
            rules.push('</div>');
            
            // Honor system notice
            rules.push('<div class="rules-section-title">ðŸ¤ Honor System</div>');
            rules.push('<div class="rules-list" style="background: var(--bg-tertiary); border-radius: 8px; padding: 10px;">');
            rules.push('<div class="rules-item" style="font-style: italic;">Battles run on trust, like a friendly golf wager or office pool. There\'s no automated verification - the community polices itself. Play fair!</div>');
            rules.push('</div>');
            
            // Agreement
            rules.push('<div class="rules-agreement">');
            rules.push('<label class="rules-checkbox-label">');
            rules.push(`<input type="checkbox" id="rules-agree-checkbox">`);
            rules.push('<span>I understand and agree to these rules</span>');
            rules.push('</label>');
            rules.push('</div>');
            
            return rules.join('');
        }
        
        function showCreateBattle() {
            if (!currentUser) {
                showToast('Sign in to create battles', 'error');
                return;
            }
            // Reset form
            document.getElementById('battle-name-input').value = '';
            document.getElementById('battle-duration').value = '3';
            document.getElementById('battle-entry-fee').value = '0';
            
            // Reset visibility toggle to private
            const publicToggle = document.getElementById('battle-public-toggle');
            if (publicToggle) {
                publicToggle.checked = false;
                updateVisibilityDisplay(false);
            }
            
            // Reset selected games to defaults
            battleSelectedGames = ['wordle', 'connections'];
            updateSelectedGamesPreview();
            
            // Reset battle type to total-score
            document.querySelectorAll('.battle-type-option').forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.type === 'total-score');
            });
            
            // Generate initial rules
            setTimeout(() => {
                updateBattleRulesPreview();
            }, 100);
            
            document.getElementById('create-battle-sheet').classList.add('active');
        }
        
        // Toggle battle visibility (public/private)
        function toggleBattleVisibility() {
            const toggle = document.getElementById('battle-public-toggle');
            if (toggle) {
                toggle.checked = !toggle.checked;
                updateVisibilityDisplay(toggle.checked);
            }
        }
        
        function updateVisibilityDisplay(isPublic) {
            const icon = document.getElementById('battle-visibility-icon');
            const text = document.getElementById('battle-visibility-text');
            const desc = document.getElementById('battle-visibility-desc');
            const stakeSelect = document.getElementById('battle-stake-select');
            const amountContainer = document.getElementById('stake-amount-container');
            const integrityNotice = document.getElementById('battle-integrity-notice');
            
            if (isPublic) {
                icon.textContent = 'ðŸŒ';
                text.textContent = 'Public Battle';
                desc.textContent = 'Anyone can find and join';
                
                // v1.2.77: Force friendly for public battles
                if (stakeSelect) {
                    stakeSelect.style.opacity = '0.5';
                    stakeSelect.style.pointerEvents = 'none';
                    // Select friendly option
                    const friendlyOption = stakeSelect.querySelector('[data-stake="friendly"]');
                    if (friendlyOption) {
                        document.querySelectorAll('.battle-stake-option').forEach(opt => {
                            opt.classList.remove('selected');
                            opt.style.border = '2px solid transparent';
                        });
                        friendlyOption.classList.add('selected');
                        friendlyOption.style.border = '2px solid var(--accent-purple)';
                    }
                }
                if (amountContainer) {
                    amountContainer.style.display = 'none';
                }
                if (integrityNotice) {
                    integrityNotice.innerHTML = 'ðŸŒ Public battles are always friendly - no wagering with strangers';
                }
            } else {
                icon.textContent = 'ðŸ”’';
                text.textContent = 'Private Battle';
                desc.textContent = 'Only people with code can join';
                
                // v1.2.77: Re-enable stake selection
                if (stakeSelect) {
                    stakeSelect.style.opacity = '1';
                    stakeSelect.style.pointerEvents = 'auto';
                }
                if (integrityNotice) {
                    integrityNotice.innerHTML = 'ðŸ¤ Battles run on trust - like a friendly golf wager. Play fair!';
                }
            }
        }
        
        function selectBattleType(el) {
            // Remove selected from all
            document.querySelectorAll('.battle-type-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            // Add to clicked one
            el.classList.add('selected');
            
            // Update rules preview
            updateBattleRulesPreview();
        }
        
        // v1.2.77: Stake type selection (Friendly/Coins/Tokens)
        function selectBattleStake(el) {
            // Remove selected styling from all options
            document.querySelectorAll('.battle-stake-option').forEach(opt => {
                opt.classList.remove('selected');
                opt.style.border = '2px solid transparent';
            });
            // Add to clicked one
            el.classList.add('selected');
            el.style.border = '2px solid var(--accent-purple)';
            
            const stakeType = el.dataset.stake;
            const amountContainer = document.getElementById('stake-amount-container');
            const amountInput = document.getElementById('battle-stake-amount');
            const amountIcon = document.getElementById('stake-amount-icon');
            const amountLabel = document.getElementById('stake-amount-label');
            const legacyFee = document.getElementById('battle-entry-fee');
            
            if (stakeType === 'friendly') {
                amountContainer.style.display = 'none';
                legacyFee.value = '0';
            } else if (stakeType === 'coins') {
                amountContainer.style.display = 'block';
                amountIcon.textContent = 'ðŸª™';
                amountLabel.textContent = 'coins (max 5)';
                amountInput.min = 1;
                amountInput.max = 5;
                amountInput.value = Math.min(amountInput.value || 1, 5);
                validateStakeAmount();
            } else if (stakeType === 'tokens') {
                amountContainer.style.display = 'block';
                amountIcon.textContent = 'ðŸŽŸï¸';
                amountLabel.textContent = 'tokens (max 500)';
                amountInput.min = 1;
                amountInput.max = 500;
                amountInput.value = Math.min(amountInput.value || 10, 500);
                validateStakeAmount();
            }
            
            updateBattleRulesPreview();
        }
        
        function validateStakeAmount() {
            const selectedStake = document.querySelector('.battle-stake-option.selected');
            const stakeType = selectedStake ? selectedStake.dataset.stake : 'friendly';
            const amountInput = document.getElementById('battle-stake-amount');
            const legacyFee = document.getElementById('battle-entry-fee');
            
            if (stakeType === 'friendly') {
                legacyFee.value = '0';
                return;
            }
            
            let amount = parseInt(amountInput.value) || 1;
            const max = stakeType === 'coins' ? 5 : 500;
            
            // Clamp value
            if (amount < 1) amount = 1;
            if (amount > max) amount = max;
            amountInput.value = amount;
            
            // Store in a format we can parse later: "coins:3" or "tokens:100"
            // For now, store negative for tokens to differentiate
            if (stakeType === 'coins') {
                legacyFee.value = amount.toString();
            } else {
                // Use negative to indicate tokens (hacky but backward compatible)
                legacyFee.value = (-amount).toString();
            }
        }
        
        function getBattleStakeInfo() {
            const selectedStake = document.querySelector('.battle-stake-option.selected');
            const stakeType = selectedStake ? selectedStake.dataset.stake : 'friendly';
            const amountInput = document.getElementById('battle-stake-amount');
            
            if (stakeType === 'friendly') {
                return { type: 'friendly', amount: 0 };
            }
            
            const amount = parseInt(amountInput.value) || 1;
            return { type: stakeType, amount: amount };
        }
        
        function updateBattleRulesPreview() {
            const content = document.getElementById('battle-rules-content');
            if (!content) return;
            
            // Get selected type
            const selectedTypeEl = document.querySelector('.battle-type-option.selected');
            const battleType = selectedTypeEl ? selectedTypeEl.dataset.type : 'total-score';
            
            // Get selected games from our array
            const selectedGames = battleSelectedGames;
            
            // Get duration
            const durationEl = document.getElementById('battle-duration');
            const duration = durationEl ? parseInt(durationEl.value) : 3;
            
            // Generate and display rules
            content.innerHTML = generateBattleRules(battleType, selectedGames, duration);
            
            // IMPORTANT: Manually attach event listener to checkbox after DOM insertion
            const checkbox = document.getElementById('rules-agree-checkbox');
            if (checkbox) {
                
                checkbox.addEventListener('change', function() {
                    
                    updateCreateBattleButton();
                });
            } else {
                
            }
            
            // Reset agreement checkbox state
            updateCreateBattleButton();
        }
        
        function updateRulesAgreement() {
            
            updateCreateBattleButton();
        }
        
        function updateCreateBattleButton() {
            
            const btn = document.getElementById('create-battle-btn');
            const checkbox = document.getElementById('rules-agree-checkbox');
            
            
            
            if (btn && checkbox) {
                
                if (checkbox.checked) {
                    
                    btn.classList.remove('btn-disabled');
                    btn.style.opacity = '1';
                    btn.style.pointerEvents = 'auto';
                    btn.style.cursor = 'pointer';
                    
                    
                    
                } else {
                    
                    btn.classList.add('btn-disabled');
                    btn.style.opacity = '0.5';
                    btn.style.pointerEvents = 'none';
                    btn.style.cursor = 'not-allowed';
                }
            } else {
                
            }
        }
        
        function closeCreateBattle() {
            document.getElementById('create-battle-sheet').classList.remove('active');
        }
        
        function showJoinBattle() {
            if (!currentUser) {
                showToast('Sign in to join battles', 'error');
                return;
            }
            // Reset form
            document.getElementById('join-code-input').value = '';
            document.getElementById('join-battle-preview').style.display = 'none';
            document.getElementById('join-battle-error').style.display = 'none';
            document.getElementById('find-battle-btn').style.display = 'block';
            document.getElementById('join-battle-sheet').classList.add('active');
        }
        
        function closeJoinBattle() {
            document.getElementById('join-battle-sheet').classList.remove('active');
        }
        
        // ============ GAME SELECTOR FOR BATTLES ============
        let battleSelectedGames = ['wordle', 'connections']; // Default selections
        
        const BATTLE_GAME_CATEGORIES = {
            'NYT Games': ['wordle', 'connections', 'strands', 'mini', 'spelling-bee', 'letterboxed'],
            'LinkedIn': ['queens', 'tango', 'pinpoint', 'crossclimb', 'zip'],
            'Word Games': ['quordle', 'octordle', 'waffle', 'dordle', 'nerdle', 'semantle', 'contexto', 'redactle'],
            'Geography': ['worldle', 'globle', 'tradle', 'wheretaken', 'travle', 'foodguessr'],
            'Entertainment': ['framed', 'actorle', 'moviedle', 'heardle', 'bandle'],
            'Game Shelf Originals': ['quotle', 'slate', 'rungs', 'wordboxing'],
            'Other': ['immaculate-grid', 'costcodle']
        };
        
        function openGameSelector() {
            renderGameSelector();
            document.getElementById('game-selector-overlay').classList.add('active');
        }
        
        function closeGameSelector() {
            document.getElementById('game-selector-overlay').classList.remove('active');
        }
        
        function renderGameSelector() {
            const body = document.getElementById('game-selector-body');
            if (!body) return;
            
            let html = '';
            
            for (const [category, gameIds] of Object.entries(BATTLE_GAME_CATEGORIES)) {
                // Filter to only include games that exist in GAMES
                const validGames = gameIds.filter(id => GAMES[id]);
                if (validGames.length === 0) continue;
                
                html += `<div class="game-category">`;
                html += `<div class="game-category-title">${category}</div>`;
                html += `<div class="game-category-grid">`;
                
                for (const gameId of validGames) {
                    const game = GAMES[gameId];
                    const isSelected = battleSelectedGames.includes(gameId);
                    html += `
                        <div class="game-select-item ${isSelected ? 'selected' : ''}" 
                             data-game="${gameId}" 
                             onclick="toggleGameInSelector(this, '${gameId}')">
                            <span class="game-select-icon">${game.icon}</span>
                            <span class="game-select-name">${game.name}</span>
                            <span class="game-select-check">âœ“</span>
                        </div>
                    `;
                }
                
                html += `</div></div>`;
            }
            
            body.innerHTML = html;
            updateGameSelectorCount();
        }
        
        function toggleGameInSelector(el, gameId) {
            const isSelected = battleSelectedGames.includes(gameId);
            
            if (isSelected) {
                battleSelectedGames = battleSelectedGames.filter(id => id !== gameId);
                el.classList.remove('selected');
            } else {
                battleSelectedGames.push(gameId);
                el.classList.add('selected');
            }
            
            updateGameSelectorCount();
        }
        
        function updateGameSelectorCount() {
            const count = battleSelectedGames.length;
            const countText = document.getElementById('game-selector-count-text');
            if (countText) {
                countText.textContent = `${count} game${count !== 1 ? 's' : ''} selected`;
            }
        }
        
        function confirmGameSelection() {
            closeGameSelector();
            updateSelectedGamesPreview();
            updateBattleRulesPreview();
        }
        
        function updateSelectedGamesPreview() {
            const preview = document.getElementById('selected-games-preview');
            const countBtn = document.getElementById('selected-games-count');
            
            if (battleSelectedGames.length === 0) {
                countBtn.textContent = 'Select games for battle...';
                preview.innerHTML = '';
                return;
            }
            
            countBtn.textContent = `${battleSelectedGames.length} game${battleSelectedGames.length !== 1 ? 's' : ''} selected`;
            
            let html = '';
            for (const gameId of battleSelectedGames.slice(0, 6)) {
                const game = GAMES[gameId];
                if (game) {
                    html += `<span class="selected-game-tag">${game.icon} ${game.name}</span>`;
                }
            }
            if (battleSelectedGames.length > 6) {
                html += `<span class="selected-game-tag">+${battleSelectedGames.length - 6} more</span>`;
            }
            preview.innerHTML = html;
        }
        
        // Legacy function - keep for compatibility but redirect
        function toggleBattleGame(el) {
            const gameId = el.dataset.game;
            if (battleSelectedGames.includes(gameId)) {
                battleSelectedGames = battleSelectedGames.filter(id => id !== gameId);
                el.classList.remove('selected');
            } else {
                battleSelectedGames.push(gameId);
                el.classList.add('selected');
            }
            updateBattleRulesPreview();
        }
        
        function generateBattleCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }
        
        async function createBattle() {
            
            if (!currentUser) return;
            
            // Check agreement
            const agreeCheckbox = document.getElementById('rules-agree-checkbox');
            if (!agreeCheckbox || !agreeCheckbox.checked) {
                showToast('Please agree to the rules first', 'error');
                return;
            }
            
            const name = sanitizeTextInput(document.getElementById('battle-name-input').value, 30) || 'Brain Battle';
            const duration = parseInt(document.getElementById('battle-duration').value);
            const isPublic = document.getElementById('battle-public-toggle')?.checked || false;
            
            // v1.2.77: Get stake info from new UI
            const stakeInfo = getBattleStakeInfo();
            let stakeType = stakeInfo.type;  // 'friendly', 'coins', or 'tokens'
            let stakeAmount = stakeInfo.amount;
            
            // SAFEGUARD: Enforce stake rules
            // - Public battles: always friendly (no wagering with strangers)
            // - Private battles: max 5 coins OR max 500 tokens
            if (isPublic) {
                stakeType = 'friendly';
                stakeAmount = 0;
            } else {
                if (stakeType === 'coins') {
                    stakeAmount = Math.min(stakeAmount, 5);
                } else if (stakeType === 'tokens') {
                    stakeAmount = Math.min(stakeAmount, 500);
                }
            }
            
            // Legacy compatibility: entryFee for old code paths
            const entryFee = stakeType === 'coins' ? stakeAmount : 0;
            
            // Get selected battle type
            const selectedTypeEl = document.querySelector('.battle-type-option.selected');
            const battleType = selectedTypeEl ? selectedTypeEl.dataset.type : 'total-score';
            
            // Use the battleSelectedGames array
            const selectedGames = [...battleSelectedGames];
            
            if (selectedGames.length === 0) {
                showToast('Select at least one game', 'error');
                return;
            }
            
            // Check if user has enough for stake
            const coins = appData.wallet?.coins || 0;
            const tokens = appData.wallet?.tokens || 0;
            if (stakeType === 'coins' && coins < stakeAmount) {
                showToast(`Need ${stakeAmount} coins to create`, 'error');
                return;
            }
            if (stakeType === 'tokens' && tokens < stakeAmount) {
                showToast(`Need ${stakeAmount} tokens to create`, 'error');
                return;
            }
            
            const battleId = 'battle_' + Date.now();
            const joinCode = generateBattleCode();
            const now = Date.now();
            
            const battle = {
                id: battleId,
                name: name,
                type: battleType,
                scoringRules: BATTLE_TYPES[battleType]?.name || 'Total Score',
                status: 'active',
                games: selectedGames,
                createdBy: currentUser.uid,
                creatorName: currentUser.displayName || 'Player',
                createdAt: now,
                startDate: now,
                endDate: now + (duration * 24 * 60 * 60 * 1000),
                duration: duration,
                // v1.2.77: New stake fields
                stakeType: stakeType,
                stakeAmount: stakeAmount,
                entryFee: entryFee,  // Legacy compatibility
                joinCode: joinCode,
                isPublic: isPublic,
                prizePool: stakeAmount, // Will grow as people join
                prizeType: stakeType,   // Track what currency the pool is in
                participants: {
                    [currentUser.uid]: {
                        odataId: currentUser.uid,
                        displayName: currentUser.displayName || 'Player',
                        score: 0,
                        wins: 0,
                        perfects: 0,
                        daysPlayed: 0,
                        joinedAt: now
                    }
                }
            };
            
            try {
                
                
                
                
                
                await db.ref(`battles/${battleId}`).set(battle);
                
                // If public, also publish to public-battles for discovery
                if (isPublic) {
                    const publicBattleData = {
                        id: battleId,
                        name: name,
                        type: battleType,
                        typeName: BATTLE_TYPES[battleType]?.name || 'Total Score',
                        typeIcon: BATTLE_TYPES[battleType]?.icon || 'ðŸ†',
                        games: selectedGames,
                        creatorName: currentUser.displayName || 'Player',
                        createdAt: now,
                        endDate: now + (duration * 24 * 60 * 60 * 1000),
                        duration: duration,
                        stakeType: stakeType,
                        stakeAmount: stakeAmount,
                        entryFee: entryFee,  // Legacy
                        joinCode: joinCode,
                        participantCount: 1
                    };
                    await db.ref(`public-battles/${battleId}`).set(publicBattleData);
                }
                
                // v1.2.77: Deduct stake (coins or tokens)
                if (stakeAmount > 0) {
                    if (stakeType === 'coins') {
                        appData.wallet.coins -= stakeAmount;
                        // Award tokens for coin-based battle participation
                        awardBattleParticipationTokens(name);
                    } else if (stakeType === 'tokens') {
                        appData.wallet.tokens -= stakeAmount;
                    }
                    saveData();
                    renderWallet();
                }
                
                // Log activity
                logActivity('battle-created', {
                    battleId: battleId,
                    name: name,
                    type: battleType
                });
                
                // Trigger referral engagement (advanced feature)
                triggerReferralEngagement('Battles');
                
                closeCreateBattle();
                const typeInfo = BATTLE_TYPES[battleType];
                showToast(`${typeInfo?.icon || 'âš”ï¸'} Battle created! Code: ${joinCode}`);
                
                // Unlock battle achievement
                if (!appData.achievements) appData.achievements = {};
                if (!appData.achievements['battle-join']) {
                    unlockAchievement('battle-join');
                }
                
                // Show the battle details with share code
                loadUserBattles();
                setTimeout(() => showBattleDetails(battleId), 500);
                
            } catch (e) {
                console.error('Error creating battle:', e);
                showToast('Error creating battle', 'error');
            }
        }
        
        async function lookupBattleCode() {
            const code = document.getElementById('join-code-input').value.toUpperCase().trim();
            if (code.length !== 6) {
                document.getElementById('join-battle-error').textContent = 'Enter a 6-character code';
                document.getElementById('join-battle-error').style.display = 'block';
                return;
            }
            
            try {
                const snapshot = await db.ref('battles').orderByChild('joinCode').equalTo(code).once('value');
                const battles = snapshot.val();
                
                if (!battles) {
                    document.getElementById('join-battle-error').textContent = 'Battle not found';
                    document.getElementById('join-battle-error').style.display = 'block';
                    document.getElementById('join-battle-preview').style.display = 'none';
                    return;
                }
                
                const battleId = Object.keys(battles)[0];
                const battle = battles[battleId];
                
                // Check battle status - allow joining active battles too (within first day)
                const now = Date.now();
                const battleAge = now - battle.startDate;
                const oneDayMs = 24 * 60 * 60 * 1000;
                
                if (battle.status === 'completed') {
                    document.getElementById('join-battle-error').textContent = 'Battle has ended';
                    document.getElementById('join-battle-error').style.display = 'block';
                    return;
                }
                
                if (battle.status === 'active' && battleAge > oneDayMs) {
                    document.getElementById('join-battle-error').textContent = 'Battle already in progress (can only join within first 24h)';
                    document.getElementById('join-battle-error').style.display = 'block';
                    return;
                }
                
                if (battle.participants && battle.participants[currentUser.uid]) {
                    document.getElementById('join-battle-error').textContent = 'You\'re already in this battle';
                    document.getElementById('join-battle-error').style.display = 'block';
                    return;
                }
                
                // Show preview with full details
                document.getElementById('join-battle-error').style.display = 'none';
                document.getElementById('join-battle-name').textContent = battle.name;
                
                const participantCount = Object.keys(battle.participants || {}).length;
                document.getElementById('join-battle-info').textContent = `Created by ${Object.values(battle.participants || {})[0]?.displayName || 'Unknown'} â€¢ ${participantCount} player${participantCount !== 1 ? 's' : ''}`;
                
                // Battle type
                const typeInfo = BATTLE_TYPES[battle.type] || BATTLE_TYPES['total-score'];
                document.getElementById('join-battle-type').textContent = `${typeInfo.icon} ${typeInfo.name}`;
                
                // v1.2.77: Entry fee / Stakes display
                const stakeType = battle.stakeType || (battle.entryFee > 0 ? 'coins' : 'friendly');
                const stakeAmount = battle.stakeAmount || battle.entryFee || 0;
                let feeDisplay = 'Free';
                if (stakeType === 'coins' && stakeAmount > 0) {
                    feeDisplay = `ðŸª™ ${stakeAmount}`;
                } else if (stakeType === 'tokens' && stakeAmount > 0) {
                    feeDisplay = `ðŸŽŸï¸ ${stakeAmount}`;
                }
                document.getElementById('join-battle-fee').textContent = feeDisplay;
                
                // Days left
                const daysLeft = Math.max(0, Math.ceil((battle.endDate - now) / oneDayMs));
                document.getElementById('join-battle-days').textContent = daysLeft;
                
                // Generate and show rules
                const rulesContent = document.getElementById('join-battle-rules-content');
                rulesContent.innerHTML = generateBattleRules(battle.type, battle.games, battle.duration || 3, 'updateJoinRulesAgreement');
                
                // IMPORTANT: Manually attach event listener to checkbox after DOM insertion
                const joinCheckbox = document.getElementById('rules-agree-checkbox');
                if (joinCheckbox) {
                    
                    joinCheckbox.addEventListener('change', function() {
                        
                        updateJoinRulesAgreement();
                    });
                }
                
                // Store battle data for join
                document.getElementById('join-battle-preview').dataset.battleId = battleId;
                document.getElementById('join-battle-preview').dataset.battle = JSON.stringify(battle);
                
                // Setup join button
                const joinBtn = document.getElementById('join-battle-btn');
                joinBtn.onclick = () => joinBattle(battleId, battle);
                joinBtn.classList.add('btn-disabled');
                joinBtn.style.opacity = '0.5';
                joinBtn.style.pointerEvents = 'none';
                joinBtn.style.cursor = 'not-allowed';
                
                // Hide find button, show preview
                document.getElementById('find-battle-btn').style.display = 'none';
                document.getElementById('join-battle-preview').style.display = 'block';
                
            } catch (e) {
                console.error('Error looking up battle:', e);
                document.getElementById('join-battle-error').textContent = 'Error finding battle';
                document.getElementById('join-battle-error').style.display = 'block';
            }
        }
        
        // Handle join rules agreement (shared with create)
        function updateJoinRulesAgreement() {
            const btn = document.getElementById('join-battle-btn');
            const checkbox = document.getElementById('rules-agree-checkbox');
            if (btn && checkbox) {
                if (checkbox.checked) {
                    btn.classList.remove('btn-disabled');
                    btn.style.opacity = '1';
                    btn.style.pointerEvents = 'auto';
                    btn.style.cursor = 'pointer';
                } else {
                    btn.classList.add('btn-disabled');
                    btn.style.opacity = '0.5';
                    btn.style.pointerEvents = 'none';
                    btn.style.cursor = 'not-allowed';
                }
            }
        }
        
        async function joinBattle(battleId, battle) {
            if (!currentUser) return;
            
            // Check agreement
            const agreeCheckbox = document.getElementById('rules-agree-checkbox');
            if (!agreeCheckbox || !agreeCheckbox.checked) {
                showToast('Please agree to the rules first', 'error');
                return;
            }
            
            // v1.2.77: Handle coins and tokens
            const stakeType = battle.stakeType || (battle.entryFee > 0 ? 'coins' : 'friendly');
            const stakeAmount = battle.stakeAmount || battle.entryFee || 0;
            const coins = appData.wallet?.coins || 0;
            const tokens = appData.wallet?.tokens || 0;
            
            if (stakeType === 'coins' && stakeAmount > 0 && coins < stakeAmount) {
                showToast(`Need ${stakeAmount} coins to join`, 'error');
                return;
            }
            if (stakeType === 'tokens' && stakeAmount > 0 && tokens < stakeAmount) {
                showToast(`Need ${stakeAmount} tokens to join`, 'error');
                return;
            }
            
            try {
                // Add participant with tracking fields
                await db.ref(`battles/${battleId}/participants/${currentUser.uid}`).set({
                    odataId: currentUser.uid,
                    displayName: currentUser.displayName || 'Player',
                    score: 0,
                    wins: 0,
                    perfects: 0,
                    daysPlayed: 0,
                    joinedAt: Date.now(),
                    agreedToRules: true
                });
                
                // Update prize pool
                if (stakeAmount > 0) {
                    const currentPool = battle.prizePool || stakeAmount;
                    await db.ref(`battles/${battleId}/prizePool`).set(currentPool + stakeAmount);
                }
                
                // Start the battle if pending
                if (battle.status === 'pending') {
                    await db.ref(`battles/${battleId}/status`).set('active');
                }
                
                // v1.2.77: Deduct stake (coins or tokens)
                if (stakeAmount > 0) {
                    if (stakeType === 'coins') {
                        appData.wallet.coins -= stakeAmount;
                        // Award tokens for coin-based battle participation
                        awardBattleParticipationTokens(battle.name);
                    } else if (stakeType === 'tokens') {
                        appData.wallet.tokens -= stakeAmount;
                    }
                    saveData();
                    renderWallet();
                }
                
                // Log activity
                logActivity('battle-joined', {
                    battleId: battleId,
                    name: battle.name,
                    type: battle.type
                });
                
                // Trigger referral engagement (advanced feature)
                triggerReferralEngagement('Battles');
                
                closeJoinBattle();
                showToast('Joined battle!');
                loadUserBattles();
                
                // Unlock battle achievement
                if (!appData.achievements) appData.achievements = {};
                if (!appData.achievements['battle-join']) {
                    unlockAchievement('battle-join');
                }
                
            } catch (e) {
                console.error('Error joining battle:', e);
                showToast('Error joining battle', 'error');
            }
        }
        
        async function loadUserBattles() {
            if (!currentUser) {
                userBattles = [];
                renderBattles();
                return;
            }
            
            try {
                const snapshot = await db.ref('battles').once('value');
                const allBattles = snapshot.val() || {};
                
                userBattles = Object.values(allBattles).filter(b => 
                    b.participants && b.participants[currentUser.uid]
                );
                
                // Check for completed battles
                const now = Date.now();
                userBattles.forEach(battle => {
                    if (battle.status === 'active' && battle.endDate < now) {
                        completeBattle(battle);
                    }
                });
                
                renderBattles();
                updateHomeBattleWidget();
                
            } catch (e) {
                console.error('Error loading battles:', e);
            }
        }
        
        async function completeBattle(battle) {
            if (battle.status === 'completed') return;
            
            const participants = Object.entries(battle.participants || {})
                .map(([uid, data]) => ({ odataId: uid, ...data }))
                .sort((a, b) => (b.score || 0) - (a.score || 0));
            
            const winner = participants[0];
            const runnerUp = participants[1];
            
            // v1.2.77: Handle both coins and tokens properly
            const stakeType = battle.stakeType || (battle.entryFee > 0 ? 'coins' : 'friendly');
            const stakeAmount = battle.stakeAmount || battle.entryFee || 0;
            const prizePool = stakeAmount * participants.length;
            
            const isWinner = winner?.odataId === currentUser?.uid;
            const isRunnerUp = runnerUp?.odataId === currentUser?.uid;
            const isSoloChallenge = participants.length === 1;
            
            // Calculate prize distribution (80% to winner, 20% to 2nd)
            // No prizes for solo challenges - need actual competition
            const winnerPrize = isSoloChallenge ? 0 : Math.floor(prizePool * 0.8);
            const runnerUpPrize = isSoloChallenge ? 0 : (prizePool - winnerPrize);
            
            try {
                await db.ref(`battles/${battle.id}`).update({
                    status: 'completed',
                    completedAt: Date.now(),
                    winner: (winner && !isSoloChallenge) ? {
                        odataId: winner.odataId,
                        displayName: winner.displayName,
                        score: winner.score
                    } : null,
                    prizePool: prizePool,
                    prizeType: stakeType,
                    prizes: {
                        first: winnerPrize,
                        second: runnerUpPrize
                    }
                });
                
                // Log activity (only for real wins with competition)
                if (isWinner && !isSoloChallenge) {
                    logActivity('battle-won', {
                        battleId: battle.id,
                        name: battle.name,
                        prize: winnerPrize,
                        prizeType: stakeType
                    });
                }
                
                // Award prize if current user won or is runner-up
                let myPrize = 0;
                if (isWinner && winnerPrize > 0) {
                    myPrize = winnerPrize;
                } else if (isRunnerUp && runnerUpPrize > 0 && participants.length > 2) {
                    myPrize = runnerUpPrize;
                }
                
                // v1.2.77: Award correct currency type
                if (myPrize > 0) {
                    if (stakeType === 'coins') {
                        appData.wallet.coins = (appData.wallet?.coins || 0) + myPrize;
                    } else {
                        // tokens or friendly (though friendly should have 0 prize)
                        appData.wallet.tokens = (appData.wallet?.tokens || 0) + myPrize;
                    }
                    saveData();
                    renderWallet();
                    
                    playSound('walletAdd');
                }
                
                // Show battle results modal
                showBattleResultsModal(battle, participants, myPrize);
                
            } catch (e) {
                console.error('Error completing battle:', e);
            }
        }
        
        // Store current completed battle for sharing
        let completedBattleData = null;
        
        // Show battle results modal
        function showBattleResultsModal(battle, participants, myPrize) {
            completedBattleData = { battle, participants, myPrize };
            
            const myUid = currentUser?.uid;
            const myPosition = participants.findIndex(p => p.odataId === myUid) + 1;
            const myParticipant = participants.find(p => p.odataId === myUid);
            const winner = participants[0];
            const isWinner = winner?.odataId === myUid;
            const isRunnerUp = myPosition === 2;
            
            // Set trophy/title based on position
            const trophyEl = document.getElementById('battle-results-trophy');
            const titleEl = document.getElementById('battle-results-title');
            
            // Single participant = solo challenge, not a "win"
            const isSoloChallenge = participants.length === 1;
            
            if (isSoloChallenge) {
                trophyEl.textContent = 'âœ…';
                titleEl.textContent = 'Challenge Complete!';
                titleEl.className = 'battle-results-title participant';
            } else if (isWinner) {
                trophyEl.textContent = 'ðŸ†';
                titleEl.textContent = 'VICTORY!';
                titleEl.className = 'battle-results-title winner';
            } else if (isRunnerUp) {
                trophyEl.textContent = 'ðŸ¥ˆ';
                titleEl.textContent = 'SO CLOSE!';
                titleEl.className = 'battle-results-title runner-up';
            } else {
                trophyEl.textContent = myPosition <= 3 ? ['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰'][myPosition - 1] : 'ðŸŽ®';
                titleEl.textContent = 'Better Luck Next Time!';
                titleEl.className = 'battle-results-title participant';
            }
            
            document.getElementById('battle-results-name').textContent = battle.name;
            
            // Stats
            document.getElementById('battle-results-score').textContent = `${myParticipant?.score || 0} pts`;
            document.getElementById('battle-results-perfects').textContent = countPerfects(battle, myUid);
            document.getElementById('battle-results-played').textContent = countGamesPlayed(battle, myUid);
            
            // Margin row
            const marginRow = document.getElementById('battle-results-margin-row');
            if (isWinner && participants.length > 1) {
                const margin = (winner?.score || 0) - (participants[1]?.score || 0);
                document.getElementById('battle-results-margin').textContent = `+${margin} pts`;
                marginRow.style.display = 'flex';
            } else if (!isWinner) {
                const gap = (winner?.score || 0) - (myParticipant?.score || 0);
                document.getElementById('battle-results-margin').textContent = `-${gap} from winner`;
                marginRow.querySelector('.battle-results-stat-label').textContent = 'Gap';
                marginRow.style.display = 'flex';
            } else {
                marginRow.style.display = 'none';
            }
            
            // Prize
            const prizeEl = document.getElementById('battle-results-prize');
            if (myPrize > 0) {
                document.getElementById('battle-results-prize-amount').textContent = `${myPrize} tokens`;
                prizeEl.style.display = 'block';
            } else {
                prizeEl.style.display = 'none';
            }
            
            // Standings
            const standingsList = document.getElementById('battle-results-standings-list');
            standingsList.innerHTML = participants.slice(0, 5).map((p, i) => {
                const isMe = p.odataId === myUid;
                const isWinnerRow = i === 0;
                const rankEmoji = ['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰'][i] || (i + 1);
                return `
                    <div class="battle-results-standing-row ${isWinnerRow ? 'winner-row' : ''} ${isMe ? 'you-row' : ''}">
                        <div class="battle-results-rank">${rankEmoji}</div>
                        <div class="battle-results-player">
                            <div class="battle-results-player-name">${escapeHtml(p.displayName || 'Player')}${isMe ? ' (You)' : ''}</div>
                            <div class="battle-results-player-score">${parseInt(p.score) || 0} pts</div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Tips for non-winners
            const tipsEl = document.getElementById('battle-results-tips');
            const tipsList = document.getElementById('battle-results-tips-list');
            
            if (!isWinner) {
                const tips = generateBattleTips(battle, myParticipant, winner);
                if (tips.length > 0) {
                    tipsList.innerHTML = tips.map(tip => 
                        `<div class="battle-results-tip-item">â€¢ ${tip}</div>`
                    ).join('');
                    tipsEl.style.display = 'block';
                } else {
                    tipsEl.style.display = 'none';
                }
            } else {
                tipsEl.style.display = 'none';
            }
            
            // Update share button text
            document.getElementById('battle-results-share-btn').textContent = isWinner ? 'ðŸŽ‰ Share Victory' : 'ðŸ“¤ Share Result';
            
            // Show modal
            document.getElementById('battle-results-modal').classList.add('active');
            
            // Play sound
            playSound(isWinner ? 'achievement' : 'complete');
        }
        
        function closeBattleResults() {
            document.getElementById('battle-results-modal').classList.remove('active');
            completedBattleData = null;
        }
        
        // Generate tips for non-winners
        function generateBattleTips(battle, myParticipant, winner) {
            const tips = [];
            
            // Count missed games
            const myGames = countGamesPlayedNum(battle, myParticipant?.odataId);
            const winnerGames = countGamesPlayedNum(battle, winner?.odataId);
            const totalPossible = (battle.games?.length || 1) * getDurationDays(battle);
            
            if (myGames < winnerGames) {
                const missed = winnerGames - myGames;
                tips.push(`Played ${missed} fewer game${missed > 1 ? 's' : ''} than winner`);
            }
            
            // Compare perfects
            const myPerfects = countPerfectsNum(battle, myParticipant?.odataId);
            const winnerPerfects = countPerfectsNum(battle, winner?.odataId);
            
            if (myPerfects < winnerPerfects) {
                tips.push(`${winnerPerfects - myPerfects} fewer perfect game${(winnerPerfects - myPerfects) > 1 ? 's' : ''}`);
            }
            
            // General tip
            if (tips.length === 0) {
                tips.push('Great effort! Keep practicing for next time');
            }
            
            return tips.slice(0, 3);
        }
        
        // Helper functions for battle stats
        function countPerfects(battle, odataId) {
            // Count from dailyScores if available
            return countPerfectsNum(battle, odataId).toString();
        }
        
        function countPerfectsNum(battle, odataId) {
            const participant = battle.participants?.[odataId];
            if (!participant?.dailyScores) return 0;
            // Approximate: count scores >= 30 as "perfect"
            return Object.values(participant.dailyScores).filter(s => s >= 30).length;
        }
        
        function countGamesPlayed(battle, odataId) {
            const played = countGamesPlayedNum(battle, odataId);
            const total = (battle.games?.length || 1) * getDurationDays(battle);
            return `${played}/${total}`;
        }
        
        function countGamesPlayedNum(battle, odataId) {
            const participant = battle.participants?.[odataId];
            if (!participant?.dailyScores) return 0;
            return Object.keys(participant.dailyScores).length;
        }
        
        function getDurationDays(battle) {
            if (!battle.startDate || !battle.endDate) return 7;
            return Math.ceil((battle.endDate - battle.startDate) / 86400000);
        }
        
        // Share battle result
        function shareBattleResult() {
            if (!completedBattleData) return;
            
            const { battle, participants, myPrize } = completedBattleData;
            const myUid = currentUser?.uid;
            const myPosition = participants.findIndex(p => p.odataId === myUid) + 1;
            const myParticipant = participants.find(p => p.odataId === myUid);
            const winner = participants[0];
            const isWinner = winner?.odataId === myUid;
            
            let message = [];
            
            if (isWinner) {
                message = [
                    'ðŸ† VICTORY!',
                    '',
                    `âš”ï¸ "${battle.name}"`,
                    '',
                    `ðŸ“Š Final Score: ${myParticipant?.score || 0} pts`,
                    `â­ ${countPerfects(battle, myUid)} perfect games`,
                    `ðŸ‘¥ Beat ${participants.length - 1} opponent${participants.length > 2 ? 's' : ''}`,
                    ''
                ];
                
                if (myPrize > 0) {
                    message.push(`ðŸŽ Won ${myPrize} tokens!`);
                    message.push('');
                }
                
                message.push('Challenge me on Game Shelf! ðŸŽ®');
            } else {
                message = [
                    `âš”ï¸ "${battle.name}" Complete!`,
                    '',
                    `ðŸ“Š My Score: ${myParticipant?.score || 0} pts (${myPosition}${getOrdinalSuffix(myPosition)} place)`,
                    `ðŸ† Winner: ${winner?.displayName || 'Champion'} (${winner?.score || 0} pts)`,
                    '',
                    'Great competition! ðŸ’ª',
                    '',
                    'Track your games on Game Shelf ðŸŽ®'
                ];
            }
            
            const shareText = message.join('\n');
            
            if (navigator.share) {
                navigator.share({ text: shareText }).catch(() => {
                    navigator.clipboard.writeText(shareText).then(() => {
                        showToast('Copied to clipboard!');
                    }).catch(() => {
                        showToast('Could not copy', 'error');
                    });
                });
            } else {
                navigator.clipboard.writeText(shareText).then(() => {
                    showToast('Copied to clipboard!');
                }).catch(() => {
                    showToast('Could not copy', 'error');
                });
            }
        }
        
        // Start rematch with same participants
        function startRematch() {
            if (!completedBattleData) return;
            
            closeBattleResults();
            showCreateBattle();
            
            // Pre-select same games
            const { battle } = completedBattleData;
            setTimeout(() => {
                battle.games?.forEach(gameId => {
                    const chip = document.querySelector(`.battle-game-chip[data-game="${gameId}"]`);
                    if (chip && !chip.classList.contains('selected')) {
                        chip.click();
                    }
                });
            }, 100);
            
            showToast('Set up your rematch!', 'info');
        }
        
        function renderBattles() {
            const container = document.getElementById('battles-list');
            if (!container) return;
            
            const activeBattles = userBattles.filter(b => b.status === 'active');
            const pendingBattles = userBattles.filter(b => b.status === 'pending' && b.createdBy === currentUser?.uid);
            const pastBattles = userBattles.filter(b => b.status === 'completed').slice(0, 5);
            
            if (activeBattles.length === 0 && pendingBattles.length === 0 && pastBattles.length === 0) {
                container.innerHTML = `
                    <div class="battle-empty">
                        <div class="empty-icon">âš”ï¸</div>
                        <p>No battles yet</p>
                        <p style="font-size: 0.85rem; margin-top: 5px;">Create a battle or join one with a code!</p>
                    </div>
                `;
                return;
            }
            
            let html = '';
            
            // Pending battles
            pendingBattles.forEach(battle => {
                html += renderBattleCard(battle, 'pending');
            });
            
            // Active battles
            activeBattles.forEach(battle => {
                html += renderBattleCard(battle, 'active');
            });
            
            // Past battles
            if (pastBattles.length > 0) {
                html += '<div style="font-size: 0.85rem; color: var(--text-muted); margin: 15px 0 10px;">Past Battles</div>';
                pastBattles.forEach(battle => {
                    html += renderBattleCard(battle, 'completed');
                });
            }
            
            container.innerHTML = html;
        }
        
        function renderBattleCard(battle, status) {
            const participants = Object.values(battle.participants || {}).sort((a, b) => (b.score || 0) - (a.score || 0));
            const daysLeft = Math.max(0, Math.ceil((battle.endDate - Date.now()) / 86400000));
            
            let badge = '';
            let headerStyle = 'background: linear-gradient(135deg, #667eea, #764ba2);';
            
            if (status === 'pending') {
                badge = '<span class="battle-badge" style="background: #ff9800;">PENDING</span>';
                headerStyle = 'background: linear-gradient(135deg, #ff9800, #f57c00);';
            } else if (status === 'active') {
                badge = '<span class="battle-badge live">LIVE</span>';
            } else {
                badge = '<span class="battle-badge">ENDED</span>';
                headerStyle = 'background: var(--bg-tertiary);';
            }
            
            const topPlayers = participants.slice(0, 3).map((p, i) => `
                <div class="battle-leaderboard-row">
                    <div class="battle-rank">${['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰'][i]}</div>
                    <div class="battle-participant-avatar" style="background: ${getAvatarColor(p.displayName)}">${escapeHtml((p.displayName || 'U')[0])}</div>
                    <div class="battle-participant-name">${escapeHtml(p.displayName || 'Unknown')}${p.odataId === currentUser?.uid ? ' (You)' : ''}</div>
                    <div class="battle-participant-score">${parseInt(p.score) || 0}</div>
                </div>
            `).join('');
            
            return `
                <div class="battle-card" onclick="showBattleDetails('${escapeAttr(battle.id)}')">
                    <div class="battle-card-header" style="${headerStyle}">
                        âš”ï¸ ${badge}
                    </div>
                    <div class="battle-card-content">
                        <div class="battle-card-title">${escapeHtml(battle.name)}</div>
                        <div class="battle-stats">
                            <span>ðŸŽ® ${escapeHtml(battle.games?.join(', ') || '-')}</span>
                            <span>â±ï¸ ${status === 'completed' ? 'Ended' : parseInt(daysLeft) + 'd left'}</span>
                            ${battle.entryFee > 0 ? `<span>ðŸª™ ${parseInt(battle.entryFee) * participants.length}</span>` : ''}
                        </div>
                        <div class="battle-leaderboard">${topPlayers}</div>
                    </div>
                </div>
            `;
        }
        
        function showBattleDetails(battleId) {
            const battle = userBattles.find(b => b.id === battleId);
            if (!battle) return;
            
            currentBattleId = battleId;
            
            const participants = Object.values(battle.participants || {}).sort((a, b) => (b.score || 0) - (a.score || 0));
            const daysLeft = Math.max(0, Math.ceil((battle.endDate - Date.now()) / 86400000));
            const prizePool = battle.prizePool || (battle.entryFee || 0) * participants.length;
            
            document.getElementById('battle-details-title').textContent = `âš”ï¸ ${battle.name}`;
            
            // Display battle type
            const battleType = battle.type || 'total-score';
            const typeInfo = BATTLE_TYPES[battleType] || BATTLE_TYPES['total-score'];
            document.getElementById('battle-type-icon').textContent = typeInfo.icon;
            document.getElementById('battle-type-name').textContent = typeInfo.name;
            
            // Short description based on type
            const typeDescs = {
                'total-score': 'Highest combined score wins',
                'streak': 'Daily play streaks count',
                'wins': 'Each game won = 1 point',
                'perfect': 'Only perfect scores count'
            };
            document.getElementById('battle-type-desc').textContent = typeDescs[battleType] || 'Highest score wins';
            
            // Format games display with icons
            const gamesDisplay = (battle.games || []).map(g => {
                const game = GAMES[g];
                return game ? `${game.icon}` : g;
            }).join(' ');
            document.getElementById('battle-games-display').textContent = gamesDisplay || '-';
            document.getElementById('battle-time-display').textContent = battle.status === 'completed' ? 'Ended' : `${daysLeft} days`;
            
            if (prizePool > 0) {
                document.getElementById('battle-prize-display').style.display = 'block';
                document.getElementById('battle-prize-amount').textContent = `ðŸª™ ${prizePool}`;
            } else {
                document.getElementById('battle-prize-display').style.display = 'none';
            }
            
            // Status banner
            const banner = document.getElementById('battle-status-banner');
            if (battle.status === 'completed') {
                const winner = participants[0];
                const isWinner = winner?.odataId === currentUser?.uid;
                banner.style.background = isWinner ? 'linear-gradient(135deg, #FFD700, #FFA500)' : 'var(--bg-tertiary)';
                banner.style.color = isWinner ? '#000' : 'var(--text-primary)';
                banner.textContent = isWinner ? 'ðŸ† YOU WON!' : `ðŸ† Winner: ${winner?.displayName || 'Unknown'}`;
            } else if (battle.status === 'pending') {
                banner.style.background = 'linear-gradient(135deg, #ff9800, #f57c00)';
                banner.style.color = '#fff';
                banner.textContent = 'â³ Waiting for opponent...';
            } else {
                banner.style.background = 'linear-gradient(135deg, #4CAF50, #45a049)';
                banner.style.color = '#fff';
                banner.textContent = `ðŸ”´ LIVE â€¢ ${daysLeft} day${daysLeft !== 1 ? 's' : ''} left`;
            }
            
            // Share code (for active battles that can accept more players)
            const shareCodeEl = document.getElementById('battle-share-code');
            if (battle.joinCode && battle.status !== 'completed') {
                shareCodeEl.style.display = 'block';
                document.getElementById('battle-code-display').textContent = battle.joinCode;
            } else {
                shareCodeEl.style.display = 'none';
            }
            
            // Leaderboard
            document.getElementById('battle-leaderboard-display').innerHTML = participants.map((p, i) => `
                <div class="battle-leaderboard-row" style="${p.odataId === currentUser?.uid ? 'background: rgba(102, 126, 234, 0.1);' : ''}">
                    <div class="battle-rank">${i < 3 ? ['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰'][i] : (i + 1)}</div>
                    <div class="battle-participant-avatar" style="background: ${getAvatarColor(p.displayName)}">${escapeHtml((p.displayName || 'U')[0])}</div>
                    <div class="battle-participant-name">${escapeHtml(p.displayName || 'Unknown')}${p.odataId === currentUser?.uid ? ' (You)' : ''}</div>
                    <div class="battle-participant-score">${parseInt(p.score) || 0}</div>
                </div>
            `).join('') || '<div style="color: var(--text-muted); text-align: center;">No participants yet</div>';
            
            document.getElementById('battle-details-sheet').classList.add('active');
        }
        
        function closeBattleDetails() {
            document.getElementById('battle-details-sheet').classList.remove('active');
            currentBattleId = null;
        }
        
        function copyBattleCode() {
            const code = document.getElementById('battle-code-display').textContent;
            navigator.clipboard.writeText(code).then(() => {
                showToast('Code copied!');
            }).catch(() => {
                showToast('Could not copy code', 'error');
            });
        }
        
        function shareBattleInvite() {
            const battle = userBattles.find(b => b.id === currentBattleId);
            if (!battle) return;
            
            const code = battle.joinCode;
            const daysLeft = Math.max(0, Math.ceil((battle.endDate - Date.now()) / 86400000));
            const gameIcons = (battle.games || []).map(g => GAMES[g]?.icon || 'ðŸŽ®').join(' ');
            const prizePool = battle.prizePool || 0;
            const battleLink = `${REFERRAL_BASE_URL}/#battle=${code}`;
            
            let message = `âš”ï¸ Join my puzzle battle!\n\n`;
            message += `ðŸ† ${battle.name}\n`;
            message += `ðŸŽ® Games: ${gameIcons}\n`;
            message += `â° ${daysLeft} days left\n`;
            if (prizePool > 0) {
                message += `ðŸª™ Prize pool: ${prizePool} coins\n`;
            }
            message += `\nðŸ‘‰ ${battleLink}`;
            
            if (navigator.share) {
                navigator.share({
                    title: `Join ${battle.name}!`,
                    text: message,
                    url: battleLink
                }).catch(() => {
                    // User cancelled or error - fallback to copy
                    copyBattleInviteMessage(message);
                });
            } else {
                copyBattleInviteMessage(message);
            }
        }
        
        function copyBattleInviteMessage(message) {
            navigator.clipboard.writeText(message).then(() => {
                showToast('ðŸ“‹ Invite copied! Send to friends');
            }).catch(() => {
                showToast('Could not copy invite', 'error');
            });
        }
        
        function updateHomeBattleWidget() {
            const widget = document.getElementById('battle-widget');
            // v1.3.1: Get all active battles, not just the first one
            const activeBattles = userBattles.filter(b => b.status === 'active');
            
            if (activeBattles.length === 0) {
                widget.style.display = 'none';
                return;
            }
            
            widget.style.display = 'block';
            
            // Show the most urgent battle (ending soonest)
            const activeBattle = activeBattles.sort((a, b) => a.endDate - b.endDate)[0];
            
            // v1.3.1: Better time remaining display (hours if <1 day)
            const msLeft = activeBattle.endDate - Date.now();
            const hoursLeft = Math.ceil(msLeft / 3600000);
            const daysLeft = Math.ceil(msLeft / 86400000);
            let timeDisplay;
            if (hoursLeft <= 0) {
                timeDisplay = 'Ending!';
            } else if (hoursLeft < 24) {
                timeDisplay = `${hoursLeft}h`;
            } else {
                timeDisplay = `${daysLeft}d`;
            }
            
            document.getElementById('battle-time-left').textContent = timeDisplay;
            
            // v1.3.1: Show battle count if multiple active battles
            let battleTitle = activeBattle.name;
            if (activeBattles.length > 1) {
                battleTitle += ` (+${activeBattles.length - 1} more)`;
            }
            document.getElementById('battle-name').textContent = battleTitle;
            
            const participants = Object.values(activeBattle.participants || {}).sort((a, b) => (b.score || 0) - (a.score || 0));
            document.getElementById('battle-standings').innerHTML = participants.slice(0, 3).map((p, i) => `
                <div style="display: flex; justify-content: space-between; font-size: 0.85rem; padding: 4px 0;">
                    <span>${['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰'][i]} ${escapeHtml(p.displayName || 'Unknown')}${p.odataId === currentUser?.uid ? ' (You)' : ''}</span>
                    <span style="color: var(--accent-green);">${parseInt(p.score) || 0}</span>
                </div>
            `).join('');
            
            // v1.2.77: Check for unplayed battle games today
            checkBattleReminder(activeBattle);
        }
        
        // v1.2.77: Show reminder if user hasn't played all battle games today
        function checkBattleReminder(battle) {
            if (!currentUser) return;
            
            const today = getTodayString();
            const participant = battle.participants?.[currentUser.uid];
            const dailyScores = participant?.dailyScores || {};
            
            // Get today's games played
            const todaysGames = Object.keys(dailyScores)
                .filter(key => key.startsWith(today + '_'))
                .map(key => key.split('_')[1]);
            
            // Find unplayed battle games
            const unplayedGames = (battle.games || []).filter(g => !todaysGames.includes(g));
            
            // Update or show reminder
            const reminderEl = document.getElementById('battle-reminder');
            if (!reminderEl) {
                // Create reminder element if it doesn't exist
                const widget = document.getElementById('battle-widget');
                if (!widget) return;
                
                const reminder = document.createElement('div');
                reminder.id = 'battle-reminder';
                reminder.style.cssText = 'margin-top: 8px; padding: 8px 10px; background: var(--accent-orange); color: #1a1a2e; border-radius: 8px; font-size: 0.8rem; font-weight: 600; display: none; cursor: pointer;';
                reminder.onclick = () => showBattleDetails(battle.id);
                widget.appendChild(reminder);
            }
            
            const reminder = document.getElementById('battle-reminder');
            if (unplayedGames.length > 0 && unplayedGames.length < battle.games.length) {
                // Some games played, some not
                // v1.3.1: Improved wording for readability
                const gameNames = unplayedGames.map(g => GAMES[g]?.name || g).slice(0, 2);
                const moreCount = unplayedGames.length - 2;
                let text = `âš ï¸ Still to play: ${gameNames.join(', ')}`;
                if (moreCount > 0) text += ` +${moreCount} more`;
                reminder.textContent = text;
                reminder.style.display = 'block';
            } else if (unplayedGames.length === battle.games.length) {
                // No games played yet today
                reminder.textContent = `âš ï¸ Play your battle games today!`;
                reminder.style.display = 'block';
            } else {
                // All games played
                reminder.style.display = 'none';
            }
        }
        
        // ============ PUBLIC BATTLES LOBBY ============
        let publicBattles = [];
        
        async function loadPublicBattles() {
            const container = document.getElementById('public-battles-list');
            if (!container) return;
            
            // Show loading state
            container.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-muted);">Loading battles...</div>';
            
            try {
                const snapshot = await db.ref('public-battles').orderByChild('endDate').once('value');
                const battlesObj = snapshot.val() || {};
                
                const now = Date.now();
                
                // Filter to active battles only (not ended, not full of your battles)
                publicBattles = Object.values(battlesObj)
                    .filter(b => b.endDate > now) // Not ended
                    .sort((a, b) => b.createdAt - a.createdAt); // Newest first
                
                renderPublicBattles();
                
            } catch (e) {
                console.error('Error loading public battles:', e);
                container.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-muted);">Could not load battles</div>';
            }
        }
        
        function renderPublicBattles() {
            const container = document.getElementById('public-battles-list');
            if (!container) return;
            
            if (publicBattles.length === 0) {
                container.innerHTML = `
                    <div class="battle-lobby-empty">
                        <div class="empty-icon">ðŸŸï¸</div>
                        <div>No public battles right now</div>
                        <div class="battle-lobby-create-prompt" onclick="showCreateBattle()">
                            Be the first to create one! â†’
                        </div>
                    </div>
                `;
                return;
            }
            
            // Check which battles user is already in
            const myBattleIds = userBattles.map(b => b.id);
            
            container.innerHTML = publicBattles.map(battle => {
                const isJoined = myBattleIds.includes(battle.id);
                const daysLeft = Math.max(0, Math.ceil((battle.endDate - Date.now()) / 86400000));
                const participantCount = battle.participantCount || 1;
                
                // Generate game icons
                const gameIcons = (battle.games || []).slice(0, 4).map(gameId => {
                    const game = GAMES[gameId];
                    return `<div class="public-battle-game-icon">${game?.icon || 'ðŸŽ®'}</div>`;
                }).join('');
                
                const moreGames = (battle.games?.length || 0) > 4 ? `<div class="public-battle-game-icon" style="font-size: 0.8rem;">+${battle.games.length - 4}</div>` : '';
                
                return `
                    <div class="public-battle-card">
                        <div class="public-battle-header">
                            <div class="public-battle-name">${escapeHtml(battle.name)}</div>
                            <span class="public-battle-badge ${daysLeft <= 1 ? 'starting-soon' : 'open'}">
                                ${daysLeft <= 1 ? 'âš¡ Ending soon' : 'âœ“ Open'}
                            </span>
                        </div>
                        <div class="public-battle-meta">
                            <span>ðŸ‘¤ ${participantCount} player${participantCount !== 1 ? 's' : ''}</span>
                            <span>â±ï¸ ${daysLeft}d left</span>
                            <span>${battle.typeIcon || 'ðŸ†'} ${battle.typeName || 'Total Score'}</span>
                            <span>ðŸ†“ Free</span>
                        </div>
                        <div class="public-battle-games">
                            ${gameIcons}${moreGames}
                        </div>
                        <button class="public-battle-join-btn ${isJoined ? 'joined' : ''}" 
                                onclick="event.stopPropagation(); ${isJoined ? `showBattleDetails('${escapeAttr(battle.id)}')` : `joinPublicBattle('${escapeAttr(battle.id)}')`}">
                            ${isJoined ? 'âœ“ Joined - View Battle' : 'âš”ï¸ Join Battle'}
                        </button>
                    </div>
                `;
            }).join('');
        }
        
        async function joinPublicBattle(battleId) {
            if (!currentUser) {
                showToast('Sign in to join battles', 'error');
                return;
            }
            
            try {
                // Get the full battle data
                const snapshot = await db.ref(`battles/${battleId}`).once('value');
                const battle = snapshot.val();
                
                if (!battle) {
                    showToast('Battle not found', 'error');
                    return;
                }
                
                // Check if already joined
                if (battle.participants?.[currentUser.uid]) {
                    showToast('Already in this battle!');
                    showBattleDetails(battleId);
                    return;
                }
                
                // Check entry fee
                const entryFee = battle.entryFee || 0;
                const coins = appData.wallet?.coins || 0;
                if (entryFee > 0 && coins < entryFee) {
                    showToast(`Need ${entryFee} coins to join`, 'error');
                    return;
                }
                
                // Join the battle
                await db.ref(`battles/${battleId}/participants/${currentUser.uid}`).set({
                    odataId: currentUser.uid,
                    displayName: currentUser.displayName || 'Player',
                    score: 0,
                    wins: 0,
                    perfects: 0,
                    daysPlayed: 0,
                    joinedAt: Date.now()
                });
                
                // Update participant count in public listing
                const publicBattle = publicBattles.find(b => b.id === battleId);
                if (publicBattle) {
                    const newCount = (publicBattle.participantCount || 1) + 1;
                    await db.ref(`public-battles/${battleId}/participantCount`).set(newCount);
                }
                
                // Deduct entry fee
                if (entryFee > 0) {
                    appData.wallet.coins -= entryFee;
                    // Award tokens for coin-based battle participation
                    awardBattleParticipationTokens(battle.name || 'Battle');
                    saveData();
                    renderWallet();
                    
                    // Update prize pool
                    const currentPool = battle.prizePool || entryFee;
                    await db.ref(`battles/${battleId}/prizePool`).set(currentPool + entryFee);
                }
                
                SoundManager.play('reward');
                showToast('âš”ï¸ Joined battle!', 'success');
                
                // Unlock achievement
                if (!appData.achievements?.['battle-join']) {
                    unlockAchievement('battle-join');
                }
                
                // Reload battles
                await loadUserBattles();
                loadPublicBattles();
                
                // Show battle details
                setTimeout(() => showBattleDetails(battleId), 500);
                
            } catch (e) {
                console.error('Error joining public battle:', e);
                showToast('Could not join battle', 'error');
            }
        }
        
        // Update battle score when logging a game
        async function updateBattleScore(gameId, score, result = {}) {
            if (!currentUser) return;
            
            const today = getTodayString();
            const scoreKey = `${today}_${gameId}`;
            
            // Determine win/perfect status
            const won = result.won || false;
            const perfect = result.meta?.perfect || result.score?.includes('ðŸŽ¯') || false;
            
            for (const battle of userBattles) {
                if (battle.status !== 'active') continue;
                if (!battle.games?.includes(gameId)) continue;
                
                try {
                    const participantRef = db.ref(`battles/${battle.id}/participants/${currentUser.uid}`);
                    
                    // v1.2.77: Use transaction to store score AND meta atomically
                    // Firebase Function trigger will recalculate proper score based on battle type
                    await participantRef.transaction(participant => {
                        if (!participant) return participant;
                        
                        // Initialize if needed
                        if (!participant.dailyScores) participant.dailyScores = {};
                        if (!participant.dailyMeta) participant.dailyMeta = {};
                        
                        // Store raw score
                        participant.dailyScores[scoreKey] = score;
                        
                        // Store meta for battle type scoring (wins/perfect/streak)
                        participant.dailyMeta[scoreKey] = {
                            won: won,
                            perfect: perfect,
                            timestamp: Date.now()
                        };
                        
                        // Client-side score calculation (Firebase trigger will override for non-total-score battles)
                        // This provides immediate feedback while trigger processes
                        const battleType = battle.type || 'total-score';
                        
                        if (battleType === 'total-score') {
                            // Sum all raw scores
                            participant.score = Object.values(participant.dailyScores)
                                .reduce((sum, s) => sum + (parseInt(s) || 0), 0);
                        } else if (battleType === 'wins') {
                            // Count wins
                            participant.score = Object.values(participant.dailyMeta)
                                .filter(m => m?.won).length;
                        } else if (battleType === 'perfect') {
                            // Count perfects
                            participant.score = Object.values(participant.dailyMeta)
                                .filter(m => m?.perfect).length;
                        } else if (battleType === 'streak') {
                            // Raw scores (bonus calculated server-side)
                            participant.score = Object.values(participant.dailyScores)
                                .reduce((sum, s) => sum + (parseInt(s) || 0), 0);
                        }
                        
                        // Track unique days played
                        const uniqueDays = new Set(
                            Object.keys(participant.dailyScores).map(key => key.split('_')[0])
                        );
                        participant.daysPlayed = uniqueDays.size;
                        
                        return participant;
                    });
                    
                } catch (e) {
                    console.error('Error updating battle score:', e);
                }
            }
            
            loadUserBattles();
        }
        
        function getAvatarColor(name) {
            const colors = ['#667eea', '#764ba2', '#f093fb', '#f5576c', '#4facfe', '#43e97b', '#fa709a', '#fee140'];
            const index = (name || 'U').charCodeAt(0) % colors.length;
            return colors[index];
        }
        function renderAll() {
            // Batch DOM updates in single animation frame for smoother rendering
            requestAnimationFrame(() => {
                renderWallet();
                renderQuickGames();
                renderProgress();
                renderHomeGames();
                renderShelfGames();
                renderPopularGames();
                renderRecommendations();
                restoreRecommendationsState();
                restoreCategoryExpandedState(); // v1.3.0: Restore category accordion state
                renderLeaderboard();
                renderFriendsWidget();
            });
        }
        
        function renderWallet() {
            const tokenEl = document.getElementById('token-count');
            const coinEl = document.getElementById('coin-count');
            if (tokenEl) tokenEl.textContent = appData.wallet.tokens || 0;
            if (coinEl) coinEl.textContent = appData.wallet.coins || 0;
        }
        
        // Show wallet options when tapping on wallet display
        function showWalletOptionsSheet() {
            toggleSettingsMenu(); // Close menu first
            const tokens = appData.wallet?.tokens || 0;
            const coins = appData.wallet?.coins || 0;
            
            showGenericSheet({
                title: 'ðŸ’Ž Your Wallet',
                content: `
                    <div style="text-align: center; padding: 20px;">
                        <div style="display: flex; justify-content: center; gap: 32px; margin-bottom: 24px;">
                            <div>
                                <div style="font-size: 2.5rem;">ðŸ’Ž</div>
                                <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-purple);">${tokens}</div>
                                <div style="font-size: 0.8rem; color: var(--text-muted);">Tokens</div>
                            </div>
                            <div>
                                <div style="font-size: 2.5rem;">ðŸª™</div>
                                <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-gold);">${coins}</div>
                                <div style="font-size: 0.8rem; color: var(--text-muted);">Coins</div>
                            </div>
                        </div>
                        
                        <div style="background: var(--bg-tertiary); border-radius: 12px; padding: 16px; margin-bottom: 20px; text-align: left;">
                            <div style="font-size: 0.85rem; color: var(--text-muted);">
                                <div style="margin-bottom: 8px;">ðŸ’Ž <strong>Tokens</strong> = AI hints (5 per hint) & battles</div>
                                <div style="margin-bottom: 8px;">ðŸª™ <strong>Coins</strong> = Convert to tokens or wager in battles</div>
                                <div style="font-size: 0.75rem; color: var(--text-muted);">âš”ï¸ Battle wagers: up to 5 coins or 500 tokens per battle</div>
                            </div>
                        </div>
                        
                        <div style="display: flex; flex-direction: column; gap: 12px;">
                            <button onclick="showBuyCoinsSheet();" style="
                                width: 100%;
                                padding: 16px;
                                background: linear-gradient(135deg, var(--accent-gold), #e6c200);
                                border: none;
                                border-radius: 12px;
                                color: #1a1a2e;
                                font-weight: 600;
                                font-size: 1rem;
                                cursor: pointer;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                gap: 8px;
                            ">
                                ðŸ’° Buy Coins
                            </button>
                            ${coins > 0 ? `
                            <button onclick="showConvertCoinsSheet();" style="
                                width: 100%;
                                padding: 16px;
                                background: linear-gradient(135deg, var(--accent-green), #38a169);
                                border: none;
                                border-radius: 12px;
                                color: white;
                                font-weight: 600;
                                font-size: 1rem;
                                cursor: pointer;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                gap: 8px;
                            ">
                                ðŸ”„ Convert Coins to Tokens
                            </button>
                            ` : ''}
                            <button onclick="showReferralSheet(); closeGenericSheet();" style="
                                width: 100%;
                                padding: 16px;
                                background: linear-gradient(135deg, var(--accent-purple), #764ba2);
                                border: none;
                                border-radius: 12px;
                                color: white;
                                font-weight: 600;
                                font-size: 1rem;
                                cursor: pointer;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                gap: 8px;
                            ">
                                ðŸ“§ Invite Friends for Tokens
                            </button>
                            <button onclick="showTransactionHistorySheet();" style="
                                width: 100%;
                                padding: 16px;
                                background: var(--bg-tertiary);
                                border: 1px solid var(--border);
                                border-radius: 12px;
                                color: var(--text-primary);
                                font-weight: 600;
                                font-size: 1rem;
                                cursor: pointer;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                gap: 8px;
                            ">
                                ðŸ“œ Transaction History
                            </button>
                        </div>
                        
                        <div style="margin-top: 20px; padding-top: 16px; border-top: 1px solid var(--border);">
                            <a href="#" onclick="showTermsSheet(); return false;" style="font-size: 0.8rem; color: var(--text-muted);">
                                Terms & Conditions
                            </a>
                        </div>
                    </div>
                `
            });
        }
        
        // Show Transaction History
        async function showTransactionHistorySheet() {
            closeGenericSheet();
            
            // Show loading state
            showGenericSheet({
                title: 'ðŸ“œ Transaction History',
                content: `
                    <div style="text-align: center; padding: 40px;">
                        <div class="spinner" style="margin: 0 auto;"></div>
                        <div style="margin-top: 16px; color: var(--text-muted);">Loading transactions...</div>
                    </div>
                `
            });
            
            if (!currentUser) {
                showGenericSheet({
                    title: 'ðŸ“œ Transaction History',
                    content: `
                        <div style="text-align: center; padding: 40px; color: var(--text-muted);">
                            <div style="font-size: 3rem; margin-bottom: 16px;">ðŸ”’</div>
                            <p>Sign in to view your transaction history</p>
                        </div>
                    `
                });
                return;
            }
            
            const userId = currentUser.uid;
            const transactions = [];
            
            try {
                // Fetch coin purchases
                const purchasesRef = db.ref(`purchases/${userId}`);
                const purchasesSnap = await purchasesRef.orderByChild('timestamp').limitToLast(50).once('value');
                purchasesSnap.forEach(snap => {
                    const data = snap.val();
                    transactions.push({
                        type: 'purchase',
                        icon: 'ðŸ’°',
                        description: `Purchased ${data.coinAmount} coins`,
                        amount: `+${data.coinAmount} ðŸª™`,
                        cost: `$${(data.priceCents / 100).toFixed(2)}`,
                        timestamp: data.timestamp,
                        color: 'var(--accent-gold)'
                    });
                });
                
                // Fetch token history (hints, etc.)
                const tokenHistoryRef = db.ref(`users/${userId}/tokenHistory`);
                const tokenHistorySnap = await tokenHistoryRef.orderByChild('timestamp').limitToLast(50).once('value');
                tokenHistorySnap.forEach(snap => {
                    const data = snap.val();
                    const isDebit = data.amount < 0;
                    transactions.push({
                        type: data.type || 'token',
                        icon: isDebit ? 'ðŸ’Ž' : 'âœ¨',
                        description: data.type === 'hint' ? 'Used AI Hint' : (data.type || 'Token transaction'),
                        amount: `${data.amount > 0 ? '+' : ''}${data.amount} ðŸ’Ž`,
                        timestamp: data.timestamp,
                        color: isDebit ? 'var(--accent-red)' : 'var(--accent-green)'
                    });
                });
                
                // Fetch gift redemptions
                const giftsRef = db.ref(`giftRedemptions/${userId}`);
                const giftsSnap = await giftsRef.orderByChild('timestamp').limitToLast(20).once('value');
                giftsSnap.forEach(snap => {
                    const data = snap.val();
                    transactions.push({
                        type: 'gift',
                        icon: 'ðŸŽ',
                        description: `Redeemed $${data.tierValue} gift`,
                        amount: `-${data.tierCoins} ðŸª™`,
                        timestamp: data.timestamp,
                        color: 'var(--accent-purple)'
                    });
                });
                
                // Sort by timestamp descending (newest first)
                transactions.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
                
                // Format the transactions
                const formatDate = (ts) => {
                    if (!ts) return 'Unknown date';
                    const d = new Date(ts);
                    const now = new Date();
                    const isToday = d.toDateString() === now.toDateString();
                    const isYesterday = d.toDateString() === new Date(now - 86400000).toDateString();
                    
                    if (isToday) return `Today ${d.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}`;
                    if (isYesterday) return `Yesterday ${d.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}`;
                    return d.toLocaleDateString([], { month: 'short', day: 'numeric' }) + ' ' + d.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
                };
                
                let content;
                if (transactions.length === 0) {
                    content = `
                        <div style="text-align: center; padding: 40px; color: var(--text-muted);">
                            <div style="font-size: 3rem; margin-bottom: 16px;">ðŸ“­</div>
                            <p>No transactions yet</p>
                            <p style="font-size: 0.85rem;">Buy coins or use hints to see your history here</p>
                        </div>
                    `;
                } else {
                    content = `
                        <div style="max-height: 400px; overflow-y: auto;">
                            ${transactions.map(t => `
                                <div style="
                                    display: flex;
                                    align-items: center;
                                    padding: 12px 16px;
                                    border-bottom: 1px solid var(--border);
                                    gap: 12px;
                                ">
                                    <div style="font-size: 1.5rem;">${t.icon}</div>
                                    <div style="flex: 1; min-width: 0;">
                                        <div style="font-weight: 500; color: var(--text-primary);">${t.description}</div>
                                        <div style="font-size: 0.75rem; color: var(--text-muted);">${formatDate(t.timestamp)}${t.cost ? ` â€¢ ${t.cost}` : ''}</div>
                                    </div>
                                    <div style="font-weight: 600; color: ${t.color}; white-space: nowrap;">${t.amount}</div>
                                </div>
                            `).join('')}
                        </div>
                        <div style="padding: 12px 16px; text-align: center; color: var(--text-muted); font-size: 0.75rem;">
                            Showing last ${transactions.length} transaction${transactions.length === 1 ? '' : 's'}
                        </div>
                    `;
                }
                
                showGenericSheet({
                    title: 'ðŸ“œ Transaction History',
                    content: content
                });
                
            } catch (error) {
                console.error('Failed to load transaction history:', error);
                showGenericSheet({
                    title: 'ðŸ“œ Transaction History',
                    content: `
                        <div style="text-align: center; padding: 40px; color: var(--text-muted);">
                            <div style="font-size: 3rem; margin-bottom: 16px;">âŒ</div>
                            <p>Failed to load history</p>
                            <p style="font-size: 0.85rem;">${error.message}</p>
                        </div>
                    `
                });
            }
        }
        
        // ============ TOKEN/COIN MANAGEMENT ============
        
        // Show Terms & Conditions
        function showTermsSheet() {
            closeGenericSheet();
            showGenericSheet({
                title: 'ðŸ“‹ Terms & Conditions',
                content: `
                    <div style="padding: 16px; font-size: 0.9rem; line-height: 1.6;">
                        <h4 style="margin: 0 0 12px; color: var(--text-primary);">Game Shelf Token & Coin System</h4>
                        
                        <div style="margin-bottom: 16px;">
                            <strong>Account Requirements</strong>
                            <ul style="margin: 8px 0; padding-left: 20px; color: var(--text-secondary);">
                                <li>A Google account is required to use Game Shelf features including AI hints, battles, and purchases</li>
                                <li>You must be signed in to earn or spend tokens</li>
                            </ul>
                        </div>
                        
                        <div style="margin-bottom: 16px;">
                            <strong>Coin Purchases</strong>
                            <ul style="margin: 8px 0; padding-left: 20px; color: var(--text-secondary);">
                                <li>Coins cost $1 USD each</li>
                                <li>Minimum purchase: 10 coins ($10 USD)</li>
                                <li>All purchases are processed securely via Stripe</li>
                                <li>Coins are non-refundable once purchased</li>
                                <li>Weekly purchase limit: $50 USD</li>
                            </ul>
                        </div>
                        
                        <div style="margin-bottom: 16px;">
                            <strong>Tokens & Hints</strong>
                            <ul style="margin: 8px 0; padding-left: 20px; color: var(--text-secondary);">
                                <li>AI hints cost 5 tokens each</li>
                                <li>1 coin converts to 100 tokens</li>
                                <li>New users receive 50 bonus tokens</li>
                                <li>Tokens can be earned through referrals</li>
                            </ul>
                        </div>
                        
                        <div style="margin-bottom: 16px;">
                            <strong>Referral Program</strong>
                            <ul style="margin: 8px 0; padding-left: 20px; color: var(--text-secondary);">
                                <li>Send invite: +10 tokens</li>
                                <li>Friend signs up: +50 tokens</li>
                                <li>Friend makes first purchase: +100 tokens</li>
                            </ul>
                        </div>
                        
                        <div style="font-size: 0.8rem; color: var(--text-muted); margin-top: 20px; padding-top: 12px; border-top: 1px solid var(--border);">
                            By using Game Shelf, you agree to these terms. Terms may be updated periodically.
                        </div>
                    </div>
                `
            });
        }
        
        function showInsufficientTokensSheet(current, needed) {
            const coinsAvailable = appData.wallet?.coins || 0;
            showGenericSheet({
                title: 'ðŸ’Ž Need More Tokens',
                content: `
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 3rem; margin-bottom: 16px;">ðŸ’Ž</div>
                        <div style="font-size: 1.1rem; margin-bottom: 8px;">
                            You have <strong>${current}</strong> tokens
                        </div>
                        <div style="color: var(--text-muted); margin-bottom: 24px;">
                            Hints cost <strong>${needed}</strong> tokens each
                        </div>
                        
                        <div style="text-align: left; background: var(--bg-tertiary); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                            <div style="font-weight: 600; margin-bottom: 12px;">ðŸ’¡ Ways to get tokens:</div>
                            <div style="display: flex; flex-direction: column; gap: 10px; font-size: 0.9rem;">
                                <div style="display: flex; justify-content: space-between;">
                                    <span>ðŸ“§ Invite a friend</span>
                                    <strong style="color: var(--accent-purple);">+10</strong>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span>ðŸ‘‹ Friend signs up</span>
                                    <strong style="color: var(--accent-purple);">+50</strong>
                                </div>
                                <div style="display: flex; justify-content: space-between;">
                                    <span>ðŸ’° Friend buys coins</span>
                                    <strong style="color: var(--accent-purple);">+100</strong>
                                </div>
                                <div style="display: flex; justify-content: space-between; padding-top: 8px; border-top: 1px solid var(--border-color);">
                                    <span>ðŸ”„ Convert 1 coin</span>
                                    <strong style="color: var(--accent-gold);">= 100 tokens</strong>
                                </div>
                            </div>
                        </div>
                        
                        <div style="display: flex; flex-direction: column; gap: 10px;">
                            <button class="btn-primary" style="width: 100%; padding: 14px;" onclick="showReferralSheet(); closeGenericSheet();">
                                ðŸ“§ Invite Friends
                            </button>
                            <button class="btn-secondary" style="width: 100%; padding: 14px;" onclick="showBuyCoinsSheet();">
                                ðŸ’° Buy Coins
                            </button>
                            ${coinsAvailable > 0 ? `
                            <button class="btn-secondary" style="width: 100%; padding: 14px;" onclick="showConvertCoinsSheet();">
                                ðŸ”„ Convert Coins (${coinsAvailable} available)
                            </button>
                            ` : ''}
                        </div>
                    </div>
                `
            });
        }
        
        function showBuyCoinsSheet() {
            closeGenericSheet();
            showGenericSheet({
                title: 'ðŸ’° Buy Coins',
                content: `
                    <div style="padding: 20px;">
                        <div style="text-align: center; margin-bottom: 24px;">
                            <div style="font-size: 3rem;">ðŸª™</div>
                            <div style="font-size: 1.4rem; font-weight: 700; color: var(--accent-gold); margin-top: 8px;">
                                $1 per coin
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 24px;">
                            <label style="display: block; margin-bottom: 10px; font-size: 0.9rem; color: var(--text-secondary);">How many coins?</label>
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <button onclick="adjustCoinAmount(-10)" style="
                                    width: 48px; height: 48px;
                                    background: var(--bg-tertiary);
                                    border: 1px solid var(--border);
                                    border-radius: 10px;
                                    color: var(--text-primary);
                                    font-size: 1.4rem;
                                    cursor: pointer;
                                ">âˆ’</button>
                                <input type="number" id="buy-coins-amount" min="10" max="100" value="10" 
                                    style="flex: 1; padding: 16px; text-align: center; font-size: 1.6rem; font-weight: 700; border-radius: 10px; border: 2px solid var(--accent-gold); background: var(--bg-tertiary); color: var(--accent-gold);"
                                    onchange="updateBuyPreview()"
                                    oninput="updateBuyPreview()"
                                >
                                <button onclick="adjustCoinAmount(10)" style="
                                    width: 48px; height: 48px;
                                    background: var(--bg-tertiary);
                                    border: 1px solid var(--border);
                                    border-radius: 10px;
                                    color: var(--text-primary);
                                    font-size: 1.4rem;
                                    cursor: pointer;
                                ">+</button>
                            </div>
                            <div style="font-size: 0.75rem; color: var(--text-muted); margin-top: 8px; text-align: center;">Minimum: 10 coins</div>
                        </div>
                        
                        <div id="buy-preview" style="padding: 20px; background: var(--bg-tertiary); border-radius: 12px; margin-bottom: 20px; text-align: center;">
                            <div style="font-size: 0.9rem; color: var(--text-muted); margin-bottom: 4px;">Total</div>
                            <div style="font-size: 2rem; font-weight: 700; color: var(--accent-green);">$10</div>
                        </div>
                        
                        <button onclick="purchaseCoinsFromInput()" style="
                            width: 100%;
                            padding: 18px;
                            background: linear-gradient(135deg, var(--accent-gold), #e6c200);
                            border: none;
                            border-radius: 12px;
                            color: #1a1a2e;
                            font-weight: 700;
                            font-size: 1.1rem;
                            cursor: pointer;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            gap: 8px;
                        ">
                            ðŸ’³ Purchase Coins
                        </button>
                        
                        <div style="margin-top: 16px; padding: 12px; background: var(--bg-tertiary); border-radius: 8px; font-size: 0.8rem; color: var(--text-muted); text-align: center;">
                            ðŸ”’ Secure payment via Stripe<br>
                            <a href="#" onclick="showTermsSheet(); return false;" style="color: var(--accent-purple);">Terms & Conditions</a>
                        </div>
                    </div>
                `
            });
        }
        
        function adjustCoinAmount(delta) {
            const input = document.getElementById('buy-coins-amount');
            let value = parseInt(input.value) || 10;
            value = Math.max(10, Math.min(100, value + delta));
            input.value = value;
            updateBuyPreview();
        }
        
        function updateBuyPreview() {
            const input = document.getElementById('buy-coins-amount');
            let amount = parseInt(input.value) || 10;
            amount = Math.max(10, Math.min(100, amount));
            const preview = document.getElementById('buy-preview');
            if (preview) {
                preview.innerHTML = `
                    <div style="font-size: 0.9rem; color: var(--text-muted); margin-bottom: 4px;">Total</div>
                    <div style="font-size: 2rem; font-weight: 700; color: var(--accent-green);">$${amount}</div>
                `;
            }
        }
        
        function purchaseCoinsFromInput() {
            const input = document.getElementById('buy-coins-amount');
            let amount = parseInt(input.value) || 10;
            amount = Math.max(10, Math.min(100, amount));
            purchaseCoins(amount);
        }
        
        async function purchaseCoins(amount) {
            if (!currentUser) {
                showToast('Please sign in to purchase coins');
                return;
            }
            
            if (amount < 10 || amount > 100) {
                showToast('Please select 10-100 coins', 'error');
                return;
            }
            
            closeGenericSheet();
            showToast('ðŸ”„ Preparing checkout...');
            
            try {
                // Call Firebase function to create Stripe checkout session
                const createCheckout = firebase.functions().httpsCallable('createCoinCheckout');
                const result = await createCheckout({ 
                    coinAmount: amount,
                    successUrl: window.location.href.split('?')[0] + '?purchase=success',
                    cancelUrl: window.location.href.split('?')[0] + '?purchase=cancelled'
                });
                
                // Redirect to Stripe checkout
                if (result.data.checkoutUrl) {
                    window.location.href = result.data.checkoutUrl;
                } else {
                    throw new Error('No checkout URL returned');
                }
                
            } catch (error) {
                console.error('Purchase error:', error);
                // Show more specific error message
                const message = error.message || error.details || 'Purchase failed';
                if (message.includes('unauthenticated')) {
                    showToast('Please sign in to purchase', 'error');
                } else if (message.includes('internal')) {
                    showToast('Payment service error. Try again.', 'error');
                } else {
                    showToast('Purchase error: ' + message, 'error');
                }
            }
        }
        
        function showConvertCoinsSheet() {
            const coins = appData.wallet?.coins || 0;
            
            if (coins === 0) {
                showToast('No coins to convert');
                return;
            }
            
            closeGenericSheet();
            showGenericSheet({
                title: 'ðŸ”„ Convert Coins to Tokens',
                content: `
                    <div style="padding: 20px; text-align: center;">
                        <div style="font-size: 2.5rem; margin-bottom: 8px;">ðŸª™ â†’ ðŸ’Ž</div>
                        <div style="margin-bottom: 20px;">
                            <div style="font-size: 1.2rem; font-weight: 600;">You have ${coins} coins</div>
                            <div style="color: var(--text-muted); font-size: 0.85rem;">1 coin = 100 tokens</div>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 8px; font-size: 0.9rem;">Convert how many coins?</label>
                            <input type="number" id="convert-coins-amount" min="1" max="${coins}" value="1" 
                                style="width: 80px; padding: 12px; text-align: center; font-size: 1.2rem; border-radius: 8px; border: 2px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary);"
                                onchange="updateConversionPreview()"
                                oninput="updateConversionPreview()"
                            >
                        </div>
                        
                        <div id="conversion-preview" style="padding: 16px; background: var(--bg-tertiary); border-radius: 12px; margin-bottom: 20px;">
                            <div style="font-size: 0.85rem; color: var(--text-muted);">You'll receive</div>
                            <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-purple);">ðŸ’Ž 100 tokens</div>
                        </div>
                        
                        <button class="btn-primary" style="width: 100%; padding: 14px;" onclick="convertCoins()">
                            Convert Coins
                        </button>
                    </div>
                `
            });
        }
        
        function updateConversionPreview() {
            const input = document.getElementById('convert-coins-amount');
            const amount = parseInt(input?.value) || 0;
            const tokens = amount * 100;
            const preview = document.getElementById('conversion-preview');
            if (preview) {
                preview.innerHTML = `
                    <div style="font-size: 0.85rem; color: var(--text-muted);">You'll receive</div>
                    <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-purple);">ðŸ’Ž ${tokens.toLocaleString()} tokens</div>
                `;
            }
        }
        
        async function convertCoins() {
            const input = document.getElementById('convert-coins-amount');
            const amount = parseInt(input?.value) || 0;
            const coins = appData.wallet?.coins || 0;
            
            if (amount < 1 || amount > coins) {
                showToast('Invalid amount', 'error');
                return;
            }
            
            try {
                // Update locally
                appData.wallet.coins -= amount;
                appData.wallet.tokens = (appData.wallet.tokens || 0) + (amount * 100);
                saveData();
                renderWallet();
                
                // v1.2.77: Play coin drop sound for wallet addition
                playSound('walletAdd');
                
                closeGenericSheet();
                showToast(`ðŸŽ‰ Converted ${amount} coin${amount > 1 ? 's' : ''} to ${(amount * 100).toLocaleString()} tokens!`);
                
                // Sync to cloud
                if (currentUser) {
                    await saveToCloud();
                }
                
                // Log activity
                logActivity('coins-converted', { coins: amount, tokens: amount * 100 });
            } catch (e) {
                console.error('Error converting coins:', e);
                showToast('Conversion saved locally', 'info');
            }
        }
        
        // Check for successful purchase on page load
        function checkPurchaseResult() {
            const params = new URLSearchParams(window.location.search);
            const purchaseStatus = params.get('purchase');
            
            if (purchaseStatus === 'success') {
                // Clear URL param
                window.history.replaceState({}, '', window.location.pathname + window.location.hash);
                
                // Refresh wallet from server (Stripe webhook will have updated it)
                setTimeout(async () => {
                    if (currentUser) {
                        await loadFromCloud();
                        renderWallet();
                    }
                    showToast('ðŸŽ‰ Purchase complete! Coins added to your wallet.');
                    
                    // Log activity
                    logActivity('coins-purchased', { status: 'success' });
                }, 1000);
            } else if (purchaseStatus === 'cancelled') {
                window.history.replaceState({}, '', window.location.pathname + window.location.hash);
                showToast('Purchase cancelled');
            }
        }
        
        // ============ ENGAGEMENT REWARDS ============
        // One-time and recurring token rewards for player engagement
        
        const GS_ORIGINAL_GAMES = ['quotle', 'slate', 'rungs', 'wordboxing'];
        
        // Initialize rewards tracking if needed
        function initRewardsTracking() {
            if (!appData.rewards) {
                appData.rewards = {
                    fiveDayStreak: false,   // 50 tokens for first 5-day streak
                    allGsGames: false       // 20 tokens for playing all 4 GS games
                };
            }
        }
        
        // Check for 5-day streak reward (50 tokens, one-time)
        function checkFiveDayStreakReward() {
            initRewardsTracking();
            
            if (appData.rewards.fiveDayStreak) return; // Already claimed
            
            // Check if any game has 5+ day streak
            const hasStreak = Object.values(appData.stats || {}).some(
                stat => (stat.currentStreak || 0) >= 5
            );
            
            if (hasStreak) {
                appData.rewards.fiveDayStreak = true;
                appData.wallet.tokens = (appData.wallet?.tokens || 0) + 50;
                saveData();
                renderWallet();
                
                // v1.2.77: Play coin drop sound
                playSound('walletAdd');
                
                // Show celebration
                setTimeout(() => {
                    showToast('ðŸŽ‰ +50 tokens for your first 5-day streak!');
                    logActivity('reward-earned', { type: 'five-day-streak', tokens: 50 });
                }, 1000);
            }
        }
        
        // Check for all GS games played reward (20 tokens, one-time)
        function checkAllGsGamesReward() {
            initRewardsTracking();
            
            if (appData.rewards.allGsGames) return; // Already claimed
            
            // Check if user has played all 4 GS original games
            const playedGames = Object.keys(appData.stats || {});
            const hasPlayedAll = GS_ORIGINAL_GAMES.every(gameId => 
                playedGames.includes(gameId) && 
                (appData.stats[gameId]?.gamesPlayed || 0) > 0
            );
            
            if (hasPlayedAll) {
                appData.rewards.allGsGames = true;
                appData.wallet.tokens = (appData.wallet?.tokens || 0) + 20;
                saveData();
                renderWallet();
                
                // v1.2.77: Play coin drop sound
                playSound('walletAdd');
                
                // Show celebration
                setTimeout(() => {
                    showToast('ðŸŽ‰ +20 tokens for trying all Game Shelf originals!');
                    logActivity('reward-earned', { type: 'all-gs-games', tokens: 20 });
                }, 1500);
            }
        }
        
        // Award tokens for coin-based battle participation (5 tokens per battle)
        function awardBattleParticipationTokens(battleName) {
            appData.wallet.tokens = (appData.wallet?.tokens || 0) + 5;
            saveData();
            renderWallet();
            
            // v1.2.77: Play coin drop sound
            playSound('walletAdd');
            
            showToast('ðŸŽŸï¸ +5 tokens for battle participation!');
            logActivity('reward-earned', { type: 'battle-participation', tokens: 5, battle: battleName });
        }

        // ============ STATS SCREEN (v1.3.0) ============
        function renderStatsScreen() {
            const summaryContainer = document.getElementById('stats-summary');
            const listContainer = document.getElementById('stats-game-list');
            if (!summaryContainer || !listContainer) return;
            
            // Calculate summary stats
            const todayPlayed = getGamesPlayedToday();
            const totalPlayed = Object.values(appData.stats).reduce((sum, s) => sum + (s.gamesPlayed || 0), 0);
            const maxStreak = getMaxStreak();
            const totalWins = Object.values(appData.stats).reduce((sum, s) => sum + (s.gamesWon || 0), 0);
            const overallWinRate = totalPlayed > 0 ? Math.round((totalWins / totalPlayed) * 100) : 0;
            
            // Render summary cards
            summaryContainer.innerHTML = `
                <div style="background: var(--bg-secondary); border-radius: 12px; padding: 16px; text-align: center;">
                    <div style="font-size: 2rem; font-weight: 700; color: var(--accent-purple);">${todayPlayed}</div>
                    <div style="font-size: 0.75rem; color: var(--text-muted);">Today</div>
                </div>
                <div style="background: var(--bg-secondary); border-radius: 12px; padding: 16px; text-align: center;">
                    <div style="font-size: 2rem; font-weight: 700; color: var(--accent-orange);">ðŸ”¥ ${maxStreak}</div>
                    <div style="font-size: 0.75rem; color: var(--text-muted);">Best Streak</div>
                </div>
                <div style="background: var(--bg-secondary); border-radius: 12px; padding: 16px; text-align: center;">
                    <div style="font-size: 2rem; font-weight: 700; color: var(--accent-green);">${totalPlayed}</div>
                    <div style="font-size: 0.75rem; color: var(--text-muted);">Total Played</div>
                </div>
                <div style="background: var(--bg-secondary); border-radius: 12px; padding: 16px; text-align: center;">
                    <div style="font-size: 2rem; font-weight: 700; color: var(--text-primary);">${overallWinRate}%</div>
                    <div style="font-size: 0.75rem; color: var(--text-muted);">Win Rate</div>
                </div>
            `;
            
            // Render per-game stats
            const gamesWithStats = appData.games
                .map(g => {
                    const game = GAMES[g.id];
                    const stats = appData.stats[g.id] || {};
                    return {
                        id: g.id,
                        game: game,
                        stats: stats,
                        currentStreak: stats.currentStreak || 0,
                        maxStreak: stats.maxStreak || 0,
                        gamesPlayed: stats.gamesPlayed || 0,
                        gamesWon: stats.gamesWon || 0
                    };
                })
                .filter(g => g.game) // Filter out invalid games
                .sort((a, b) => b.currentStreak - a.currentStreak); // Sort by current streak
            
            if (gamesWithStats.length === 0) {
                listContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: var(--text-muted);">
                        <div style="font-size: 3rem; margin-bottom: 16px;">ðŸ“Š</div>
                        <div style="font-size: 1rem; margin-bottom: 8px;">No stats yet</div>
                        <div style="font-size: 0.85rem;">Play some games or import stats from screenshots!</div>
                    </div>
                `;
                return;
            }
            
            listContainer.innerHTML = gamesWithStats.map(g => {
                const winRate = g.gamesPlayed > 0 ? Math.round((g.gamesWon / g.gamesPlayed) * 100) : 0;
                const todayResult = getTodayHistory()[g.id];
                
                return `
                    <div class="stats-game-row" onclick="showGameStatsDetail('${g.id}')" style="
                        background: var(--bg-secondary);
                        border-radius: 12px;
                        padding: 14px 16px;
                        display: flex;
                        align-items: center;
                        gap: 14px;
                        cursor: pointer;
                        transition: background 0.2s;
                    ">
                        <div style="font-size: 1.8rem; width: 44px; text-align: center;">${g.game.icon}</div>
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-weight: 600; font-size: 0.95rem; display: flex; align-items: center; gap: 8px;">
                                ${g.game.name}
                                ${todayResult ? '<span style="font-size: 0.7rem; background: var(--accent-green); color: white; padding: 2px 6px; border-radius: 4px;">Today âœ“</span>' : ''}
                            </div>
                            <div style="font-size: 0.75rem; color: var(--text-muted); margin-top: 2px;">
                                ${g.gamesPlayed} played â€¢ ${winRate}% wins
                            </div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 1.1rem; font-weight: 700; color: ${g.currentStreak > 0 ? 'var(--accent-orange)' : 'var(--text-muted)'};">
                                ${g.currentStreak > 0 ? 'ðŸ”¥ ' + g.currentStreak : 'â€”'}
                            </div>
                            <div style="font-size: 0.65rem; color: var(--text-muted);">
                                ${g.currentStreak > 0 ? 'streak' : 'no streak'}
                            </div>
                        </div>
                        <div style="color: var(--text-muted); font-size: 0.8rem;">â€º</div>
                    </div>
                `;
            }).join('');
        }
        
        // Show detailed stats for a single game
        function showGameStatsDetail(gameId) {
            const game = GAMES[gameId];
            const stats = appData.stats[gameId] || {};
            const todayResult = getTodayHistory()[gameId];
            
            if (!game) return;
            
            const winRate = stats.gamesPlayed > 0 ? Math.round((stats.gamesWon / stats.gamesPlayed) * 100) : 0;
            
            showGenericSheet({
                title: `${game.icon} ${game.name} Stats`,
                content: `
                    <div style="padding: 20px;">
                        <!-- Current Status -->
                        ${todayResult ? `
                            <div style="background: var(--accent-green); color: white; padding: 12px; border-radius: 10px; text-align: center; margin-bottom: 20px;">
                                âœ“ Played today: <strong>${todayResult.score}</strong>
                            </div>
                        ` : `
                            <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 10px; text-align: center; margin-bottom: 20px; color: var(--text-muted);">
                                Not played today
                            </div>
                        `}
                        
                        <!-- Stats Grid -->
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 20px;">
                            <div style="background: var(--bg-tertiary); border-radius: 10px; padding: 16px; text-align: center;">
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-orange);">ðŸ”¥ ${stats.currentStreak || 0}</div>
                                <div style="font-size: 0.75rem; color: var(--text-muted);">Current Streak</div>
                            </div>
                            <div style="background: var(--bg-tertiary); border-radius: 10px; padding: 16px; text-align: center;">
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-purple);">ðŸ† ${stats.maxStreak || 0}</div>
                                <div style="font-size: 0.75rem; color: var(--text-muted);">Best Streak</div>
                            </div>
                            <div style="background: var(--bg-tertiary); border-radius: 10px; padding: 16px; text-align: center;">
                                <div style="font-size: 1.8rem; font-weight: 700;">${stats.gamesPlayed || 0}</div>
                                <div style="font-size: 0.75rem; color: var(--text-muted);">Games Played</div>
                            </div>
                            <div style="background: var(--bg-tertiary); border-radius: 10px; padding: 16px; text-align: center;">
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-green);">${winRate}%</div>
                                <div style="font-size: 0.75rem; color: var(--text-muted);">Win Rate</div>
                            </div>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div style="display: flex; flex-direction: column; gap: 10px;">
                            <button onclick="closeGenericSheet(); playGame('${gameId}')" style="
                                width: 100%;
                                padding: 14px;
                                background: var(--accent-purple);
                                border: none;
                                border-radius: 10px;
                                color: white;
                                font-size: 1rem;
                                font-weight: 600;
                                cursor: pointer;
                            ">
                                ${todayResult ? 'ðŸ”„ Play Again' : 'â–¶ï¸ Play Now'}
                            </button>
                            <button onclick="closeGenericSheet(); handleRecordGame()" style="
                                width: 100%;
                                padding: 14px;
                                background: var(--bg-tertiary);
                                border: 1px solid var(--border);
                                border-radius: 10px;
                                color: var(--text-primary);
                                font-size: 1rem;
                                cursor: pointer;
                            ">
                                ðŸ“· Import Stats from Screenshot
                            </button>
                        </div>
                    </div>
                `
            });
        }
        
        function renderQuickGames() {
            const container = document.getElementById('quick-games');
            const shelf = appData.games.slice(0, 6);
            const todayHistory = getTodayHistory();
            
            // v1.3.0: Quick game buttons now play the game (not open log sheet)
            // v1.3.1: Added long-press support for consistency with game grid
            container.innerHTML = shelf.map(g => {
                const game = GAMES[g.id];
                if (!game) return '';
                const done = todayHistory[g.id];
                return `<button class="quick-game-btn ${done ? 'done' : ''}" 
                    data-game-id="${g.id}"
                    title="${game.name}">${game.icon}</button>`;
            }).join('');
            
            // v1.3.1: Setup long-press and click handlers for quick game buttons
            container.querySelectorAll('.quick-game-btn[data-game-id]').forEach(btn => {
                const gameId = btn.dataset.gameId;
                btn.onclick = () => playGame(gameId);
                setupLongPress(btn, gameId);
            });
        }
        
        function renderProgress() {
            const played = getGamesPlayedToday() || 0;
            const goal = appData.dailyGoal || 5;
            const pct = goal > 0 ? Math.min(100, (played / goal) * 100) : 0;
            // v1.3.1: Show current streak (not all-time best) - more relevant for daily motivation
            const currentStreak = getCurrentMaxStreak() || 0;
            
            document.getElementById('progress-bar').style.width = (isNaN(pct) ? 0 : pct) + '%';
            document.getElementById('goal-display').textContent = `${played}/${goal} games`;
            document.getElementById('streak-badge').textContent = `ðŸ”¥ ${currentStreak}`;
            
            // Show/hide share button based on games played
            const shareBtn = document.getElementById('share-today-btn');
            if (shareBtn) {
                shareBtn.style.display = played > 0 ? 'flex' : 'none';
            }
            
            // Update header share button badge
            const headerShareBtn = document.getElementById('header-share-btn');
            if (headerShareBtn) {
                if (played > 0) {
                    headerShareBtn.classList.add('has-badge');
                    headerShareBtn.setAttribute('data-badge', played);
                } else {
                    headerShareBtn.classList.remove('has-badge');
                }
            }
            
            if (played === 0) {
                document.getElementById('games-today-text').textContent = 'Play your first game!';
            } else if (played >= goal) {
                document.getElementById('games-today-text').textContent = 'ðŸŽ‰ Goal reached!';
            } else {
                document.getElementById('games-today-text').textContent = `${goal - played} more to go`;
            }
        }
        
        function renderHomeGames() {
            const container = document.getElementById('home-games-grid');
            if (!container) return;
            
            const shelf = appData.games.slice(0, 6);
            const todayHistory = getTodayHistory();
            
            // Update header to show if there are more games on shelf
            const totalGamesCount = document.getElementById('total-games-count');
            const totalOnShelf = appData.games.length;
            if (totalGamesCount) {
                if (totalOnShelf > 6) {
                    totalGamesCount.textContent = `+${totalOnShelf - 6} more`;
                } else {
                    totalGamesCount.textContent = '';
                }
            }
            
            // If no games on shelf, show empty state with add button
            if (shelf.length === 0) {
                container.innerHTML = `
                    <div style="grid-column: 1/-1; text-align: center; padding: 20px; color: var(--text-muted);">
                        <div style="font-size: 2rem; margin-bottom: 8px;">ðŸŽ®</div>
                        <div style="margin-bottom: 12px;">No games on your shelf yet!</div>
                        <button onclick="switchTab('games')" style="background: var(--accent-purple); color: white; border: none; padding: 10px 20px; border-radius: 10px; font-weight: 600; cursor: pointer;">
                            Browse Games â†’
                        </button>
                    </div>`;
                return;
            }
            
            container.innerHTML = shelf.map(g => {
                const game = GAMES[g.id];
                if (!game) return '';
                const done = todayHistory[g.id];
                const stats = appData.stats[g.id];
                const streak = stats?.currentStreak || 0;
                
                let status = streak > 0 ? `ðŸ”¥ ${streak}` : 'Play';
                if (done) status = `âœ“ ${done.score}`;
                
                return `<div class="game-card ${done ? 'done' : ''}" onclick="playGame('${g.id}')" data-game-id="${g.id}">
                    <div class="game-icon">${game.icon}</div>
                    <div class="game-name">${game.name}</div>
                    <div class="game-status">${status}</div>
                </div>`;
            }).join('');
            
            // v1.3.0: Setup long-press for each game card
            container.querySelectorAll('.game-card[data-game-id]').forEach(card => {
                setupLongPress(card, card.dataset.gameId);
            });
        }
        
        function renderShelfGames() {
            const container = document.getElementById('shelf-games-grid');
            const todayHistory = getTodayHistory();
            
            // Update shelf count
            const shelfCount = document.getElementById('shelf-count');
            if (shelfCount) shelfCount.textContent = `(${appData.games.length})`;
            
            if (appData.games.length === 0) {
                container.innerHTML = `<div style="grid-column: 1/-1; text-align: center; padding: 20px; color: var(--text-muted);">
                    No games on your shelf yet.<br>Browse below to add some!
                </div>`;
                return;
            }
            
            container.innerHTML = appData.games.map(g => {
                const game = GAMES[g.id];
                if (!game) return '';
                const done = todayHistory[g.id];
                const stats = appData.stats[g.id];
                const streak = stats?.currentStreak || 0;
                
                let status = streak > 0 ? `ðŸ”¥ ${streak}` : 'Play';
                if (done) status = `âœ“ ${done.score}`;
                
                return `<div class="game-card ${done ? 'done' : ''}" onclick="playGame('${g.id}')" data-game-id="${g.id}">
                    <div class="game-icon">${game.icon}</div>
                    <div class="game-name">${game.name}</div>
                    <div class="game-status">${status}</div>
                </div>`;
            }).join('');
            
            // v1.3.0: Setup long-press for each game card
            container.querySelectorAll('.game-card[data-game-id]').forEach(card => {
                setupLongPress(card, card.dataset.gameId);
            });
        }
        
        function renderPopularGames() {
            // Now renders browse categories instead
            renderBrowseCategories();
        }
        
        function renderBrowseCategories() {
            const container = document.getElementById('browse-categories');
            if (!container) return;
            
            const onShelf = new Set(appData.games.map(g => g.id));
            
            container.innerHTML = GAME_CATEGORIES.map(cat => {
                const gamesNotOnShelf = cat.games.filter(id => !onShelf.has(id) && GAMES[id]);
                const allOnShelf = gamesNotOnShelf.length === 0;
                
                return `
                    <div class="game-category-accordion">
                        <div class="game-category-header" onclick="toggleGameCategory('${cat.id}')" id="cat-header-${cat.id}">
                            <div class="game-category-left">
                                <span class="game-category-icon">${cat.icon}</span>
                                <span class="game-category-name">${cat.name}</span>
                                <span class="game-category-count">(${cat.games.length})</span>
                            </div>
                            <div class="game-category-right">
                                ${!allOnShelf ? `<button class="add-all-btn" onclick="event.stopPropagation(); addAllFromCategory('${cat.id}')">+ All</button>` : '<span class="all-added-badge">âœ“ All added</span>'}
                                <span class="game-category-chevron">â–¼</span>
                            </div>
                        </div>
                        <div class="game-category-content" id="cat-content-${cat.id}">
                            ${cat.games.map(gameId => {
                                const game = GAMES[gameId];
                                if (!game) return '';
                                const isOnShelf = onShelf.has(gameId);
                                return `
                                    <div class="game-mini-card ${isOnShelf ? 'on-shelf' : ''}" 
                                         onclick="${isOnShelf ? `showToast('${game.name} already on shelf')` : `addToShelf('${gameId}')`}">
                                        <span class="game-mini-icon">${game.icon}</span>
                                        <div class="game-mini-info">
                                            <div class="game-mini-name">${game.name}</div>
                                            <div class="game-mini-status ${isOnShelf ? 'on-shelf' : ''}">${isOnShelf ? 'âœ“ On shelf' : 'Tap to add'}</div>
                                        </div>
                                        ${!isOnShelf ? '<span class="game-mini-add">+ Add</span>' : ''}
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // v1.3.0: Added confirmation dialog before bulk adding
        function addAllFromCategory(catId) {
            const category = GAME_CATEGORIES.find(c => c.id === catId);
            if (!category) return;
            
            const onShelf = new Set(appData.games.map(g => g.id));
            const gamesToAdd = category.games.filter(id => !onShelf.has(id) && GAMES[id]);
            
            if (gamesToAdd.length === 0) {
                showToast('All games from this category are already on your shelf!');
                return;
            }
            
            // v1.3.0: Show confirmation before adding multiple games
            showConfirmModal({
                icon: category.icon,
                title: `Add ${gamesToAdd.length} Games?`,
                message: `Add all ${gamesToAdd.length} ${category.name} games to your shelf?`,
                confirmText: `Add ${gamesToAdd.length} Games`,
                confirmStyle: 'primary',
                onConfirm: () => {
                    // Add all games
                    gamesToAdd.forEach(gameId => {
                        appData.games.push({ id: gameId, addedAt: new Date().toISOString() });
                    });
                    
                    saveData();
                    syncToCloud();
                    renderAll();
                    
                    SoundManager.play('reward');
                    showToast(`Added ${gamesToAdd.length} ${category.name} game${gamesToAdd.length > 1 ? 's' : ''}!`, 'success');
                }
            });
        }
        
        // v1.3.0: Save and restore category expanded state
        function toggleGameCategory(catId) {
            const header = document.getElementById('cat-header-' + catId);
            const content = document.getElementById('cat-content-' + catId);
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                header.classList.remove('expanded');
            } else {
                content.classList.add('expanded');
                header.classList.add('expanded');
            }
            
            // v1.3.0: Save expanded state to localStorage
            saveCategoryExpandedState();
        }
        
        function saveCategoryExpandedState() {
            const expanded = [];
            document.querySelectorAll('.game-category-content.expanded').forEach(el => {
                const catId = el.id.replace('cat-content-', '');
                expanded.push(catId);
            });
            localStorage.setItem('gs_expanded_categories', JSON.stringify(expanded));
        }
        
        function restoreCategoryExpandedState() {
            try {
                const expanded = JSON.parse(localStorage.getItem('gs_expanded_categories') || '[]');
                expanded.forEach(catId => {
                    const header = document.getElementById('cat-header-' + catId);
                    const content = document.getElementById('cat-content-' + catId);
                    if (header) header.classList.add('expanded');
                    if (content) content.classList.add('expanded');
                });
            } catch (e) {
                console.error('Error restoring category state:', e);
            }
        }
        
        // Search/filter games
        // v1.3.0: Search/filter games - also searches category names and shows streaks
        function filterGames(query) {
            const searchResults = document.getElementById('games-search-results');
            const listContainer = document.getElementById('games-list-container');
            const resultsGrid = document.getElementById('search-results-grid');
            
            if (!query || query.trim() === '') {
                searchResults.style.display = 'none';
                listContainer.style.display = 'block';
                return;
            }
            
            const q = query.toLowerCase();
            const onShelf = new Set(appData.games.map(g => g.id));
            const todayHistory = getTodayHistory();
            
            // Find games matching name
            let matches = Object.values(GAMES).filter(game => 
                game.name.toLowerCase().includes(q)
            );
            
            // v1.3.0: Also include games from matching categories
            GAME_CATEGORIES.forEach(cat => {
                if (cat.name.toLowerCase().includes(q)) {
                    cat.games.forEach(gameId => {
                        const game = GAMES[gameId];
                        if (game && !matches.find(m => m.id === gameId)) {
                            matches.push(game);
                        }
                    });
                }
            });
            
            if (matches.length === 0) {
                searchResults.style.display = 'block';
                listContainer.style.display = 'none';
                resultsGrid.innerHTML = `<div style="grid-column: 1/-1; text-align: center; padding: 20px; color: var(--text-muted);">No games found for "${escapeHtml(query)}"</div>`;
                return;
            }
            
            searchResults.style.display = 'block';
            listContainer.style.display = 'none';
            
            resultsGrid.innerHTML = matches.map(game => {
                const isOnShelf = onShelf.has(game.id);
                const done = todayHistory[game.id];
                const stats = appData.stats[game.id];
                const streak = stats?.currentStreak || 0;
                
                // v1.3.0: Show streaks for shelf games, or add prompt
                let status;
                if (isOnShelf) {
                    if (done) {
                        status = `âœ“ ${done.score}`;
                    } else if (streak > 0) {
                        status = `ðŸ”¥ ${streak}`;
                    } else {
                        status = 'âœ“ On shelf';
                    }
                } else {
                    status = '+ Add';
                }
                
                return `<div class="game-card ${done ? 'done' : ''}" 
                            onclick="${isOnShelf ? `playGame('${game.id}')` : `addToShelf('${game.id}')`}"
                            data-game-id="${game.id}">
                    <div class="game-icon">${game.icon}</div>
                    <div class="game-name">${game.name}</div>
                    <div class="game-status">${status}</div>
                </div>`;
            }).join('');
            
            // v1.3.0: Setup long-press for search result cards
            resultsGrid.querySelectorAll('.game-card[data-game-id]').forEach(card => {
                setupLongPress(card, card.dataset.gameId);
            });
        }
        
        // Suggest a game functions
        function showSuggestGame() {
            document.getElementById('suggest-game-name').value = '';
            document.getElementById('suggest-game-url').value = '';
            document.getElementById('suggest-game-category').value = '';
            document.getElementById('suggest-game-error').style.display = 'none';
            document.getElementById('suggest-game-sheet').classList.add('active');
        }
        
        function closeSuggestGame() {
            document.getElementById('suggest-game-sheet').classList.remove('active');
        }
        
        async function submitGameSuggestion() {
            const name = document.getElementById('suggest-game-name').value.trim();
            const url = document.getElementById('suggest-game-url').value.trim();
            const category = document.getElementById('suggest-game-category').value;
            const errorEl = document.getElementById('suggest-game-error');
            
            if (!name || !url) {
                errorEl.textContent = 'Please fill in game name and URL';
                errorEl.style.display = 'block';
                return;
            }
            
            if (!url.startsWith('http')) {
                errorEl.textContent = 'Please enter a valid URL';
                errorEl.style.display = 'block';
                return;
            }
            
            try {
                // Store suggestion in Firebase
                await db.ref('game-suggestions').push({
                    name: name,
                    url: url,
                    category: category || 'other',
                    suggestedBy: currentUser?.uid || 'anonymous',
                    suggestedByName: currentUser?.displayName || 'Anonymous',
                    timestamp: Date.now(),
                    status: 'pending'
                });
                
                closeSuggestGame();
                showToast('âœ“ Thanks! We\'ll review your suggestion.');
                
            } catch (e) {
                console.error('Failed to submit suggestion:', e);
                errorEl.textContent = 'Could not submit. Try again.';
                errorEl.style.display = 'block';
            }
        }
        
        function renderLeaderboard() {
            const container = document.getElementById('leaderboard-list');
            
            // Mock leaderboard for now
            const leaderboard = [
                { name: 'You', streak: getMaxStreak(), score: getGamesPlayedToday() * 10, isYou: true },
            ];
            
            if (leaderboard.length === 0 || (leaderboard.length === 1 && leaderboard[0].score === 0)) {
                container.innerHTML = `<div class="empty-state">
                    <div class="empty-icon">ðŸ†</div>
                    <div class="empty-title">Play games to rank!</div>
                    <div class="empty-desc">Your daily scores appear here</div>
                </div>`;
                return;
            }
            
            container.innerHTML = leaderboard.map((p, i) => {
                const rankClass = i === 0 ? 'gold' : i === 1 ? 'silver' : i === 2 ? 'bronze' : '';
                return `<div class="leaderboard-item">
                    <div class="leaderboard-rank ${rankClass}">${i + 1}</div>
                    <div class="leaderboard-info">
                        <div class="leaderboard-name">${p.name}${p.isYou ? ' (You)' : ''}</div>
                        <div class="leaderboard-streak">ðŸ”¥ ${p.streak} streak</div>
                    </div>
                    <div class="leaderboard-score">${p.score} pts</div>
                </div>`;
            }).join('');
        }
        
        function renderFriendsWidget() {
            const container = document.getElementById('friends-row');
            if (!container) return;
            
            if (!currentUser || friendsData.length === 0) {
                container.innerHTML = `<div style="padding: 10px; font-size: 0.85rem; color: var(--text-muted);">
                    ${currentUser ? 'Add friends to see their progress' : 'Sign in to see friends'}
                </div>`;
                return;
            }
            
            // Show up to 6 friends
            const displayFriends = friendsData.slice(0, 6);
            
            // v1.3.1: Added friend names below avatars for better identification
            container.innerHTML = displayFriends.map(friend => {
                const shelfData = friend.shelfData || {};
                const hasPlayed = (shelfData.todayCount || 0) > 0;
                const initial = (friend.displayName || 'U')[0].toUpperCase();
                const firstName = (friend.displayName || 'Friend').split(' ')[0];
                
                return `
                    <div class="friend-item ${hasPlayed ? 'played' : 'waiting'}" onclick="showFriendProfile('${friend.odataId}')">
                        <div class="friend-avatar">
                            ${shelfData.photoURL 
                                ? `<img src="${shelfData.photoURL}" alt="" style="width:100%;height:100%;border-radius:50%;object-fit:cover;">` 
                                : initial}
                        </div>
                        <div class="friend-name">${escapeHtml(firstName)}</div>
                        <div class="friend-status">${hasPlayed ? 'âœ“' : '...'}</div>
                    </div>
                `;
            }).join('');
        }
        
        // ============ GAME TRACKING IMPROVEMENTS ============
        let lastLaunchedGame = null;
        let lastLaunchTime = null;
        let clipboardPlusInterval = null;
        let lastClipboardContent = null;
        let returnPromptDismissedFor = null;
        let returnPromptDismissedAt = null; // v1.2.3: Track when dismissed for time decay
        let lastConfidenceScore = null;
        let promptShownTime = null;
        
        // ============ ANALYTICS SYSTEM ============
        const ANALYTICS_EVENTS = {
            GAME_LAUNCH: 'game_launch',
            GAME_RETURN: 'game_return',
            GAME_LOGGED: 'game_logged',
            PROMPT_SHOWN: 'prompt_shown',
            PROMPT_DISMISSED: 'prompt_dismissed',
            PROMPT_ACCEPTED: 'prompt_accepted',
            PROMPT_TIMEOUT: 'prompt_timeout',
            TUTORIAL_STARTED: 'tutorial_started',
            TUTORIAL_COMPLETED: 'tutorial_completed',
            TUTORIAL_SKIPPED: 'tutorial_skipped',
            CLIPBOARD_READ_SUCCESS: 'clipboard_read_success',
            CLIPBOARD_READ_FAILED: 'clipboard_read_failed',
            PUBLISHER_PREF_SET: 'publisher_pref_set'
        };
        
        let sessionId = null;
        function getSessionId() {
            if (!sessionId) {
                sessionId = Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
            }
            return sessionId;
        }
        
        function getPlatform() {
            const ua = navigator.userAgent;
            if (/iPad|iPhone|iPod/.test(ua)) return 'ios';
            if (/Android/.test(ua)) return 'android';
            return 'desktop';
        }
        
        function trackEvent(eventType, data = {}) {
            const event = {
                type: eventType,
                timestamp: Date.now(),
                sessionId: getSessionId(),
                data: {
                    ...data,
                    platform: getPlatform(),
                    isStandalone: isStandalone(),
                    appVersion: APP_VERSION
                }
            };
            
            // Store locally
            try {
                const events = JSON.parse(localStorage.getItem('gs_analytics') || '[]');
                events.push(event);
                if (events.length > 500) events.splice(0, events.length - 500);
                localStorage.setItem('gs_analytics', JSON.stringify(events));
            } catch (e) {
                console.warn('Analytics storage failed:', e);
            }
            
            // Update daily dismiss count if needed
            if (eventType === ANALYTICS_EVENTS.PROMPT_DISMISSED) {
                incrementDismissCount();
            }
            
            console.log(`ðŸ“Š Analytics: ${eventType}`, data);
        }
        
        function getTodayDismissCount() {
            try {
                const data = JSON.parse(localStorage.getItem('gs_dismiss_tracking') || '{}');
                const today = getTodayString();
                return data[today] || 0;
            } catch (e) {
                return 0;
            }
        }
        
        function incrementDismissCount() {
            try {
                const data = JSON.parse(localStorage.getItem('gs_dismiss_tracking') || '{}');
                const today = getTodayString();
                data[today] = (data[today] || 0) + 1;
                // Clean up old days (keep last 7)
                const keys = Object.keys(data).sort().reverse();
                keys.slice(7).forEach(k => delete data[k]);
                localStorage.setItem('gs_dismiss_tracking', JSON.stringify(data));
                return data[today];
            } catch (e) {
                return 1;
            }
        }
        
        function getAnalyticsSummary(dateString = getTodayString()) {
            try {
                const events = JSON.parse(localStorage.getItem('gs_analytics') || '[]');
                const dayStart = new Date(dateString + 'T00:00:00').getTime();
                const dayEnd = dayStart + 86400000;
                const dayEvents = events.filter(e => e.timestamp >= dayStart && e.timestamp < dayEnd);
                
                const launches = dayEvents.filter(e => e.type === 'game_launch').length;
                const logs = dayEvents.filter(e => e.type === 'game_logged').length;
                
                return {
                    date: dateString,
                    launches: launches,
                    returns: dayEvents.filter(e => e.type === 'game_return').length,
                    logsTotal: logs,
                    logsAuto: dayEvents.filter(e => e.type === 'game_logged' && e.data?.logMethod === 'auto').length,
                    logsPrompt: dayEvents.filter(e => e.type === 'game_logged' && e.data?.logMethod === 'prompt').length,
                    logsManual: dayEvents.filter(e => e.type === 'game_logged' && e.data?.logMethod === 'manual').length,
                    promptsShown: dayEvents.filter(e => e.type === 'prompt_shown').length,
                    promptsDismissed: dayEvents.filter(e => e.type === 'prompt_dismissed').length,
                    conversionRate: launches > 0 ? (logs / launches * 100).toFixed(1) + '%' : 'N/A'
                };
            } catch (e) {
                return { error: e.message };
            }
        }
        
        // Make analytics accessible for UAT
        window.gsAnalytics = {
            getSummary: getAnalyticsSummary,
            getEvents: () => JSON.parse(localStorage.getItem('gs_analytics') || '[]'),
            clearEvents: () => localStorage.removeItem('gs_analytics'),
            getDetectionFailures: () => {
                const events = JSON.parse(localStorage.getItem('gs_analytics') || '[]');
                return events.filter(e => e.type === 'detection_failure');
            },
            getDetectionRate: () => {
                const events = JSON.parse(localStorage.getItem('gs_analytics') || '[]');
                const logs = events.filter(e => e.type === 'game_logged');
                const autoLogs = logs.filter(e => e.data?.logMethod === 'auto');
                const promptLogs = logs.filter(e => e.data?.logMethod === 'prompt');
                const manualLogs = logs.filter(e => e.data?.logMethod === 'manual' || e.data?.logMethod === 'quick-log');
                const failures = events.filter(e => e.type === 'detection_failure');
                return {
                    total: logs.length,
                    auto: autoLogs.length,
                    prompt: promptLogs.length,
                    manual: manualLogs.length,
                    failures: failures.length,
                    detectionRate: logs.length > 0 ? ((autoLogs.length + promptLogs.length) / logs.length * 100).toFixed(1) + '%' : 'N/A'
                };
            }
        };
        
        // Track game log and detect potential detection failures
        function trackGameLog(result, logMethod) {
            const gameInfo = GAMES[result.gameId];
            const timeSinceLaunch = lastLaunchTime ? Date.now() - lastLaunchTime : null;
            
            // Track the log event
            trackEvent(ANALYTICS_EVENTS.GAME_LOGGED, {
                gameId: result.gameId,
                gameName: gameInfo?.name,
                logMethod: logMethod,
                timeSinceLaunch: timeSinceLaunch,
                confidenceScore: lastConfidenceScore,
                launchedFromGS: lastLaunchedGame === result.gameId
            });
            
            // Detect potential detection failures
            // If user manually logged a game we launched and should have detected
            if (logMethod === 'manual' || logMethod === 'quick-log' || logMethod === 'paste') {
                if (lastLaunchedGame === result.gameId && timeSinceLaunch && timeSinceLaunch < 30 * 60 * 1000) {
                    // This was a detection failure - we launched this game but didn't auto-detect
                    trackEvent('detection_failure', {
                        gameId: result.gameId,
                        gameName: gameInfo?.name,
                        logMethod: logMethod,
                        timeSinceLaunch: timeSinceLaunch,
                        lastConfidenceScore: lastConfidenceScore,
                        clipboardWasUnknown: clipboardOnLeave === CLIPBOARD_UNKNOWN,
                        platform: getPlatform(),
                        // Why might we have failed?
                        possibleCauses: detectFailureCauses()
                    });
                    console.warn(`âš ï¸ Detection failure: User manually logged ${gameInfo?.name || result.gameId} that we launched ${Math.round(timeSinceLaunch/1000)}s ago`);
                }
            }
        }
        
        // Analyze why detection might have failed
        function detectFailureCauses() {
            const causes = [];
            
            if (clipboardOnLeave === CLIPBOARD_UNKNOWN) {
                causes.push('clipboard_read_failed_on_leave');
            }
            
            if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
                causes.push('ios_clipboard_requires_gesture');
            }
            
            if (lastConfidenceScore !== null && lastConfidenceScore < 50) {
                causes.push('low_confidence_score');
            }
            
            if (getTodayDismissCount() >= 2) {
                causes.push('multiple_dismissals_penalty');
            }
            
            if (!lastLaunchTime) {
                causes.push('launch_time_not_tracked');
            }
            
            return causes;
        }
        
        // ============ RETURN CONFIDENCE ALGORITHM ============
        // v1.2.3: Added mismatch penalty, game-aware time thresholds, dismiss time decay
        function calculateReturnConfidence(context) {
            let score = 0;
            let signals = {};
            
            // ===== POSITIVE SIGNALS =====
            
            // 1. Clipboard contains valid game result (+25 base)
            if (context.clipboardHasGameResult) {
                score += 25;
                signals.hasGameResult = true;
                
                // Bonus: Result matches launched game (+15)
                if (context.resultMatchesLaunchedGame) {
                    score += 15;
                    signals.matchesLaunchedGame = true;
                }
            }
            
            // 2. Clipboard actually changed from when they left (+20)
            if (context.clipboardChanged && context.clipboardOnLeave !== CLIPBOARD_UNKNOWN) {
                score += 20;
                signals.clipboardChanged = true;
            }
            
            // 3. Time away is reasonable for playing a game (+15 max)
            // v1.2.3: Game-aware thresholds for quick games
            const minutesAway = context.timeAway / 60000;
            const isQuickGame = context.lastLaunchedGame && QUICK_GAMES.includes(context.lastLaunchedGame);
            const minTimeThreshold = isQuickGame ? 0.33 : 0.5; // 20s for quick games, 30s for others
            
            if (minutesAway >= 1 && minutesAway <= 15) {
                score += 15;
                signals.timeAwayOptimal = true;
            } else if (minutesAway > 15 && minutesAway <= 30) {
                score += 10;
                signals.timeAwayReasonable = true;
            } else if (minutesAway >= minTimeThreshold && minutesAway < 1) {
                score += 5;
                signals.timeAwayQuick = true;
                if (isQuickGame) signals.quickGameBonus = true;
            }
            
            // 4. User has history of logging this game (+10)
            if (context.hasLoggedThisGameBefore) {
                score += 10;
                signals.hasHistory = true;
            }
            
            // 5. This game not yet logged today (+5)
            if (!context.alreadyLoggedToday) {
                score += 5;
                signals.notLoggedToday = true;
            }
            
            // ===== NEGATIVE SIGNALS =====
            
            // 6. User dismissed prompt for this game recently (-20)
            // v1.2.3: Check if dismissal was within last 2 hours
            if (context.dismissedPromptRecently) {
                const hoursSinceDismiss = context.hoursSinceLastDismiss || 0;
                if (hoursSinceDismiss < 2) {
                    score -= 20;
                    signals.recentlyDismissed = true;
                } else {
                    // Dismissal was >2 hours ago, reduced penalty
                    score -= 5;
                    signals.dismissedButDecayed = true;
                }
            }
            
            // 7. Multiple prompts today with no logs (-10 per, max -20)
            // v1.2.3: Reduced max penalty from -30 to -20
            const dismissPenalty = Math.min(context.todayDismissCount * 10, 20);
            if (dismissPenalty > 0) {
                score -= dismissPenalty;
                signals.multipleDismissals = context.todayDismissCount;
            }
            
            // 8. Clipboard was UNKNOWN on leave (-10)
            if (context.clipboardOnLeave === CLIPBOARD_UNKNOWN) {
                score -= 10;
                signals.clipboardWasUnknown = true;
            }
            
            // 9. Very short time away - probably didn't play
            // v1.2.3: Game-aware threshold (20s for quick games, 30s for others)
            if (minutesAway < minTimeThreshold) {
                score -= 15;
                signals.tooQuick = true;
            }
            
            // 10. Clipboard has content but NOT a game result (-5)
            if (context.clipboardHasContent && !context.clipboardHasGameResult) {
                score -= 5;
                signals.clipboardNotGameResult = true;
            }
            
            // 11. [P0 FIX] Result is for DIFFERENT game than launched (-20)
            // v1.2.3: Critical fix for mismatched game false positives
            if (context.clipboardHasGameResult && !context.resultMatchesLaunchedGame && context.lastLaunchedGame) {
                score -= 20;
                signals.resultMismatch = true;
                signals.detectedGame = context.parsedResult?.gameId;
                signals.launchedGame = context.lastLaunchedGame;
            }
            
            // v1.2.7.6: iOS score floor - ensure valid matches always get a chance
            // iOS users face unavoidable clipboardUnknown penalty due to gesture requirement
            // When they have a valid, matching result, don't let penalty stacking block capture
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            if (isIOS && context.clipboardHasGameResult && context.resultMatchesLaunchedGame) {
                const preFloorScore = score;
                score = Math.max(score, 25); // Floor at tap-to-log threshold
                if (score !== preFloorScore) {
                    signals.iosMatchFloor = true;
                    console.log(`ðŸ“± iOS: Score floored from ${preFloorScore} to ${score} for valid match`);
                }
            }
            
            // Clamp to 0-100
            score = Math.max(0, Math.min(100, score));
            
            console.log(`ðŸŽ¯ Confidence: ${score}`, signals);
            return { score, signals };
        }
        
        function hasHistoryForGame(gameId) {
            if (!appData.history) return false;
            for (const dateKey of Object.keys(appData.history)) {
                if (appData.history[dateKey][gameId]) return true;
            }
            return false;
        }
        
        async function buildReturnContext() {
            let currentClipboard = '';
            let clipboardReadSuccess = false;
            
            try {
                if (navigator.clipboard?.readText) {
                    currentClipboard = await navigator.clipboard.readText() || '';
                    clipboardReadSuccess = true;
                    trackEvent(ANALYTICS_EVENTS.CLIPBOARD_READ_SUCCESS);
                }
            } catch (e) {
                trackEvent(ANALYTICS_EVENTS.CLIPBOARD_READ_FAILED, { error: e.message });
            }
            
            const parsedResult = parseShareText(currentClipboard);
            
            return {
                timeAway: lastLaunchTime ? Date.now() - lastLaunchTime : 0,
                clipboardOnLeave: clipboardOnLeave,
                currentClipboard: currentClipboard,
                clipboardChanged: clipboardOnLeave !== CLIPBOARD_UNKNOWN && clipboardOnLeave !== currentClipboard,
                clipboardHasContent: currentClipboard.length > 0,
                clipboardHasGameResult: !!parsedResult,
                parsedResult: parsedResult,
                resultMatchesLaunchedGame: parsedResult?.gameId === lastLaunchedGame,
                lastLaunchedGame: lastLaunchedGame,
                alreadyLoggedToday: lastLaunchedGame ? !!getTodayHistory()[lastLaunchedGame] : false,
                hasLoggedThisGameBefore: lastLaunchedGame ? hasHistoryForGame(lastLaunchedGame) : false,
                dismissedPromptRecently: returnPromptDismissedFor === lastLaunchedGame,
                hoursSinceLastDismiss: returnPromptDismissedAt ? (Date.now() - returnPromptDismissedAt) / 3600000 : 0, // v1.2.3
                todayDismissCount: getTodayDismissCount(),
                isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent),
                clipboardReadSuccess: clipboardReadSuccess
            };
        }
        
        // ============ CLIPBOARD DIFF TRACKING ============
        // Stores clipboard content when user LEAVES the app
        // On return, we compare to detect if user copied something new
        let clipboardOnLeave = null; // null = unknown, string = content when left
        const CLIPBOARD_UNKNOWN = '__CLIPBOARD_UNKNOWN__'; // Marker for when we couldn't read
        
        // Stores clipboard content that was ALREADY PROCESSED (logged)
        // If current clipboard matches this, it's stale - don't prompt again
        let lastProcessedClipboard = null;
        
        // Enhanced playGame - tracks what was launched
        // Track pending game for launch pref modal
        let pendingLaunchGame = null;
        let pendingTutorialGame = null; // Game waiting for tutorial completion
        
        async function playGame(gameId, forceVisit = false, skipUnrecordedCheck = false) {
            const game = GAMES[gameId];
            if (!game) return;
            
            // Check if user has an unrecorded game from a previous visit
            // Only check if:
            // 1. Not forcing visit
            // 2. Not skipping this check (user chose "go to new game")
            // 3. There's a lastLaunchedGame that's different from current game
            // 4. The lastLaunchedGame wasn't recorded today
            if (!forceVisit && !skipUnrecordedCheck && lastLaunchedGame && lastLaunchedGame !== gameId) {
                const todayHistory = getTodayHistory();
                if (!todayHistory[lastLaunchedGame]) {
                    // Check if enough time passed (at least 30 seconds)
                    const elapsed = Date.now() - (lastLaunchTime || 0);
                    if (elapsed > 30000) {
                        // Show unrecorded game prompt
                        showUnrecordedGamePrompt(lastLaunchedGame, gameId);
                        return;
                    }
                }
            }
            
            const todayHistory = getTodayHistory();
            if (todayHistory[gameId] && !forceVisit) {
                // Game already played - show options sheet
                const todayScore = todayHistory[gameId].score;
                showGenericSheet({
                    title: `âœ… ${game.name} - Already Played`,
                    content: `
                        <div style="padding: 16px;">
                            <div style="text-align: center; margin-bottom: 20px;">
                                <div style="font-size: 2.5rem; margin-bottom: 8px;">${game.icon}</div>
                                <div style="font-size: 1.1rem; font-weight: 600; color: var(--accent-green);">Today: ${todayScore}</div>
                            </div>
                            
                            <div style="display: flex; flex-direction: column; gap: 10px;">
                                <button onclick="closeGenericSheet(); playGame('${gameId}', true)" style="
                                    width: 100%;
                                    padding: 14px;
                                    background: var(--accent-purple);
                                    border: none;
                                    border-radius: 10px;
                                    color: white;
                                    font-size: 1rem;
                                    font-weight: 600;
                                    cursor: pointer;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    gap: 8px;
                                ">
                                    <span>ðŸŽ®</span> Visit Game Anyway
                                </button>
                                
                                <button onclick="closeGenericSheet(); showGameStatsDetail('${gameId}')" style="
                                    width: 100%;
                                    padding: 14px;
                                    background: var(--bg-tertiary);
                                    border: 1px solid var(--border);
                                    border-radius: 10px;
                                    color: var(--text-primary);
                                    font-size: 1rem;
                                    cursor: pointer;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    gap: 8px;
                                ">
                                    <span>ðŸ“Š</span> View Stats
                                </button>
                                
                                <button onclick="closeGenericSheet(); adjustRecordingFromModal('${gameId}')" style="
                                    width: 100%;
                                    padding: 14px;
                                    background: var(--bg-tertiary);
                                    border: 1px solid var(--border);
                                    border-radius: 10px;
                                    color: var(--text-primary);
                                    font-size: 1rem;
                                    cursor: pointer;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    gap: 8px;
                                ">
                                    <span>âœï¸</span> Adjust Recording
                                </button>
                            </div>
                        </div>
                    `
                });
                return;
            }
            
            // Check if user has seen the recording tutorial (first time ANY game launch)
            if (!appData.hasSeenRecordingTutorial) {
                pendingTutorialGame = gameId;
                showRecordingTutorial(game);
                return;
            }
            
            // Check if this game has an app option AND we need to ask for publisher pref
            if (game.hasApp && game.publisher) {
                // Check for game-specific override first
                const gameOverride = appData.launchPrefs?.[gameId];
                if (!gameOverride) {
                    // Check for publisher preference
                    const publisherPref = appData.publisherPrefs?.[game.publisher];
                    if (!publisherPref) {
                        // First time for this publisher - ask user
                        pendingLaunchGame = gameId;
                        showPublisherPrefModal(game);
                        return;
                    }
                }
            }
            
            // We have a preference (or no app) - launch directly
            launchGame(gameId);
        }
        
        // ============ RECORDING TUTORIAL (First-time users) ============
        let tutorialStep = 0;
        
        function showRecordingTutorial(game) {
            trackEvent(ANALYTICS_EVENTS.TUTORIAL_STARTED, { gameId: game?.id });
            tutorialStep = 1;
            
            const overlay = document.getElementById('recording-tutorial-overlay');
            if (!overlay) {
                console.warn('Recording tutorial overlay not found');
                // Fallback: skip tutorial
                appData.hasSeenRecordingTutorial = true;
                saveData();
                if (pendingTutorialGame) {
                    playGame(pendingTutorialGame);
                    pendingTutorialGame = null;
                }
                return;
            }
            
            // Update game name in final step
            document.getElementById('tutorial-game-name').textContent = game?.name || 'your game';
            
            // Reset to step 1
            overlay.querySelectorAll('.tutorial-step').forEach((step, i) => {
                step.classList.toggle('active', i === 0);
            });
            
            overlay.classList.add('active');
        }
        
        function recordingTutorialNext() {
            tutorialStep++;
            const overlay = document.getElementById('recording-tutorial-overlay');
            if (!overlay) return;
            
            overlay.querySelectorAll('.tutorial-step').forEach((step, i) => {
                step.classList.toggle('active', i === tutorialStep - 1);
            });
            
            // If we're past step 3, complete the tutorial
            if (tutorialStep > 3) {
                completeRecordingTutorial();
            }
        }
        
        function completeRecordingTutorial() {
            trackEvent(ANALYTICS_EVENTS.TUTORIAL_COMPLETED);
            appData.hasSeenRecordingTutorial = true;
            saveData();
            
            const overlay = document.getElementById('recording-tutorial-overlay');
            if (overlay) overlay.classList.remove('active');
            
            // Continue with game launch
            if (pendingTutorialGame) {
                const gameId = pendingTutorialGame;
                pendingTutorialGame = null;
                playGame(gameId);
            }
        }
        
        function skipRecordingTutorial() {
            trackEvent(ANALYTICS_EVENTS.TUTORIAL_SKIPPED, { step: tutorialStep });
            completeRecordingTutorial();
        }
        
        // ============ PUBLISHER PREFERENCE MODAL ============
        function showPublisherPrefModal(game) {
            const overlay = document.getElementById('launch-pref-overlay');
            if (!overlay) return;
            
            const appInfo = APP_INFO[game.publisher];
            const publisherGames = Object.values(GAMES).filter(g => g.publisher === game.publisher);
            const gameNames = publisherGames.slice(0, 3).map(g => g.name).join(', ');
            const moreCount = publisherGames.length - 3;
            
            // Update modal content for publisher-level preference
            document.getElementById('launch-pref-icon').textContent = appInfo?.icon || game.icon;
            document.getElementById('launch-pref-game-name').textContent = appInfo?.name || game.publisher;
            document.getElementById('launch-pref-app-name').textContent = appInfo?.name || 'the app';
            
            // Update subtitle to show this applies to all publisher games
            const subtitle = overlay.querySelector('.launch-pref-subtitle');
            if (subtitle) {
                let text = `This applies to ${gameNames}`;
                if (moreCount > 0) text += ` and ${moreCount} more`;
                subtitle.textContent = text;
            }
            
            // Show modal
            overlay.classList.add('active');
        }
        
        // Legacy function - redirects to publisher modal
        function showLaunchPrefModal(game) {
            showPublisherPrefModal(game);
        }
        
        function closeLaunchPrefModal() {
            const overlay = document.getElementById('launch-pref-overlay');
            if (overlay) overlay.classList.remove('active');
            pendingLaunchGame = null;
        }
        
        function showLaunchPrefsManager() {
            // Show a list of games with saved preferences
            const prefs = appData.launchPrefs || {};
            const customUrls = appData.customUrls || {};
            const gamesWithPrefs = [...new Set([...Object.keys(prefs), ...Object.keys(customUrls)])];
            
            if (gamesWithPrefs.length === 0) {
                showToast('No launch preferences saved yet. Play a game to set one!');
                return;
            }
            
            // Build modal content
            let content = '<div style="padding: 20px; max-height: 70vh; overflow-y: auto;">';
            content += '<h3 style="margin: 0 0 16px; font-size: 1.2rem;">ðŸš€ Game Launch Settings</h3>';
            content += '<p style="color: var(--text-muted); font-size: 0.9rem; margin-bottom: 20px;">Tap a game to change how it opens</p>';
            
            gamesWithPrefs.forEach(gameId => {
                const game = GAMES[gameId];
                if (!game) return;
                const pref = prefs[gameId];
                const hasCustomUrl = !!customUrls[gameId];
                let prefLabel = pref === 'app' ? 'ðŸ“± App' : 'ðŸŒ Browser';
                if (hasCustomUrl) prefLabel += ' âœï¸';
                
                content += `
                    <div onclick="toggleLaunchPref('${gameId}')" style="
                        display: flex;
                        align-items: center;
                        gap: 12px;
                        padding: 14px;
                        background: var(--bg-tertiary);
                        border-radius: 12px;
                        margin-bottom: 10px;
                        cursor: pointer;
                    ">
                        <span style="font-size: 1.5rem;">${game.icon}</span>
                        <span style="flex: 1; font-weight: 500;">${game.name}</span>
                        <span style="color: var(--text-muted); font-size: 0.9rem;">${prefLabel}</span>
                    </div>
                `;
            });
            
            content += '<p style="color: var(--text-muted); font-size: 0.8rem; margin-top: 16px; text-align: center;">âœï¸ = custom URL set</p>';
            content += '</div>';
            
            // Show as a bottom sheet
            showBottomSheet('Launch Preferences', content);
        }
        
        function toggleLaunchPref(gameId) {
            const game = GAMES[gameId];
            if (!game) return;
            
            const hasCustomUrl = !!appData.customUrls?.[gameId];
            const currentPref = appData.launchPrefs?.[gameId] || 'browser';
            
            // Show options
            let content = `<div style="padding: 20px;">`;
            content += `<div style="display: flex; align-items: center; gap: 12px; margin-bottom: 20px;">`;
            content += `<span style="font-size: 2rem;">${game.icon}</span>`;
            content += `<span style="font-size: 1.2rem; font-weight: 600;">${game.name}</span>`;
            content += `</div>`;
            
            // App/Browser toggle
            if (game.hasApp) {
                content += `
                    <button onclick="setLaunchPref('${gameId}', 'app')" style="
                        width: 100%;
                        display: flex;
                        align-items: center;
                        gap: 12px;
                        padding: 14px;
                        background: ${currentPref === 'app' ? 'rgba(102, 126, 234, 0.15)' : 'var(--bg-tertiary)'};
                        border: 2px solid ${currentPref === 'app' ? 'var(--accent-purple)' : 'var(--border)'};
                        border-radius: 12px;
                        margin-bottom: 10px;
                        cursor: pointer;
                        text-align: left;
                        color: var(--text-primary);
                    ">
                        <span style="font-size: 1.3rem;">ðŸ“±</span>
                        <span>Open in app</span>
                        ${currentPref === 'app' ? '<span style="margin-left: auto;">âœ“</span>' : ''}
                    </button>
                `;
            }
            
            content += `
                <button onclick="setLaunchPref('${gameId}', 'browser')" style="
                    width: 100%;
                    display: flex;
                    align-items: center;
                    gap: 12px;
                    padding: 14px;
                    background: ${currentPref === 'browser' && !hasCustomUrl ? 'rgba(102, 126, 234, 0.15)' : 'var(--bg-tertiary)'};
                    border: 2px solid ${currentPref === 'browser' && !hasCustomUrl ? 'var(--accent-purple)' : 'var(--border)'};
                    border-radius: 12px;
                    margin-bottom: 10px;
                    cursor: pointer;
                    text-align: left;
                    color: var(--text-primary);
                ">
                    <span style="font-size: 1.3rem;">ðŸŒ</span>
                    <span>Open in browser</span>
                    ${currentPref === 'browser' && !hasCustomUrl ? '<span style="margin-left: auto;">âœ“</span>' : ''}
                </button>
            `;
            
            // Custom URL option
            content += `
                <button onclick="closeGenericSheet(); showCustomUrlModal(GAMES['${gameId}'])" style="
                    width: 100%;
                    display: flex;
                    align-items: center;
                    gap: 12px;
                    padding: 14px;
                    background: ${hasCustomUrl ? 'rgba(102, 126, 234, 0.15)' : 'var(--bg-tertiary)'};
                    border: 2px solid ${hasCustomUrl ? 'var(--accent-purple)' : 'var(--border)'};
                    border-radius: 12px;
                    margin-bottom: 10px;
                    cursor: pointer;
                    text-align: left;
                    color: var(--text-primary);
                ">
                    <span style="font-size: 1.3rem;">âœï¸</span>
                    <span>${hasCustomUrl ? 'Edit custom URL' : 'Use custom URL'}</span>
                    ${hasCustomUrl ? '<span style="margin-left: auto;">âœ“</span>' : ''}
                </button>
            `;
            
            if (hasCustomUrl) {
                content += `
                    <button onclick="clearCustomUrl('${gameId}')" style="
                        width: 100%;
                        padding: 12px;
                        background: transparent;
                        border: none;
                        color: #ef4444;
                        font-size: 0.9rem;
                        cursor: pointer;
                    ">
                        Remove custom URL
                    </button>
                `;
            }
            
            content += `</div>`;
            
            showBottomSheet(`${game.icon} ${game.name}`, content);
        }
        
        function setLaunchPref(gameId, pref) {
            if (!appData.launchPrefs) appData.launchPrefs = {};
            appData.launchPrefs[gameId] = pref;
            
            // Clear custom URL if switching to standard option
            if (appData.customUrls?.[gameId]) {
                delete appData.customUrls[gameId];
            }
            
            // Clear verification so we check again
            if (appData.launchVerified?.[gameId]) {
                delete appData.launchVerified[gameId];
            }
            
            saveData();
            closeGenericSheet();
            
            const game = GAMES[gameId];
            const prefLabel = pref === 'app' ? 'app ðŸ“±' : 'browser ðŸŒ';
            showToast(`${game?.icon || 'ðŸŽ®'} ${game?.name || 'Game'} will open in ${prefLabel}`);
        }
        
        function clearCustomUrl(gameId) {
            if (appData.customUrls?.[gameId]) {
                delete appData.customUrls[gameId];
            }
            if (appData.launchVerified?.[gameId]) {
                delete appData.launchVerified[gameId];
            }
            saveData();
            closeGenericSheet();
            showToast('Custom URL removed');
        }
        
        function showBottomSheet(title, content) {
            // Create or update a generic bottom sheet
            let sheet = document.getElementById('generic-bottom-sheet');
            if (!sheet) {
                sheet = document.createElement('div');
                sheet.id = 'generic-bottom-sheet';
                sheet.className = 'bottom-sheet-overlay';
                sheet.onclick = function(e) { 
                    if (e.target === this) closeGenericSheet(); 
                };
                document.body.appendChild(sheet);
            }
            
            sheet.innerHTML = `
                <div class="bottom-sheet" onclick="event.stopPropagation()" style="max-height: 80vh;">
                    <div class="bottom-sheet-handle"></div>
                    <div class="bottom-sheet-header">
                        ${title}
                        <button onclick="closeGenericSheet()" style="position: absolute; right: 16px; top: 16px; background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text-muted);">âœ•</button>
                    </div>
                    ${content}
                </div>
            `;
            
            sheet.classList.add('active');
        }
        
        function closeGenericSheet() {
            const sheet = document.getElementById('generic-bottom-sheet');
            if (sheet) sheet.classList.remove('active');
        }
        
        // Alias for convenience
        function showGenericSheet(options) {
            showBottomSheet(options.title, options.content);
        }
        
        function selectLaunchPref(pref) {
            if (!pendingLaunchGame) return;
            
            const game = GAMES[pendingLaunchGame];
            
            // Save preference at PUBLISHER level
            if (game?.publisher) {
                if (!appData.publisherPrefs) appData.publisherPrefs = {};
                appData.publisherPrefs[game.publisher] = pref;
                
                trackEvent(ANALYTICS_EVENTS.PUBLISHER_PREF_SET, {
                    publisher: game.publisher,
                    preference: pref,
                    triggeredByGame: pendingLaunchGame
                });
            } else {
                // Fallback to game-level for games without publisher
                if (!appData.launchPrefs) appData.launchPrefs = {};
                appData.launchPrefs[pendingLaunchGame] = pref;
            }
            saveData();
            
            const gameId = pendingLaunchGame;
            closeLaunchPrefModal();
            
            // Now launch the game
            launchGame(gameId);
        }
        
        function launchGame(gameId) {
            const game = GAMES[gameId];
            if (!game) return;
            
            // Track this launch for return detection
            lastLaunchedGame = gameId;
            lastLaunchTime = Date.now();
            returnPromptDismissedFor = null;
            returnPromptDismissedAt = null; // v1.2.3: Reset dismiss timestamp
            
            // PERSIST to localStorage so we can detect on app restart
            persistActiveGame(gameId);
            
            // Get launch method for analytics
            const launchMethod = getLaunchMethod(gameId);
            
            // Track if this is first launch after setting preference (needs verification)
            const isFirstLaunch = !appData.launchVerified?.[gameId];
            if (game.hasApp && isFirstLaunch) {
                pendingVerifyGame = gameId;
            }
            
            console.log(`ðŸŽ® Launching ${game.name}...`);
            
            // Determine which URL to use
            // For GS Originals, check test mode; otherwise use game.url
            let launchUrl = getGameUrl(gameId) || game.url;
            
            // Log test mode status for GS Originals
            if (isGSOriginal(gameId) && isTestModeEnabled()) {
                console.log(`ðŸ§ª Test Mode: Using test URL for ${game.name}`);
            }
            
            // Check for custom URL first
            const customUrl = appData.customUrls?.[gameId];
            if (customUrl) {
                launchUrl = customUrl;
                console.log(`âœï¸ Launching with custom URL: ${launchUrl}`);
            } else {
                // Check game-specific override, then publisher pref
                let pref = appData.launchPrefs?.[gameId];
                if (!pref && game.publisher) {
                    pref = appData.publisherPrefs?.[game.publisher];
                }
                
                if (pref === 'app' && game.hasApp) {
                    // They prefer the app - use the same URL, iOS/Android will intercept via Universal Links
                    // Note: keep original URL for universal links, not test URL
                    if (!isGSOriginal(gameId)) {
                        launchUrl = game.url;
                    }
                    console.log(`ðŸ“± Launching via app (Universal Link): ${launchUrl}`);
                } else {
                    console.log(`ðŸŒ Launching in browser: ${launchUrl}`);
                }
            }
            
            // Track analytics
            trackEvent(ANALYTICS_EVENTS.GAME_LAUNCH, {
                gameId: gameId,
                publisher: game.publisher,
                launchMethod: launchMethod,
                isGSOriginal: isGSOriginal(gameId),
                timeOfDay: new Date().getHours()
            });
            
            // Show pre-launch reminder if enabled (not for GS Originals which auto-sync)
            const showReminder = appData.hasSeenRecordingTutorial && 
                                 appData.settings?.showPrelaunchReminder !== false &&
                                 !isGSOriginal(gameId);
            
            if (showReminder) {
                showPrelaunchReminder(game, launchUrl);
            } else {
                // Open game directly
                openGameUrl(launchUrl);
            }
        }
        
        function showPrelaunchReminder(game, launchUrl) {
            const reminder = document.getElementById('prelaunch-reminder');
            
            // v1.2.7.6: Open URL IMMEDIATELY to preserve tap gesture for iOS
            // iOS blocks window.open if called after timeout
            openGameUrl(launchUrl);
            
            // Show reminder briefly (but URL already opened)
            if (reminder) {
                document.getElementById('prelaunch-game-name').textContent = game.name;
                reminder.classList.add('active');
                
                // Auto-dismiss after 1.5 seconds
                setTimeout(() => {
                    reminder.classList.remove('active');
                }, 1500);
            }
        }
        
        function openGameUrl(launchUrl) {
            // v1.2.77: On iOS PWA, show first-time tip about returning from games
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            const isStandalone = window.navigator.standalone || window.matchMedia('(display-mode: standalone)').matches;
            
            if (isIOS && isStandalone && launchUrl.startsWith('http')) {
                // Check if user has seen the return tip
                const hasSeenReturnTip = localStorage.getItem('gs_seen_return_tip');
                if (!hasSeenReturnTip) {
                    localStorage.setItem('gs_seen_return_tip', 'true');
                    showToast('Tap âœ• or swipe down to return', 'info', 2500);
                }
            }
            
            if (launchUrl.startsWith('http')) {
                window.open(launchUrl, '_blank');
            } else {
                window.location.href = launchUrl;
            }
        }
        
        // Helper to determine launch method for a game
        function getLaunchMethod(gameId) {
            const game = GAMES[gameId];
            if (!game) return 'browser';
            
            // Custom URL takes priority
            if (appData.customUrls?.[gameId]) return 'custom';
            
            // Check game-specific override
            const gameOverride = appData.launchPrefs?.[gameId];
            if (gameOverride) return gameOverride;
            
            // Check publisher preference
            if (game.publisher) {
                const publisherPref = appData.publisherPrefs?.[game.publisher];
                if (publisherPref) return publisherPref;
            }
            
            // Default to browser
            return 'browser';
        }
        
        // ============ LAUNCH VERIFICATION ============
        let pendingVerifyGame = null;
        
        // ============ PERSISTENT GAME STATE ============
        // Persists active game to localStorage so we can detect on app restart
        function persistActiveGame(gameId) {
            const state = {
                gameId: gameId,
                launchTime: Date.now()
            };
            localStorage.setItem('gameshelf_active_game', JSON.stringify(state));
            console.log(`ðŸŽ® Persisted active game: ${gameId}`);
        }
        
        function clearActiveGame() {
            localStorage.removeItem('gameshelf_active_game');
            lastLaunchedGame = null;
            lastLaunchTime = null;
            console.log('ðŸŽ® Cleared active game state');
        }
        
        function getActiveGame() {
            try {
                const stored = localStorage.getItem('gameshelf_active_game');
                if (!stored) return null;
                const state = JSON.parse(stored);
                
                // Validate state has required fields
                if (!state.gameId || !state.launchTime) return null;
                
                // Check if stale (more than 30 minutes old)
                if (Date.now() - state.launchTime > 30 * 60 * 1000) {
                    console.log('ðŸŽ® Active game state is stale, clearing');
                    localStorage.removeItem('gameshelf_active_game');
                    return null;
                }
                
                return state;
            } catch (e) {
                return null;
            }
        }
        
        // Restore state from localStorage on init
        function restoreActiveGameState() {
            const state = getActiveGame();
            if (state) {
                lastLaunchedGame = state.gameId;
                lastLaunchTime = state.launchTime;
                console.log(`ðŸŽ® Restored active game from localStorage: ${state.gameId}`);
            }
        }
        
        function checkLaunchVerification() {
            // Called when user returns to app
            if (!pendingVerifyGame) return;
            
            const game = GAMES[pendingVerifyGame];
            if (!game) {
                pendingVerifyGame = null;
                return;
            }
            
            // Don't verify if they just logged a result - clearly it worked!
            const todayHistory = getTodayHistory();
            if (todayHistory[pendingVerifyGame]) {
                markLaunchVerified(pendingVerifyGame);
                pendingVerifyGame = null;
                return;
            }
            
            // Show verification modal
            showLaunchVerifyModal(game);
        }
        
        function showLaunchVerifyModal(game) {
            const overlay = document.getElementById('launch-verify-overlay');
            if (!overlay) return;
            
            document.getElementById('launch-verify-icon').textContent = game.icon;
            document.getElementById('launch-verify-game-name').textContent = game.name;
            
            overlay.classList.add('active');
        }
        
        function closeLaunchVerifyModal() {
            const overlay = document.getElementById('launch-verify-overlay');
            if (overlay) overlay.classList.remove('active');
        }
        
        function verifyLaunchSuccess() {
            // User confirmed it worked
            if (pendingVerifyGame) {
                markLaunchVerified(pendingVerifyGame);
                showToast('Great! ðŸ‘');
            }
            closeLaunchVerifyModal();
            pendingVerifyGame = null;
        }
        
        function markLaunchVerified(gameId) {
            if (!appData.launchVerified) appData.launchVerified = {};
            appData.launchVerified[gameId] = true;
            saveData();
        }
        
        function showLaunchFixOptions() {
            closeLaunchVerifyModal();
            
            const overlay = document.getElementById('launch-fix-overlay');
            const game = GAMES[pendingVerifyGame];
            
            if (overlay && game) {
                document.getElementById('launch-fix-icon').textContent = game.icon;
                overlay.classList.add('active');
            }
        }
        
        function closeLaunchFixModal() {
            const overlay = document.getElementById('launch-fix-overlay');
            if (overlay) overlay.classList.remove('active');
            pendingVerifyGame = null;
        }
        
        function fixLaunchIssue(issue) {
            const gameId = pendingVerifyGame;
            const game = GAMES[gameId];
            if (!game) return;
            
            closeLaunchFixModal();
            
            switch (issue) {
                case 'wrong-place':
                    // They landed on homepage - try more specific URL or suggest login
                    showToast('Try logging into your account on the game site first, then come back');
                    break;
                    
                case 'no-stats':
                    // Stats not showing - explain they need to be logged in
                    showBottomSheet('ðŸ“Š Stats Not Showing?', `
                        <div style="padding: 20px;">
                            <p style="margin-bottom: 16px;">To see your stats and streaks, you need to be logged into your account on the game site.</p>
                            <p style="margin-bottom: 16px;"><strong>For NYT Games:</strong> Create a free NYT account at nytimes.com and log in before playing.</p>
                            <p style="margin-bottom: 16px;"><strong>For LinkedIn:</strong> Make sure you're logged into LinkedIn.</p>
                            <button onclick="closeGenericSheet(); playGame('${gameId}')" style="width: 100%; padding: 14px; background: var(--accent-purple); color: white; border: none; border-radius: 12px; font-size: 1rem; font-weight: 600; cursor: pointer;">
                                Try Again
                            </button>
                        </div>
                    `);
                    break;
                    
                case 'try-other':
                    // Switch between app and browser
                    if (!appData.launchPrefs) appData.launchPrefs = {};
                    const current = appData.launchPrefs[gameId];
                    appData.launchPrefs[gameId] = current === 'app' ? 'browser' : 'app';
                    saveData();
                    
                    const newPref = appData.launchPrefs[gameId] === 'app' ? 'app' : 'browser';
                    showToast(`Switched to ${newPref}. Try again!`);
                    
                    // Re-launch with new preference
                    setTimeout(() => playGame(gameId), 500);
                    break;
                    
                case 'custom-url':
                    // Let them enter their own URL
                    showCustomUrlModal(game);
                    break;
            }
            
            pendingVerifyGame = null;
        }
        
        function showCustomUrlModal(game) {
            const overlay = document.getElementById('custom-url-overlay');
            if (!overlay) return;
            
            document.getElementById('custom-url-icon').textContent = game.icon;
            document.getElementById('custom-url-game-name').textContent = game.name;
            document.getElementById('custom-url-input').value = appData.customUrls?.[game.id] || game.url;
            
            // Store which game we're editing
            overlay.dataset.gameId = game.id;
            overlay.classList.add('active');
            
            // Focus input
            setTimeout(() => document.getElementById('custom-url-input').focus(), 100);
        }
        
        function closeCustomUrlModal() {
            const overlay = document.getElementById('custom-url-overlay');
            if (overlay) overlay.classList.remove('active');
        }
        
        function saveCustomUrl() {
            const overlay = document.getElementById('custom-url-overlay');
            const gameId = overlay?.dataset?.gameId;
            const url = document.getElementById('custom-url-input').value.trim();
            
            if (!gameId || !url) {
                showToast('Please enter a valid URL');
                return;
            }
            
            // Basic URL validation
            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                showToast('URL must start with http:// or https://');
                return;
            }
            
            // Save custom URL
            if (!appData.customUrls) appData.customUrls = {};
            appData.customUrls[gameId] = url;
            saveData();
            
            closeCustomUrlModal();
            showToast('URL saved! Launching...');
            
            // Mark as needing re-verification
            if (appData.launchVerified) delete appData.launchVerified[gameId];
            
            // Launch with new URL
            setTimeout(() => playGame(gameId), 500);
        }
        
        // Return-from-game detection - only restores state, prompting happens when clicking new game
        function checkReturnFromGame() {
            // Restore from localStorage if memory state is empty (e.g., after app restart)
            if (!lastLaunchedGame || !lastLaunchTime) {
                const activeGame = getActiveGame();
                if (activeGame) {
                    lastLaunchedGame = activeGame.gameId;
                    lastLaunchTime = activeGame.launchTime;
                    console.log(`ðŸŽ® Restored active game from localStorage: ${activeGame.gameId}`);
                } else {
                    return; // No game was launched
                }
            }
            
            // Clear if launch was more than 30 minutes ago (stale)
            const elapsed = Date.now() - lastLaunchTime;
            if (elapsed > 30 * 60 * 1000) {
                console.log('ðŸŽ® Clearing stale active game (>30min old)');
                clearActiveGame();
                return;
            }
            
            // Clear if game was already logged today
            const todayHistory = appData.history[getTodayString()] || {};
            if (todayHistory[lastLaunchedGame]) {
                console.log(`ðŸŽ® Game ${lastLaunchedGame} already logged, clearing active game`);
                clearActiveGame();
                return;
            }
            
            // Note: We no longer show automatic return prompt here
            // Instead, user will be prompted when they click on a different game
            console.log(`ðŸŽ® User returned from ${lastLaunchedGame}, will prompt on next game click`);
        }
        
        function showReturnPrompt(game) {
            const prompt = document.getElementById('return-prompt');
            if (!prompt) return;
            
            document.getElementById('return-prompt-icon').textContent = game.icon;
            document.getElementById('return-prompt-title').textContent = `Back from ${game.name}?`;
            
            prompt.style.display = 'block';
            // Small delay to trigger CSS transition
            setTimeout(() => prompt.classList.add('visible'), 10);
            
            // Auto-dismiss after 15 seconds
            setTimeout(() => {
                if (prompt.classList.contains('visible')) {
                    dismissReturnPrompt();
                }
            }, 15000);
        }
        
        function dismissReturnPrompt() {
            const prompt = document.getElementById('return-prompt');
            if (prompt) {
                prompt.classList.remove('visible');
                // Hide after transition
                setTimeout(() => {
                    if (!prompt.classList.contains('visible')) {
                        prompt.style.display = 'none';
                    }
                }, 300);
            }
            // Remember we dismissed for this game
            returnPromptDismissedFor = lastLaunchedGame;
            returnPromptDismissedAt = Date.now(); // v1.2.3: Track when dismissed
        }
        
        // Dismiss return prompt if it's currently showing for a specific game
        // Called when a game is logged to prevent stale prompts
        function dismissReturnPromptIfShowing(gameId) {
            const prompt = document.getElementById('return-prompt');
            if (prompt && prompt.classList.contains('visible') && lastLaunchedGame === gameId) {
                console.log(`ðŸŽ® Auto-dismissing return prompt for ${gameId} (game was logged)`);
                dismissReturnPrompt();
            }
        }
        
        function returnPromptNotYet() {
            dismissReturnPrompt();
            showToast('No rush! We\'ll check your clipboard when you\'re done ðŸ‘');
        }
        
        function returnPromptLogManual() {
            dismissReturnPrompt();
            // Open log sheet with this game pre-selected
            openLogSheetForGame(lastLaunchedGame);
        }
        
        // Track pending game for unrecorded prompt
        let pendingUnrecordedTargetGame = null;
        
        function showUnrecordedGamePrompt(unrecordedGameId, targetGameId) {
            const unrecordedGame = GAMES[unrecordedGameId];
            const targetGame = GAMES[targetGameId];
            if (!unrecordedGame || !targetGame) {
                // Fallback - just launch the new game
                clearActiveGame();
                playGame(targetGameId, false, true);
                return;
            }
            
            pendingUnrecordedTargetGame = targetGameId;
            
            showGenericSheet({
                title: 'ðŸ“‹ Record Previous Game?',
                content: `
                    <div style="padding: 20px; text-align: center;">
                        <div style="font-size: 3rem; margin-bottom: 12px;">${unrecordedGame.icon}</div>
                        <p style="color: var(--text-secondary); margin-bottom: 8px; font-size: 1rem;">
                            You visited <strong>${unrecordedGame.name}</strong> but didn't record your result.
                        </p>
                        <p style="color: var(--text-muted); margin-bottom: 24px; font-size: 0.85rem;">
                            If you finished playing, record it now. Otherwise, continue to your next game.
                        </p>
                        
                        <div style="display: flex; flex-direction: column; gap: 12px;">
                            <button onclick="handleUnrecordedRecord()" style="
                                width: 100%;
                                padding: 16px;
                                background: linear-gradient(135deg, var(--accent-purple), #764ba2);
                                border: none;
                                border-radius: 12px;
                                color: white;
                                font-size: 1rem;
                                font-weight: 600;
                                cursor: pointer;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                gap: 8px;
                            ">
                                ðŸ“ Record ${unrecordedGame.name}
                            </button>
                            
                            <button onclick="handleUnrecordedSkip()" style="
                                width: 100%;
                                padding: 16px;
                                background: var(--bg-tertiary);
                                border: 1px solid var(--border);
                                border-radius: 12px;
                                color: var(--text-primary);
                                font-size: 1rem;
                                cursor: pointer;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                gap: 8px;
                            ">
                                ðŸŽ® Go to ${targetGame.name}
                            </button>
                        </div>
                    </div>
                `
            });
        }
        
        async function handleUnrecordedRecord() {
            closeGenericSheet();
            
            // Try to read clipboard and auto-record
            try {
                const text = await navigator.clipboard.readText();
                const result = parseShareText(text);
                
                if (result && result.gameId === lastLaunchedGame) {
                    // Clipboard has the right game - auto-record it
                    if (logGame(result, 'unrecorded-prompt')) {
                        const game = GAMES[result.gameId];
                        showToast(`${game?.icon || 'ðŸŽ®'} ${game?.name} recorded!`, 'success');
                        renderAll();
                        clearActiveGame();
                        
                        // Now launch the target game
                        if (pendingUnrecordedTargetGame) {
                            setTimeout(() => playGame(pendingUnrecordedTargetGame, false, true), 500);
                        }
                        pendingUnrecordedTargetGame = null;
                        return;
                    }
                }
                
                // No matching result in clipboard - open log sheet for manual entry
                openLogSheetForGame(lastLaunchedGame);
                pendingUnrecordedTargetGame = null;
                
            } catch (e) {
                console.log('Clipboard read failed, opening manual log:', e.message);
                // Clipboard read failed - open log sheet for manual entry
                openLogSheetForGame(lastLaunchedGame);
                pendingUnrecordedTargetGame = null;
            }
        }
        
        function handleUnrecordedSkip() {
            closeGenericSheet();
            const targetGame = pendingUnrecordedTargetGame;
            clearActiveGame();
            pendingUnrecordedTargetGame = null;
            
            if (targetGame) {
                playGame(targetGame, false, true);
            }
        }
        
        function openLogSheetForGame(gameId) {
            openLogSheet();
            // Switch to quick log tab and highlight the game
            switchLogTab('quick');
            
            // Scroll to and highlight the game button
            setTimeout(() => {
                const btn = document.querySelector(`.quick-log-btn[data-game="${gameId}"]`);
                if (btn) {
                    btn.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    btn.style.animation = 'pulse 0.5s ease 2';
                }
            }, 100);
        }
        
        // ============ HINT HELPER SYSTEM ============
        const HINT_GAMES = {
            connections: {
                id: 'connections', name: 'Connections', icon: 'ðŸ”—',
                startDate: '2023-06-12', needsInput: false,
                searchQuery: (date) => `NYT Connections ${date} puzzle answers`,
                hintDescs: { low: "Vague category hints", mid: "Theme + partial words", high: "Full categories" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Connections: Group 16 words into 4 categories of 4.

Hint levels:
1-2: Ultra vague, ONE category. Example: "One group relates to nature" (under 10 words)
3-4: Theme for ONE category. Example: "Think about dance styles" (under 12 words)
5-6: Category name revealed. Example: "One category is BREAD TYPES"
7-8: Category + 3 of 4 words. Example: "RYE, WHEAT, SOURDOUGH are breads"
9-10: All four categories with all words

Keep levels 1-4 under 15 words.`
            },
            wordle: {
                id: 'wordle', name: 'Wordle', icon: 'ðŸŸ©',
                startDate: '2021-06-19', needsInput: false,
                searchQuery: (date) => `NYT Wordle ${date} answer`,
                hintDescs: { low: "Category hints", mid: "Letter hints", high: "Answer" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Wordle: Guess the 5-letter word in 6 tries.

Hint levels:
1-2: Vague. Example: "Common everyday word"
3-4: Category. Example: "Related to cooking"
5-6: Letter structure. Example: "Has double letters, starts with vowel"
7-8: Specific letters. Example: "Contains A and R, ends in E"
9-10: The word itself

Keep levels 1-4 under 8 words.`
            },
            strands: {
                id: 'strands', name: 'Strands', icon: 'ðŸ”µ',
                startDate: '2024-03-04', needsInput: false,
                searchQuery: (date) => `NYT Strands ${date} theme spangram answers`,
                hintDescs: { low: "Theme hints", mid: "Spangram hints", high: "Word reveals" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Strands: Find themed words in a letter grid, plus one spangram.

Hint levels:
1-2: Vague theme. Example: "Things you find outdoors"
3-4: Specific theme. Example: "Garden tools and equipment"
5-6: Spangram hint. Example: "Spangram is two words about planting"
7-8: Spangram + some words. Example: "GREENTHUMB, plus RAKE, SHOVEL"
9-10: Full solution with all words

Keep levels 1-4 under 10 words.`
            },
            spellingbee: {
                id: 'spellingbee', name: 'Spelling Bee', icon: 'ðŸ',
                startDate: '2018-01-01', needsInput: true,
                inputLabel: "Stuck on letter? (optional)", inputPlaceholder: "e.g., P",
                searchQuery: (date) => `NYT Spelling Bee ${date} pangram answers`,
                hintDescs: { low: "Pangram hints", mid: "Letter hints", high: "Word reveals" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Spelling Bee: Make words using 7 letters, must include center letter.

Hint levels:
1-2: Word count only. Example: "42 words total, 1 pangram"
3-4: Pangram theme. Example: "Pangram relates to weather"
5-6: The pangram word(s). Example: "Pangram is THUNDERSTORM"
7-8: Hard words for a letter. Example: "T words: TORRENT, THROAT, TOOT"
9-10: Full word list

Keep levels 1-4 under 10 words.`
            },
            mini: {
                id: 'mini', name: 'Mini Crossword', icon: 'ðŸ“°',
                startDate: '2014-01-01', needsInput: true, inputRequired: true,
                inputLabel: "Which clue?", inputPlaceholder: "e.g., 1-Across",
                searchQuery: (date) => `NYT Mini Crossword ${date} answers`,
                hintDescs: { low: "Category hints", mid: "Letter hints", high: "Answer" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Mini Crossword: 5x5 crossword with simple clues.

Hint levels:
1-2: Vague category. Example: "Think geography"
3-4: Specific category. Example: "A European capital"
5-6: Letter count + hint. Example: "5 letters, starts with P"
7-8: More letters. Example: "P_R_S"
9-10: The answer

Keep levels 1-4 under 10 words.`
            },
            quotle: {
                id: 'quotle', name: 'Quotle', icon: 'ðŸ’¬',
                hasLocalData: true, needsInput: false,
                hintDescs: { low: "Era/field hints", mid: "Nationality hints", high: "Name hints" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Quotle: Guess who said a famous quote.

Hint levels:
1-2: Era. Example: "Said in the 20th century"
3-4: Field. Example: "From the world of politics"
5-6: Nationality/gender. Example: "American woman"
7-8: Name hint. Example: "First name starts with E, last name R"
9-10: Full name

Keep levels 1-4 under 8 words.`
            },
            rungs: {
                id: 'rungs', name: 'Rungs', icon: 'ðŸªœ',
                hasLocalData: true, needsInput: false,
                hintDescs: { low: "Theme hints", mid: "Pairing hints", high: "Pair reveals" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to", "The items"
3. NO explanations, NO meta-commentary about search results, NO preamble, NO analysis
4. Start your response with the hint directly

Rungs: Match 8 items into 4 pairs, order leastâ†’most.

Hint levels:
1-2: ONE word theme only. Example: "Exercise"
3-4: Theme + ordering. Example: "Workout phases, beginning to end" (NO pairs)
5-6: ONE pair hint. Example: "Two words mean 'prepare for exercise'"
7-8: Reveal 2 pairs explicitly
9-10: Full solution

NEVER give pairs at levels 1-6. Max 15 words for levels 1-4.`
            },
            slate: {
                id: 'slate', name: 'Slate', icon: 'ðŸ“',
                hasLocalData: true, needsInput: true,
                inputLabel: "Which row? (1-5)", inputPlaceholder: "e.g., 3",
                hintDescs: { low: "Row theme", mid: "Letter hints", high: "Word reveal" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Slate: Guess 5-letter words for each row based on clues.

Hint levels:
1-2: Vague category. Example: "Think animals"
3-4: Specific category. Example: "A farm animal"
5-6: Letter structure. Example: "Starts with H, 5 letters"
7-8: More letters. Example: "H_R_E"
9-10: The word

Keep levels 1-4 under 10 words.`
            },
            // === NYT ADDITIONAL ===
            letterboxed: {
                id: 'letterboxed', name: 'Letterboxed', icon: 'ðŸ“¦',
                startDate: '2018-01-01', needsInput: false,
                searchQuery: (date) => `NYT Letterboxed ${date} solution`,
                hintDescs: { low: "Strategy hints", mid: "Starting word", high: "Solution" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Letterboxed: Use all 12 letters, alternating sides, in fewest words.

Hint levels:
1-2: General strategy. Example: "Look for long words with uncommon letters"
3-4: Letter focus. Example: "Try starting with Q or X"
5-6: First word hint. Example: "First word starts with QU, 7 letters"
7-8: First word revealed. Example: "Start with SEQUOIA"
9-10: Complete solution with all words

Keep levels 1-4 under 12 words.`
            },
            // === LINKEDIN GAMES ===
            queens: {
                id: 'queens', name: 'Queens', icon: 'ðŸ‘‘',
                startDate: '2024-01-01', needsInput: false,
                searchQuery: (date) => `LinkedIn Queens puzzle ${date} solution`,
                hintDescs: { low: "Region hints", mid: "Placement hints", high: "Solution" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Queens: Place queens so each row, column, and color region has exactly one.

Hint levels:
1-2: Strategy. Example: "Start with the smallest color region"
3-4: Region hint. Example: "Pink region's queen goes in row 3"
5-6: Two placements. Example: "Pink: row 3, col 2. Blue: row 1, col 5"
7-8: Half the board. Example: "Pink R3C2, Blue R1C5, Green R4C1, Yellow R2C4"
9-10: Full solution with all placements

Keep levels 1-4 under 12 words.`
            },
            tango: {
                id: 'tango', name: 'Tango', icon: 'ðŸ’ƒ',
                startDate: '2024-01-01', needsInput: false,
                searchQuery: (date) => `LinkedIn Tango puzzle ${date} solution`,
                hintDescs: { low: "Pattern hints", mid: "Row/column hints", high: "Solution" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Tango: Fill grid with suns/moons - no 3 in a row, equal per row/column.

Hint levels:
1-2: Strategy. Example: "Look for rows with 2 suns already together"
3-4: Specific cell. Example: "Row 2, Column 4 must be a moon"
5-6: Full row. Example: "Row 1: sun, moon, sun, moon, sun, moon"
7-8: Half the grid. Example: "Rows 1-3 complete: [pattern]"
9-10: Full solution

Keep levels 1-4 under 12 words.`
            },
            pinpoint: {
                id: 'pinpoint', name: 'Pinpoint', icon: 'ðŸ“',
                startDate: '2024-01-01', needsInput: true,
                inputLabel: "Clue # stuck on? (1-5)", inputPlaceholder: "e.g., 3",
                searchQuery: (date) => `LinkedIn Pinpoint ${date} answer category`,
                hintDescs: { low: "Clue hints", mid: "Category hints", high: "Answer" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Pinpoint: Guess the category connecting 5 clues. Fewer clues = better score.

Hint levels:
1-2: Vague direction. Example: "Think about things in a home"
3-4: Narrower category. Example: "Kitchen-related"
5-6: Very specific. Example: "Things that heat food"
7-8: Almost there. Example: "Kitchen appliances that..."
9-10: The answer`
            },
            crossclimb: {
                id: 'crossclimb', name: 'Crossclimb', icon: 'ðŸ§—',
                startDate: '2024-01-01', needsInput: true,
                inputLabel: "Which rung? (1-5)", inputPlaceholder: "e.g., 2",
                searchQuery: (date) => `LinkedIn Crossclimb ${date} answers`,
                hintDescs: { low: "Theme hints", mid: "Word hints", high: "Answers" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Crossclimb: Solve clues, arrange by word length to climb the ladder.

Hint levels:
1-2: Theme hint. Example: "Clues relate to weather"
3-4: Specific clue hint. Example: "The 4-letter word means precipitation"
5-6: Letter hints. Example: "4-letter word starts with R"
7-8: Reveal 2-3 words
9-10: All answers in order`
            },
            zip: {
                id: 'zip', name: 'Zip', icon: 'âš¡',
                startDate: '2024-01-01', needsInput: false,
                searchQuery: (date) => `LinkedIn Zip puzzle ${date} solution`,
                hintDescs: { low: "Path hints", mid: "Number hints", high: "Solution" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Zip: Draw paths connecting matching numbers, filling every cell.

Hint levels:
1-2: Strategy. Example: "Start with numbers in corners"
3-4: Specific path. Example: "The 1s connect along the top edge"
5-6: Two complete paths described
7-8: Most paths revealed
9-10: Full solution`
            },
            // === OTHER POPULAR GAMES ===
            quordle: {
                id: 'quordle', name: 'Quordle', icon: '4ï¸âƒ£',
                startDate: '2022-01-01', needsInput: true,
                inputLabel: "Which quadrant? (1-4)", inputPlaceholder: "e.g., 3",
                searchQuery: (date) => `Quordle ${date} answers`,
                hintDescs: { low: "Category hints", mid: "Letter hints", high: "Answers" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Quordle: Solve 4 Wordles simultaneously in 9 guesses.

Hint levels:
1-2: Vague. Example: "One word is a common noun"
3-4: Category. Example: "Quadrant 3 relates to food"
5-6: Letter structure. Example: "Quadrant 3 has double letters"
7-8: Specific letters. Example: "Quadrant 3 starts with BR"
9-10: The word(s)`
            },
            contexto: {
                id: 'contexto', name: 'Contexto', icon: 'ðŸŽ¯',
                startDate: '2022-01-01', needsInput: false,
                searchQuery: (date) => `Contexto ${date} answer`,
                hintDescs: { low: "Field hints", mid: "Category hints", high: "Answer" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Contexto: Guess the secret word using semantic similarity rankings.

Hint levels:
1-2: Very vague field. Example: "Think concrete nouns"
3-4: General category. Example: "Related to buildings"
5-6: Specific category. Example: "Part of a house"
7-8: Very close. Example: "Where you sleep"
9-10: The answer`
            },
            // === MORE WORDLE VARIANTS ===
            octordle: {
                id: 'octordle', name: 'Octordle', icon: '8ï¸âƒ£',
                startDate: '2022-01-01', needsInput: true,
                inputLabel: "Which board? (1-8)", inputPlaceholder: "e.g., 5",
                searchQuery: (date) => `Octordle ${date} answers`,
                hintDescs: { low: "Category hints", mid: "Letter hints", high: "Answers" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Octordle: Solve 8 Wordles simultaneously in 13 guesses.

Hint levels:
1-2: Vague. Example: "Board 5 is a common verb"
3-4: Category. Example: "Board 5 relates to movement"
5-6: Letter structure. Example: "Board 5 has double letters"
7-8: Specific letters. Example: "Board 5 starts with W, ends in K"
9-10: The word`
            },
            dordle: {
                id: 'dordle', name: 'Dordle', icon: '2ï¸âƒ£',
                startDate: '2022-01-01', needsInput: true,
                inputLabel: "Which side? (left/right)", inputPlaceholder: "e.g., left",
                searchQuery: (date) => `Dordle ${date} answers`,
                hintDescs: { low: "Category hints", mid: "Letter hints", high: "Answers" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Dordle: Solve 2 Wordles simultaneously in 7 guesses.

Hint levels:
1-2: Vague. Example: "Left word is a noun"
3-4: Category. Example: "Left word is an animal"
5-6: Letter structure. Example: "Left word starts with vowel"
7-8: Specific letters. Example: "Left word is _A_ER"
9-10: The word`
            },
            waffle: {
                id: 'waffle', name: 'Waffle', icon: 'ðŸ§‡',
                startDate: '2022-01-01', needsInput: false,
                searchQuery: (date) => `Waffle game ${date} answers`,
                hintDescs: { low: "Word hints", mid: "Swap hints", high: "Solution" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Waffle: Swap letters to form 6 words in a grid (3 horizontal, 3 vertical).

Hint levels:
1-2: One word hint. Example: "Top row is a color"
3-4: Two word hints. Example: "Top row: color. Middle row: animal"
5-6: Specific swap. Example: "Swap A in row 1, col 3 with E in row 3, col 3"
7-8: Multiple swaps. Example: "Swap Aâ†”E (r1c3, r3c3), swap Oâ†”I (r2c1, r2c5)"
9-10: All 6 words

Keep levels 1-4 under 12 words.`
            },
            nerdle: {
                id: 'nerdle', name: 'Nerdle', icon: 'ðŸ§®',
                startDate: '2022-01-01', needsInput: false,
                searchQuery: (date) => `Nerdle ${date} answer equation`,
                hintDescs: { low: "Operation hints", mid: "Number hints", high: "Equation" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Nerdle: Guess the 8-character math equation in 6 tries.

Hint levels:
1-2: Operation hint. Example: "Uses multiplication"
3-4: Structure hint. Example: "Two-digit times one-digit"
5-6: Partial numbers. Example: "Starts with 1, result is two digits"
7-8: Most of equation. Example: "1? * 7 = ??"
9-10: Full equation`
            },
            // === GEOGRAPHY GAMES ===
            worldle: {
                id: 'worldle', name: 'Worldle', icon: 'ðŸŒ',
                startDate: '2022-01-01', needsInput: false,
                searchQuery: (date) => `Worldle ${date} answer country`,
                hintDescs: { low: "Region hints", mid: "Continent hints", high: "Country" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Worldle: Guess the country from its silhouette shape.

Hint levels:
1-2: Hemisphere. Example: "Northern hemisphere"
3-4: Continent. Example: "In Africa"
5-6: Region. Example: "West African coast"
7-8: Neighbors. Example: "Borders Nigeria and Benin"
9-10: The country

Keep levels 1-4 under 6 words.`
            },
            globle: {
                id: 'globle', name: 'Globle', icon: 'ðŸŒŽ',
                startDate: '2022-01-01', needsInput: false,
                searchQuery: (date) => `Globle ${date} answer country`,
                hintDescs: { low: "Region hints", mid: "Proximity hints", high: "Country" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Globle: Guess the country using proximity clues (warmer = closer).

Hint levels:
1-2: Hemisphere. Example: "Southern hemisphere"
3-4: Continent. Example: "In South America"
5-6: Region. Example: "Southern cone region"
7-8: Specific area. Example: "Between Chile and Brazil"
9-10: The country

Keep levels 1-4 under 6 words.`
            },
            tradle: {
                id: 'tradle', name: 'Tradle', icon: 'ðŸš¢',
                startDate: '2022-01-01', needsInput: false,
                searchQuery: (date) => `Tradle ${date} answer country exports`,
                hintDescs: { low: "Economy hints", mid: "Region hints", high: "Country" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Tradle: Guess the country from its export treemap.

Hint levels:
1-2: Economy type. Example: "Oil-based economy"
3-4: Region. Example: "Middle Eastern country"
5-6: Specific hint. Example: "Persian Gulf nation"
7-8: Narrowed down. Example: "Small gulf state, not Saudi"
9-10: The country`
            },
            travle: {
                id: 'travle', name: 'Travle', icon: 'âœˆï¸',
                startDate: '2022-01-01', needsInput: false,
                searchQuery: (date) => `Travle ${date} answer path countries`,
                hintDescs: { low: "Region hints", mid: "Path hints", high: "Solution" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Travle: Find the shortest path between two countries through bordering nations.

Hint levels:
1-2: General direction. Example: "Path goes through Europe"
3-4: Key country. Example: "You must pass through Germany"
5-6: Two countries. Example: "Path includes Germany and Poland"
7-8: Most of path. Example: "France â†’ Germany â†’ Poland â†’ ?"
9-10: Complete optimal path

Keep levels 1-4 under 10 words.`
            },
            // === ENTERTAINMENT ===
            framed: {
                id: 'framed', name: 'Framed', icon: 'ðŸŽ¬',
                startDate: '2022-01-01', needsInput: false,
                searchQuery: (date) => `Framed game ${date} answer movie`,
                hintDescs: { low: "Genre hints", mid: "Era/actor hints", high: "Movie" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Framed: Guess the movie from still frames (6 guesses, more frames revealed).

Hint levels:
1-2: Genre. Example: "It's a sci-fi film"
3-4: Era/decade. Example: "Released in the 2010s"
5-6: Actor/director. Example: "Stars Tom Hanks"
7-8: Plot hint. Example: "About a stranded astronaut"
9-10: The movie title

Keep levels 1-4 under 8 words.`
            },
            actorle: {
                id: 'actorle', name: 'Actorle', icon: 'ðŸŽ­',
                startDate: '2022-01-01', needsInput: false,
                searchQuery: (date) => `Actorle ${date} answer actor`,
                hintDescs: { low: "Era hints", mid: "Genre/role hints", high: "Actor" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Actorle: Guess the actor from their filmography clues.

Hint levels:
1-2: Era. Example: "Active since the 1990s"
3-4: Genre. Example: "Known for action movies"
5-6: Famous role hint. Example: "Played a superhero"
7-8: Specific movie. Example: "Starred in The Matrix"
9-10: The actor's name`
            },
            moviedle: {
                id: 'moviedle', name: 'Moviedle', icon: 'ðŸŽ¥',
                startDate: '2022-01-01', needsInput: false,
                searchQuery: (date) => `Moviedle ${date} answer movie`,
                hintDescs: { low: "Genre hints", mid: "Era/cast hints", high: "Movie" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Moviedle: Guess the movie from a sped-up version of the entire film.

Hint levels:
1-2: Genre. Example: "It's a comedy"
3-4: Era. Example: "From the 2000s"
5-6: Cast hint. Example: "Features Will Ferrell"
7-8: Plot hint. Example: "About a news anchor"
9-10: The movie title`
            },
            heardle: {
                id: 'heardle', name: 'Heardle', icon: 'ðŸŽµ',
                startDate: '2022-01-01', needsInput: false,
                searchQuery: (date) => `Heardle ${date} answer song`,
                hintDescs: { low: "Genre hints", mid: "Era/artist hints", high: "Song" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Heardle: Guess the song from its intro (more seconds revealed each guess).

Hint levels:
1-2: Genre. Example: "It's a pop song"
3-4: Era. Example: "From the 1980s"
5-6: Artist hint. Example: "By a British band"
7-8: Artist name. Example: "By Queen"
9-10: Full song title and artist`
            },
            bandle: {
                id: 'bandle', name: 'Bandle', icon: 'ðŸŽ¸',
                startDate: '2022-01-01', needsInput: false,
                searchQuery: (date) => `Bandle ${date} answer song`,
                hintDescs: { low: "Genre hints", mid: "Band hints", high: "Song" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Bandle: Guess the song as instruments are added one by one.

Hint levels:
1-2: Genre. Example: "It's a rock song"
3-4: Era. Example: "Released in the 2010s"
5-6: Band hint. Example: "By an American band"
7-8: Band name. Example: "By Imagine Dragons"
9-10: Full song title`
            },
            redactle: {
                id: 'redactle', name: 'Redactle', icon: 'â–ˆ',
                startDate: '2022-01-01', needsInput: false,
                searchQuery: (date) => `Redactle ${date} answer wikipedia article`,
                hintDescs: { low: "Category hints", mid: "Topic hints", high: "Article" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Redactle: Guess words to reveal a redacted Wikipedia article.

Hint levels:
1-2: Broad category. Example: "It's about a person"
3-4: Specific category. Example: "A historical figure"
5-6: Field/era. Example: "A 20th century scientist"
7-8: Narrowed down. Example: "Nobel Prize winner in physics"
9-10: The article subject`
            },
            semantle: {
                id: 'semantle', name: 'Semantle', icon: 'ðŸ§ ',
                startDate: '2022-01-01', needsInput: false,
                searchQuery: (date) => `Semantle ${date} answer word`,
                hintDescs: { low: "Category hints", mid: "Semantic hints", high: "Word" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Semantle: Guess the word using semantic similarity scores (like Contexto).

Hint levels:
1-2: Part of speech. Example: "It's a noun"
3-4: Broad category. Example: "Related to nature"
5-6: Specific category. Example: "A type of plant"
7-8: Very close. Example: "Grows in forests, has bark"
9-10: The word`
            },
            wheretaken: {
                id: 'wheretaken', name: 'WhereTaken', icon: 'ðŸ“¸',
                startDate: '2022-01-01', needsInput: false,
                searchQuery: (date) => `WhereTaken ${date} answer country location`,
                hintDescs: { low: "Region hints", mid: "Country hints", high: "Location" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

WhereTaken: Guess where a photo was taken (country/location).

Hint levels:
1-2: Continent. Example: "Somewhere in Europe"
3-4: Region. Example: "Western Europe"
5-6: Country hint. Example: "A Mediterranean country"
7-8: Country. Example: "It's in Italy"
9-10: Specific location`
            },
            foodguessr: {
                id: 'foodguessr', name: 'FoodGuessr', icon: 'ðŸ•',
                startDate: '2022-01-01', needsInput: false,
                searchQuery: (date) => `FoodGuessr ${date} answer food country`,
                hintDescs: { low: "Cuisine hints", mid: "Region hints", high: "Dish/Country" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

FoodGuessr: Guess the origin of a food dish.

Hint levels:
1-2: Cuisine type. Example: "Asian cuisine"
3-4: Region. Example: "Southeast Asian"
5-6: Country hint. Example: "Uses fish sauce, rice noodles"
7-8: Country. Example: "It's from Vietnam"
9-10: The dish name and country`
            },
            'immaculate-grid': {
                id: 'immaculate-grid', name: 'Immaculate Grid', icon: 'âš¾',
                startDate: '2023-01-01', needsInput: true,
                inputLabel: "Which cell? (e.g., Row1-Col2)", inputPlaceholder: "e.g., 1-2",
                searchQuery: (date) => `Immaculate Grid baseball ${date} answers`,
                hintDescs: { low: "Team/stat hints", mid: "Era hints", high: "Player" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Immaculate Grid: Name MLB players matching row/column criteria.

Hint levels:
1-2: Era hint. Example: "Look for players from the 2000s"
3-4: Position hint. Example: "Consider pitchers"
5-6: Team hint. Example: "Played for both Yankees and Red Sox"
7-8: Narrowed. Example: "All-Star pitcher, 2010s, both teams"
9-10: A valid player name`
            },
            costcodle: {
                id: 'costcodle', name: 'Costcodle', icon: 'ðŸ›’',
                startDate: '2023-01-01', needsInput: false,
                searchQuery: (date) => `Costcodle ${date} answer price`,
                hintDescs: { low: "Category hints", mid: "Price range", high: "Price" },
                systemPrompt: `CRITICAL RULES - FOLLOW EXACTLY:
1. Output ONLY the hint itself - nothing else
2. FORBIDDEN: "I see", "I notice", "I found", "Let me", "Based on", "Looking at", "The search", "results show", "According to"
3. NO explanations, NO meta-commentary about search results, NO preamble
4. Start your response with the hint directly

Costcodle: Guess the Costco price of a product.

Hint levels:
1-2: Category. Example: "It's an electronics item"
3-4: Price range. Example: "Between $50 and $200"
5-6: Narrower range. Example: "Around $100-$150"
7-8: Very close. Example: "Within $20 of the answer"
9-10: The exact price`
            }
        };
        
        const HINT_LEVEL_NAMES = {
            1: "Whisper", 2: "Murmur", 3: "Hint", 4: "Nudge", 5: "Guide",
            6: "Assist", 7: "Help", 8: "Reveal", 9: "Spoiler", 10: "Answer"
        };
        
        let hintCurrentGame = null;
        let hintLevel = 4;
        let hintHistory = [];
        let hintLocalData = null;
        let hintLoading = false;
        
        // Check for hint data and show/hide badges
        function checkHintData() {
            try {
                const stored = localStorage.getItem('gameshelf_hint_data');
                const headerHintBtn = document.getElementById('header-hint-btn');
                
                if (!stored) {
                    if (headerHintBtn) headerHintBtn.classList.remove('has-badge');
                    return null;
                }
                
                const data = JSON.parse(stored);
                const age = Date.now() - data.timestamp;
                
                // Add badge if data is recent (within 24 hours)
                if (age < 24 * 60 * 60 * 1000) {
                    if (headerHintBtn) headerHintBtn.classList.add('has-badge');
                    hintLocalData = data;
                    return data;
                }
                
                if (headerHintBtn) headerHintBtn.classList.remove('has-badge');
                return null;
            } catch (e) {
                console.warn('Could not read hint data:', e);
                return null;
            }
        }
        
        // Initialize hint system on page load and visibility change
        function initHintSystem() {
            checkHintData();
            
            // Re-check when page becomes visible (user might have played a game)
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') {
                    setTimeout(checkHintData, 500);
                }
            });
        }
        
        function openHintSheet() {
            const localData = checkHintData();
            
            // Map Game Shelf game IDs to hint game IDs
            const gameIdMap = {
                // NYT Games
                'nyt-connections': 'connections',
                'connections': 'connections',
                'nyt-wordle': 'wordle',
                'wordle': 'wordle',
                'nyt-strands': 'strands',
                'strands': 'strands',
                'nyt-spelling-bee': 'spellingbee',
                'spelling-bee': 'spellingbee',
                'nyt-mini': 'mini',
                'mini': 'mini',
                'nyt-letterboxed': 'letterboxed',
                'letterboxed': 'letterboxed',
                // LinkedIn Games
                'queens': 'queens',
                'tango': 'tango',
                'pinpoint': 'pinpoint',
                'crossclimb': 'crossclimb',
                'zip': 'zip',
                // GS Originals
                'quotle': 'quotle',
                'rungs': 'rungs',
                'slate': 'slate',
                // Wordle variants
                'quordle': 'quordle',
                'octordle': 'octordle',
                'dordle': 'dordle',
                'waffle': 'waffle',
                'nerdle': 'nerdle',
                // Geography
                'worldle': 'worldle',
                'globle': 'globle',
                'tradle': 'tradle',
                'travle': 'travle',
                'wheretaken': 'wheretaken',
                'foodguessr': 'foodguessr',
                // Entertainment
                'framed': 'framed',
                'actorle': 'actorle',
                'moviedle': 'moviedle',
                'heardle': 'heardle',
                'bandle': 'bandle',
                // Other
                'contexto': 'contexto',
                'redactle': 'redactle',
                'semantle': 'semantle',
                'immaculate-grid': 'immaculate-grid',
                'costcodle': 'costcodle'
            };
            
            // Determine the hint game based on priority:
            // 1. lastLaunchedGame (most recent user action)
            // 2. localStorage hint data (if matches a GS Original and no game launched)
            // 3. Fallback to connections
            
            let selectedGameId = null;
            let selectedLocalData = null;
            
            if (lastLaunchedGame) {
                // User launched a game - use that
                const mappedId = gameIdMap[lastLaunchedGame] || lastLaunchedGame;
                if (HINT_GAMES[mappedId]) {
                    selectedGameId = mappedId;
                    // Only use local data if it matches the launched game
                    if (localData && localData.gameId === mappedId) {
                        selectedLocalData = localData;
                    }
                }
            }
            
            // If no game launched, check localStorage for GS Originals
            if (!selectedGameId && localData && HINT_GAMES[localData.gameId]) {
                selectedGameId = localData.gameId;
                selectedLocalData = localData;
            }
            
            // Fallback to connections
            if (!selectedGameId) {
                selectedGameId = 'connections';
            }
            
            selectHintGame(selectedGameId, selectedLocalData);
            document.getElementById('hint-sheet-overlay').classList.add('active');
            document.getElementById('hint-result').style.display = 'none';
            document.getElementById('hint-error').style.display = 'none';
            document.getElementById('hint-get-btn').style.display = 'block';
            
            // Show sign-in prompt if not logged in
            if (!currentUser) {
                document.getElementById('hint-error').innerHTML = 'ðŸ” <strong>Sign in required</strong><br>AI hints require a Game Shelf account. <a href="#" onclick="closeHintSheet(); signInWithGoogle(); return false;" style="color: var(--accent-purple);">Sign in â†’</a>';
                document.getElementById('hint-error').style.display = 'block';
            }
        }
        
        function closeHintSheet() {
            document.getElementById('hint-sheet-overlay').classList.remove('active');
        }
        
        function selectHintGame(gameId, localData = null) {
            const game = HINT_GAMES[gameId];
            if (!game) return;
            
            hintCurrentGame = game;
            hintLocalData = localData;
            hintHistory = [];
            
            // Update UI
            document.getElementById('hint-game-icon').textContent = game.icon;
            document.getElementById('hint-game-name').textContent = game.name;
            
            // Calculate puzzle number
            const today = new Date();
            let puzzleNum = localData?.puzzleNumber;
            if (!puzzleNum && game.startDate) {
                const start = new Date(game.startDate);
                puzzleNum = Math.floor((today - start) / (1000 * 60 * 60 * 24));
            }
            
            const dateStr = today.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
            document.getElementById('hint-game-puzzle').textContent = puzzleNum ? `#${puzzleNum} â€¢ ${dateStr}` : dateStr;
            
            // Show/hide detected badge
            const gameCard = document.getElementById('hint-game-card');
            const badge = document.getElementById('hint-detected-badge');
            if (localData) {
                gameCard.classList.add('detected');
                badge.style.display = 'inline-flex';
                badge.innerHTML = '<span>âœ“</span> Puzzle data detected';
            } else {
                gameCard.classList.remove('detected');
                badge.style.display = 'none';
            }
            
            // Show/hide input section
            const inputSection = document.getElementById('hint-input-section');
            if (game.needsInput && (!localData || game.inputRequired)) {
                inputSection.style.display = 'block';
                document.getElementById('hint-input-label').textContent = game.inputLabel || 'Additional info:';
                document.getElementById('hint-input').placeholder = game.inputPlaceholder || '';
                document.getElementById('hint-input').value = '';
            } else {
                inputSection.style.display = 'none';
            }
            
            // Update game chips
            document.querySelectorAll('.hint-game-chip').forEach(chip => {
                chip.classList.remove('active');
                if (chip.getAttribute('onclick')?.includes(gameId)) {
                    chip.classList.add('active');
                }
            });
            
            // Reset UI
            document.getElementById('hint-result').style.display = 'none';
            document.getElementById('hint-error').style.display = 'none';
            document.getElementById('hint-history').style.display = 'none';
            document.getElementById('hint-get-btn').style.display = 'block';
            updateHintLevel(hintLevel);
        }
        
        function updateHintLevel(level) {
            level = parseInt(level);
            hintLevel = level;
            
            const slider = document.getElementById('hint-level-slider');
            const levelValue = document.getElementById('hint-level-value');
            const btnLevel = document.getElementById('hint-btn-level');
            
            if (slider) slider.value = level;
            if (levelValue) levelValue.textContent = `${level}/10 â€¢ ${HINT_LEVEL_NAMES[level]}`;
            if (btnLevel) btnLevel.textContent = level;
            
            // Update level bar
            const segments = document.querySelectorAll('.hint-level-segment');
            segments.forEach((seg, i) => {
                seg.classList.remove('active', 'green', 'yellow', 'red');
                if (i < level) {
                    seg.classList.add('active');
                    if (i < 3) seg.classList.add('green');
                    else if (i < 6) seg.classList.add('yellow');
                    else seg.classList.add('red');
                }
            });
            
            // Update description
            const desc = hintCurrentGame?.hintDescs;
            if (desc) {
                const descEl = document.getElementById('hint-level-desc');
                if (descEl) {
                    const descText = level <= 4 ? desc.low : level <= 7 ? desc.mid : desc.high;
                    descEl.textContent = descText;
                }
            }
            
            // Update still stuck button
            const stillStuckBtn = document.getElementById('hint-still-stuck');
            if (stillStuckBtn) {
                stillStuckBtn.textContent = level >= 10 ? 'Max level' : `ðŸ˜© Level ${level + 1}`;
                stillStuckBtn.disabled = level >= 10;
            }
        }
        
        async function getHint(level = hintLevel) {
            if (!hintCurrentGame || hintLoading) return;
            
            // Check if user is signed in
            if (!currentUser) {
                document.getElementById('hint-error').innerHTML = 'ðŸ” <a href="#" onclick="closeHintSheet(); signInWithGoogle(); return false;" style="color: var(--accent-purple);">Sign in</a> to use AI hints.';
                document.getElementById('hint-error').style.display = 'block';
                return;
            }
            
            // ===== Check token balance =====
            const HINT_COST = 5;
            const tokens = appData.wallet?.tokens || 0;
            
            if (tokens < HINT_COST) {
                showInsufficientTokensSheet(tokens, HINT_COST);
                return;
            }
            // ===== End token check =====
            
            const game = hintCurrentGame;
            const userInput = document.getElementById('hint-input').value.trim();
            
            // Validate required input
            if (game.inputRequired && !userInput && !hintLocalData) {
                document.getElementById('hint-error').textContent = `Please provide: ${game.inputLabel}`;
                document.getElementById('hint-error').style.display = 'block';
                return;
            }
            
            hintLoading = true;
            const btn = document.getElementById('hint-get-btn');
            btn.disabled = true;
            btn.classList.add('loading');
            document.getElementById('hint-error').style.display = 'none';
            
            // Animated loading states
            const loadingMessages = game.hasLocalData && !game.id.includes('quotle')
                ? ['ðŸ¤” Thinking', 'ðŸ’­ Analyzing', 'âœ¨ Generating']
                : ['ðŸ” Searching', 'ðŸ¤” Thinking', 'âœ¨ Generating'];
            let msgIndex = 0;
            
            const updateLoadingText = () => {
                btn.innerHTML = `<span class="hint-loading-text"><span class="spinner"></span>${loadingMessages[msgIndex]}<span class="hint-loading-dots"></span></span>`;
                msgIndex = (msgIndex + 1) % loadingMessages.length;
            };
            updateLoadingText();
            const loadingInterval = setInterval(updateLoadingText, 1500);
            
            // Retry logic
            const maxRetries = 2;
            let lastError = null;
            
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const today = new Date();
                    const dateStr = today.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' });
                    
                    // Build prompt based on game type
                    let userPrompt = `Today is ${dateStr}.\n`;
                    let needsWebSearch = true; // Default to needing web search
                    
                    if (hintLocalData && game.hasLocalData) {
                        // Use local data from Game Shelf games
                        if (game.id === 'quotle' && hintLocalData.data?.quote) {
                            userPrompt += `User is playing Quotle #${hintLocalData.puzzleNumber}.\nQuote: "${hintLocalData.data.quote}"\n`;
                            if (hintLocalData.data.category) userPrompt += `Category: ${hintLocalData.data.category}, Period: ${hintLocalData.data.period}\n`;
                            userPrompt += `Search for who said this quote, then give a LEVEL ${level}/10 hint.`;
                            needsWebSearch = true; // Quotle needs search to find author
                        } else if (game.id === 'rungs' && hintLocalData.data?.items) {
                            userPrompt += `User is playing Rungs #${hintLocalData.puzzleNumber}.\nItems: ${hintLocalData.data.items.join(', ')}\n`;
                            // Level-appropriate prompting - don't ask for analysis at low levels
                            if (level <= 4) {
                                userPrompt += `Give ONLY a LEVEL ${level}/10 thematic hint. DO NOT reveal any pairs or the solution.`;
                            } else if (level <= 6) {
                                userPrompt += `Give a LEVEL ${level}/10 hint. You may hint at ONE pair only.`;
                            } else {
                                userPrompt += `Give a LEVEL ${level}/10 hint with pairs revealed.`;
                            }
                            needsWebSearch = false; // Rungs has all data locally
                        } else if (game.id === 'slate') {
                            userPrompt += `User is playing Slate #${hintLocalData.puzzleNumber}.\n`;
                            userPrompt += `Progress: ${hintLocalData.data?.wordsCompleted || 0}/5 words, stuck on row ${userInput || hintLocalData.data?.currentRow || '?'}\n`;
                            userPrompt += `Give a LEVEL ${level}/10 hint for a 5-letter word.`;
                            needsWebSearch = false; // Slate has all data locally
                        }
                    } else {
                        // Use web search for NYT games
                        userPrompt += `Search for today's ${game.name} puzzle and give a LEVEL ${level}/10 hint.\n`;
                        if (userInput) {
                            userPrompt += `User is stuck on: ${userInput}\n`;
                        }
                        needsWebSearch = true;
                    }
                    
                    if (hintHistory.length > 0) {
                        userPrompt += `\nPrevious hints given:\n${hintHistory.map(h => `- Lvl ${h.level}: "${h.hint.substring(0, 60)}"`).join('\n')}\nGive a NEW different hint.`;
                    }
                    
                    // Call Firebase Function
                    const getHintFunction = firebase.functions().httpsCallable('getHint');
                    const result = await getHintFunction({
                        gameId: game.id,
                        level: level,
                        prompt: userPrompt,
                        systemPrompt: game.systemPrompt,
                        needsWebSearch: needsWebSearch
                    });
                    
                    const hint = result.data.hint || 'Unable to generate hint. Please try again.';
                    
                    // Success! Clear loading and show result
                    clearInterval(loadingInterval);
                    
                    // ===== Deduct tokens on success =====
                    const HINT_COST = 5;
                    appData.wallet.tokens = (appData.wallet?.tokens || 0) - HINT_COST;
                    saveData();
                    renderWallet();
                    // ===== End token deduction =====
                    
                    hintLevel = level;
                    updateHintLevel(level);
                    hintHistory.push({ level, hint });
                    
                    document.getElementById('hint-result-level').textContent = `Level ${level} Hint â€¢ ${game.name}`;
                    document.getElementById('hint-result-text').textContent = hint;
                    document.getElementById('hint-result').style.display = 'block';
                    document.getElementById('hint-get-btn').style.display = 'none';
                    
                    // v1.2.77: Play hint received sound
                    playSound('hint');
                    
                    // Show usage info if available
                    if (result.data.usage) {
                        const usage = result.data.usage;
                        console.log(`Hint usage: ${usage.hourCount}/${usage.hourLimit} this hour, ${usage.dayCount}/${usage.dayLimit} today`);
                    }
                    
                    // Update history display
                    if (hintHistory.length > 1) {
                        const historyList = document.getElementById('hint-history-list');
                        historyList.innerHTML = hintHistory.slice(0, -1).map(h => 
                            `<div class="hint-history-item"><strong>Lvl ${h.level}:</strong> ${h.hint.substring(0, 60)}...</div>`
                        ).join('');
                        document.getElementById('hint-history').style.display = 'block';
                    }
                    
                    // Success - exit retry loop
                    hintLoading = false;
                    btn.disabled = false;
                    btn.classList.remove('loading');
                    btn.innerHTML = `ðŸ†˜ Get Level <span id="hint-btn-level">${parseInt(hintLevel)}</span> Hint`;
                    return;
                    
                } catch (err) {
                    lastError = err;
                    console.warn(`Hint attempt ${attempt}/${maxRetries} failed:`, err.code || err.message);
                    
                    // Don't retry auth or rate limit errors
                    if (err.code === 'unauthenticated' || err.code === 'resource-exhausted') {
                        break;
                    }
                    
                    // Wait before retry (exponential backoff)
                    if (attempt < maxRetries) {
                        btn.innerHTML = `<span class="hint-loading-text"><span class="spinner"></span>Retrying<span class="hint-loading-dots"></span></span>`;
                        await new Promise(r => setTimeout(r, 1000 * attempt));
                    }
                }
            }
            
            // All retries failed
            clearInterval(loadingInterval);
            console.error('Hint error after retries:', lastError);
            
            // Handle specific error types
            let errorMsg = 'Failed to get hint. Please try again.';
            let isSignInError = false;
            if (lastError?.code === 'unauthenticated') {
                isSignInError = true;
            } else if (lastError?.code === 'resource-exhausted') {
                errorMsg = lastError.message || 'Rate limit reached. Try again later.';
            } else if (lastError?.code === 'failed-precondition') {
                errorMsg = 'AI hints are temporarily unavailable.';
            } else if (lastError?.message) {
                errorMsg = lastError.message;
            }
            
            if (isSignInError) {
                document.getElementById('hint-error').innerHTML = 'ðŸ” <a href="#" onclick="closeHintSheet(); signInWithGoogle(); return false;" style="color: var(--accent-purple);">Sign in</a> to use AI hints.';
            } else {
                document.getElementById('hint-error').textContent = errorMsg;
            }
            document.getElementById('hint-error').style.display = 'block';
            
            hintLoading = false;
            btn.disabled = false;
            btn.classList.remove('loading');
            btn.innerHTML = `ðŸ†˜ Get Level <span id="hint-btn-level">${parseInt(hintLevel)}</span> Hint`;
        }
        
        function hintStillStuck() {
            if (hintLevel < 10) {
                const nextLevel = hintLevel + 1;
                updateHintLevel(nextLevel);
                getHint(nextLevel);
            }
        }
        
        function hintGotIt() {
            closeHintSheet();
            showToast('Nice! ðŸŽ‰');
            hintHistory = [];
        }
        
        function resetHintSession() {
            hintHistory = [];
            document.getElementById('hint-result').style.display = 'none';
            document.getElementById('hint-history').style.display = 'none';
            document.getElementById('hint-get-btn').style.display = 'block';
            hintLevel = 4;
            updateHintLevel(4);
        }
        
        // Initialize on load
        setTimeout(initHintSystem, 1000);
        
        // ============ TAP TO LOG (iOS-friendly clipboard flow) ============
        let tapToLogDismissed = false;
        let lastCelebrationGame = null;
        
        // ============ iOS GESTURE-DEFERRED CLIPBOARD CHECK ============
        // On iOS, we can't read clipboard without a gesture. Instead of guessing,
        // we wait for a gesture then check. Different gestures get different responses:
        // - Browsing gestures (tab switch, settings): subtle nudge
        // - Game card tap: hard gate - must decide before launching
        let pendingClipboardCheck = false;
        let clipboardCheckCompletedThisReturn = false;
        let clipboardKnownThisSession = false; // True once we've read clipboard - avoids redundant iOS paste popups
        let lastCheckedClipboardHash = null;
        let pendingNudgeResult = null; // Stores parsed result for nudge accept
        let pendingNudgeText = null;   // Stores clipboard text for nudge accept
        
        // Hash clipboard content to avoid re-prompting for same content
        function hashClipboard(text) {
            if (!text) return null;
            let hash = 0;
            for (let i = 0; i < Math.min(text.length, 100); i++) {
                hash = ((hash << 5) - hash) + text.charCodeAt(i);
                hash |= 0;
            }
            return hash.toString(36);
        }
        
        // Called on non-game gestures (tab switch, settings open) - shows subtle nudge
        async function checkClipboardOnGesture(gestureType) {
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            
            // Only applies when we have a pending check
            if (!pendingClipboardCheck || clipboardCheckCompletedThisReturn) {
                return;
            }
            
            // Mark as completed so we only check once per return
            clipboardCheckCompletedThisReturn = true;
            pendingClipboardCheck = false;
            
            console.log(`ðŸ“± Gesture check (${gestureType}): Reading clipboard...`);
            
            try {
                const text = await navigator.clipboard.readText();
                
                // Successfully read clipboard - mark as known to avoid future iOS paste popups
                clipboardKnownThisSession = true;
                
                const result = parseShareText(text);
                
                if (!result) {
                    console.log('ðŸ“± Gesture check: No game result in clipboard');
                    return;
                }
                
                // Check if we already offered this exact content
                const clipboardHash = hashClipboard(text);
                if (clipboardHash === lastCheckedClipboardHash) {
                    console.log('ðŸ“± Gesture check: Already offered this clipboard content');
                    return;
                }
                
                // Check if already logged
                if (getTodayHistory()[result.gameId]) {
                    console.log(`ðŸ“± Gesture check: ${result.gameId} already logged`);
                    return;
                }
                
                // Check if already processed
                if (text === lastProcessedClipboard) {
                    console.log('ðŸ“± Gesture check: Clipboard already processed');
                    return;
                }
                
                lastCheckedClipboardHash = clipboardHash;
                const game = GAMES[result.gameId];
                
                // Show subtle nudge banner
                showClipboardNudge(game, result, text);
                
            } catch (e) {
                console.log('ðŸ“± Gesture check: Clipboard read failed:', e.message);
            }
        }
        
        // Show subtle nudge banner (non-blocking)
        function showClipboardNudge(game, result, clipboardText) {
            // Store for accept handler
            pendingNudgeResult = result;
            pendingNudgeText = clipboardText;
            
            const nudge = document.getElementById('clipboard-nudge');
            if (!nudge) return;
            
            const textEl = document.getElementById('clipboard-nudge-text');
            if (textEl) {
                textEl.textContent = `${game?.icon || 'ðŸŽ®'} ${game?.name || 'Game'} result ready`;
            }
            
            nudge.style.display = 'flex';
            console.log(`ðŸ“± Showing nudge for ${game?.name}`);
            
            // Auto-hide after 8 seconds
            setTimeout(() => {
                if (nudge.style.display !== 'none') {
                    nudge.style.display = 'none';
                    console.log('ðŸ“± Nudge auto-hidden');
                }
            }, 8000);
        }
        
        function acceptClipboardNudge() {
            const nudge = document.getElementById('clipboard-nudge');
            if (nudge) nudge.style.display = 'none';
            
            if (pendingNudgeResult) {
                const game = GAMES[pendingNudgeResult.gameId];
                if (logGame(pendingNudgeResult, 'nudge')) {
                    lastProcessedClipboard = pendingNudgeText;
                    renderAll();
                    showCelebration(game, pendingNudgeResult);
                }
            }
            pendingNudgeResult = null;
            pendingNudgeText = null;
        }
        
        function dismissClipboardNudge() {
            const nudge = document.getElementById('clipboard-nudge');
            if (nudge) nudge.style.display = 'none';
            pendingNudgeResult = null;
            pendingNudgeText = null;
            console.log('ðŸ“± Nudge dismissed');
        }
        
        // Called on game card tap - hard gate that blocks until decision
        // Returns: true = proceed with launch, false = blocked (modal handles flow)
        async function checkClipboardBeforeLaunch(targetGameId) {
            // Mark as completed
            clipboardCheckCompletedThisReturn = true;
            pendingClipboardCheck = false;
            
            // Hide any existing nudge
            const nudge = document.getElementById('clipboard-nudge');
            if (nudge) nudge.style.display = 'none';
            
            try {
                const text = await navigator.clipboard.readText();
                
                // Successfully read clipboard - mark as known to avoid future iOS paste popups
                clipboardKnownThisSession = true;
                
                const result = parseShareText(text);
                
                if (!result) {
                    console.log('ðŸ“± Launch check: No game result in clipboard');
                    return true; // Proceed normally
                }
                
                // Already logged?
                if (getTodayHistory()[result.gameId]) {
                    console.log(`ðŸ“± Launch check: ${result.gameId} already logged`);
                    return true;
                }
                
                // Already processed this clipboard?
                if (text === lastProcessedClipboard) {
                    console.log('ðŸ“± Launch check: Clipboard already processed');
                    return true;
                }
                
                const sourceGame = GAMES[result.gameId];
                
                // SAME GAME - high confidence, auto-record
                if (result.gameId === targetGameId) {
                    console.log(`ðŸ“± Launch check: Same game match! Auto-recording ${sourceGame?.name}`);
                    if (logGame(result, 'auto-match')) {
                        lastProcessedClipboard = text;
                        showToast(`${sourceGame?.icon || 'ðŸŽ®'} ${sourceGame?.name} recorded!`, 'success');
                        renderAll();
                    }
                    return true; // Proceed - playGame will see it's logged and show "Already Played"
                }
                
                // DIFFERENT GAME - intercept with modal
                const targetGame = GAMES[targetGameId];
                console.log(`ðŸ“± Launch check: Different game - showing intercept modal`);
                console.log(`   Source: ${sourceGame?.name}, Target: ${targetGame?.name}`);
                
                return new Promise((resolve) => {
                    showRecordBeforeLaunchModal(sourceGame, targetGame, result, text, targetGameId, resolve);
                });
                
            } catch (e) {
                console.log('ðŸ“± Launch check: Clipboard read failed:', e.message);
                return true; // Proceed on error
            }
        }
        
        // Context for modal button handlers
        let pendingLaunchContext = null;
        
        function showRecordBeforeLaunchModal(sourceGame, targetGame, result, clipboardText, targetGameId, resolve) {
            // Store context for button handlers
            pendingLaunchContext = { result, clipboardText, targetGameId, resolve };
            
            showGenericSheet({
                title: `ðŸ“‹ Record ${sourceGame?.name || 'Game'} First?`,
                content: `
                    <div style="padding: 16px; text-align: center;">
                        <div style="font-size: 2.5rem; margin-bottom: 12px;">${sourceGame?.icon || 'ðŸŽ®'}</div>
                        <p style="color: var(--text-secondary); margin-bottom: 20px;">
                            You have <strong>${sourceGame?.name}</strong> results ready to record.
                        </p>
                        
                        <div style="display: flex; flex-direction: column; gap: 10px;">
                            <button onclick="recordAndLaunch()" style="
                                width: 100%;
                                padding: 14px;
                                background: var(--accent-purple);
                                border: none;
                                border-radius: 10px;
                                color: white;
                                font-size: 1rem;
                                font-weight: 600;
                                cursor: pointer;
                            ">
                                âœ“ Record & Play ${targetGame?.name || 'Game'}
                            </button>
                            
                            <button onclick="skipRecordAndLaunch()" style="
                                width: 100%;
                                padding: 14px;
                                background: var(--bg-tertiary);
                                border: 1px solid var(--border);
                                border-radius: 10px;
                                color: var(--text-secondary);
                                font-size: 1rem;
                                cursor: pointer;
                            ">
                                Skip for now
                            </button>
                        </div>
                    </div>
                `,
                onClose: () => {
                    // If they dismiss by tapping overlay, proceed to game
                    if (pendingLaunchContext) {
                        pendingLaunchContext.resolve(true);
                        pendingLaunchContext = null;
                    }
                }
            });
        }
        
        function recordAndLaunch() {
            const ctx = pendingLaunchContext;
            if (ctx?.result) {
                const game = GAMES[ctx.result.gameId];
                if (logGame(ctx.result, 'intercept')) {
                    lastProcessedClipboard = ctx.clipboardText;
                    showToast(`${game?.icon || 'ðŸŽ®'} ${game?.name} recorded!`, 'success');
                    renderAll();
                }
            }
            closeGenericSheet();
            if (ctx) {
                ctx.resolve(true); // Proceed to target game
                pendingLaunchContext = null;
            }
        }
        
        function skipRecordAndLaunch() {
            closeGenericSheet();
            if (pendingLaunchContext) {
                pendingLaunchContext.resolve(true); // Proceed to target game
                pendingLaunchContext = null;
            }
        }
        
        // Show the tap-to-log card when user returns to app
        function showTapToLogCard(game = null) {
            const card = document.getElementById('tap-to-log-card');
            if (!card || tapToLogDismissed) return;
            
            // Update text if we know the game
            if (game) {
                document.getElementById('tap-to-log-icon').textContent = game.icon;
                document.getElementById('tap-to-log-title').textContent = `Log ${game.name}?`;
            } else {
                document.getElementById('tap-to-log-icon').textContent = 'ðŸ“‹';
                document.getElementById('tap-to-log-title').textContent = 'Just played a game?';
            }
            
            card.style.display = 'block';
        }
        
        function hideTapToLogCard() {
            const card = document.getElementById('tap-to-log-card');
            if (card) card.style.display = 'none';
        }
        
        function dismissTapToLog(event) {
            if (event) event.stopPropagation();
            hideTapToLogCard();
            tapToLogDismissed = true;
            // Reset after 5 minutes
            setTimeout(() => { tapToLogDismissed = false; }, 300000);
        }
        
        // Handle tap - this is the user gesture that allows clipboard access on iOS
        async function tapToLogClipboard() {
            try {
                // This tap IS the user gesture - now we can read clipboard
                if (!navigator.clipboard || !navigator.clipboard.readText) {
                    // Fallback to paste prompt
                    hideTapToLogCard();
                    openLogSheet();
                    return;
                }
                
                const text = await navigator.clipboard.readText();
                const result = parseShareText(text);
                
                if (result) {
                    const todayHistory = getTodayHistory();
                    const game = GAMES[result.gameId];
                    
                    if (todayHistory[result.gameId]) {
                        // Already logged - tell user and refresh UI to show it
                        hideTapToLogCard();
                        renderAll(); // Ensure UI shows the logged game
                        showToast(`${game?.icon || 'ðŸŽ®'} ${game?.name || 'Game'} already logged today!`, 'info');
                        return;
                    }
                    
                    // Log it!
                    if (logGame(result, 'prompt')) {
                        hideTapToLogCard();
                        renderAll();
                        showCelebration(game, result);
                    }
                } else {
                    // Couldn't parse - open manual log
                    hideTapToLogCard();
                    openLogSheet();
                    showToast('Paste your game results', 'info');
                }
            } catch (e) {
                console.log('Clipboard access denied:', e);
                // Fallback to manual
                hideTapToLogCard();
                openLogSheet();
            }
        }
        
        // ============ CELEBRATION MODAL ============
        function showCelebration(game, result) {
            const overlay = document.getElementById('celebration-overlay');
            if (!overlay) return;
            
            const stats = appData.stats[result.gameId] || {};
            const streak = stats.currentStreak || 1;
            
            // Store for next action
            lastCelebrationGame = { game, result };
            
            // Update content
            document.getElementById('celebration-game-icon').textContent = game?.icon || 'ðŸŽ®';
            document.getElementById('celebration-game-name').textContent = game?.name || 'Game';
            document.getElementById('celebration-score').textContent = result.score;
            
            // Emoji based on performance
            let emoji = 'ðŸŽ‰';
            if (result.score?.includes('1/') || result.score === 'Perfect! ðŸŽ¯') {
                emoji = 'ðŸ†';
            } else if (result.score?.includes('2/') || result.won === false) {
                emoji = result.won === false ? 'ðŸ’ª' : 'â­';
            }
            document.getElementById('celebration-emoji').textContent = emoji;
            
            // Streak
            if (streak > 1) {
                document.getElementById('celebration-streak').textContent = `ðŸ”¥ ${streak} day streak!`;
                document.getElementById('celebration-streak').style.display = 'block';
            } else {
                document.getElementById('celebration-streak').style.display = 'none';
            }
            
            // Find next game to play
            const nextGame = getNextUnplayedGame(result.gameId);
            if (nextGame) {
                document.getElementById('celebration-next-icon').textContent = nextGame.icon;
                document.getElementById('celebration-next-text').textContent = `Play ${nextGame.name}`;
                document.getElementById('celebration-next-btn').style.display = 'flex';
                document.getElementById('celebration-next-btn').onclick = () => {
                    closeCelebration();
                    playGame(nextGame.id);
                };
            } else {
                // All games played today!
                document.getElementById('celebration-next-btn').style.display = 'none';
            }
            
            // Play sound
            playSound('complete');
            if (streak > 1 && streak % 7 === 0) playSound('streak');
            
            // Show
            overlay.classList.add('active');
        }
        
        function closeCelebration() {
            const overlay = document.getElementById('celebration-overlay');
            if (overlay) overlay.classList.remove('active');
            lastCelebrationGame = null;
        }
        
        function celebrationPlayNext() {
            const nextGame = getNextUnplayedGame(lastCelebrationGame?.result?.gameId);
            closeCelebration();
            if (nextGame) {
                playGame(nextGame.id);
            }
        }
        
        function celebrationShare() {
            if (lastCelebrationGame) {
                // Store for sharing
                lastLoggedResult = lastCelebrationGame.result;
                lastLoggedGame = lastCelebrationGame.game;
            }
            closeCelebration();
            openInstantShare();
        }
        
        function getNextUnplayedGame(justPlayedId) {
            const todayHistory = getTodayHistory();
            const shelf = appData.games || [];
            
            for (const g of shelf) {
                if (g.id === justPlayedId) continue; // Skip the one we just played
                if (todayHistory[g.id]) continue; // Skip already logged
                const game = GAMES[g.id];
                if (game) return { id: g.id, ...game };
            }
            return null;
        }
        
        // Show tap-to-log when app becomes visible (iOS-friendly approach)
        function checkForTapToLog() {
            // Don't show if already dismissed recently
            if (tapToLogDismissed) return;
            
            // Don't show during onboarding
            if (document.getElementById('setup-container')?.classList.contains('active')) return;
            
            // Don't show if no game was launched from Game Shelf
            // This prevents the prompt from appearing when user switches to other apps
            if (!lastLaunchedGame) return;
            
            const todayHistory = getTodayHistory();
            
            // Don't show if the launched game is already logged
            if (todayHistory[lastLaunchedGame]) {
                clearActiveGame();
                return;
            }
            
            // For GS Originals, don't show tap-to-log - use localStorage sync instead
            // These games write to localStorage on completion, which syncs automatically
            if (isGSOriginal(lastLaunchedGame)) {
                console.log(`ðŸŽ® ${lastLaunchedGame} is a GS Original - skipping tap-to-log, using localStorage sync`);
                clearActiveGame();
                return;
            }
            
            // Show tap-to-log for the specific game that was launched
            const game = GAMES[lastLaunchedGame];
            if (game) {
                showTapToLogCard(game);
            }
        }
        
        // ============ CLIPBOARD DIFF DETECTION ============
        // Capture clipboard when user leaves the app
        async function captureClipboardOnLeave() {
            try {
                if (!navigator.clipboard || !navigator.clipboard.readText) {
                    clipboardOnLeave = CLIPBOARD_UNKNOWN;
                    console.log('ðŸ“‹ Leave: Clipboard API not available');
                    return;
                }
                
                const text = await navigator.clipboard.readText();
                clipboardOnLeave = text || '';
                console.log('ðŸ“‹ Leave: Captured clipboard state', clipboardOnLeave.substring(0, 50) + '...');
            } catch (e) {
                // Can't read clipboard (permission denied, etc.)
                clipboardOnLeave = CLIPBOARD_UNKNOWN;
                console.log('ðŸ“‹ Leave: Could not read clipboard:', e.message);
            }
        }
        
        // Check clipboard on return and show prompt if content changed
        async function checkClipboardOnReturn() {
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            
            // On iOS, we can't read clipboard without a user gesture
            // Instead of guessing (showing tap-to-log), defer until a gesture occurs
            // The gesture will either be a game card tap (hard gate) or browsing (subtle nudge)
            if (isIOS) {
                // If we already read clipboard this session, no need to check again
                // This avoids redundant iOS paste permission popups
                if (clipboardKnownThisSession) {
                    console.log('ðŸ“‹ Return (iOS): Clipboard already known this session, skipping');
                    return;
                }
                
                // Only set pending if we have a launched game context
                if (lastLaunchedGame && !getTodayHistory()[lastLaunchedGame]) {
                    pendingClipboardCheck = true;
                    clipboardCheckCompletedThisReturn = false;
                    console.log('ðŸ“‹ Return (iOS): Deferring clipboard check until gesture');
                } else {
                    console.log('ðŸ“‹ Return (iOS): No pending game or already logged, skipping');
                }
                return;
            }
            
            // Build context and calculate confidence
            const context = await buildReturnContext();
            const confidence = calculateReturnConfidence(context);
            lastConfidenceScore = confidence.score;
            
            // Track return event
            trackEvent(ANALYTICS_EVENTS.GAME_RETURN, {
                gameId: lastLaunchedGame,
                timeAway: context.timeAway,
                clipboardChanged: context.clipboardChanged,
                clipboardHadResult: context.clipboardHasGameResult,
                resultMatchedGame: context.resultMatchesLaunchedGame,
                confidenceScore: confidence.score,
                confidenceSignals: confidence.signals
            });
            
            // Check if this clipboard was already processed
            if (lastProcessedClipboard && context.currentClipboard === lastProcessedClipboard) {
                console.log('ðŸ“‹ Return: Clipboard already processed, skipping');
                return;
            }
            
            // Decision based on confidence thresholds
            // v1.2.3: Adjusted thresholds and added mismatch game handling
            
            // Very low confidence (<25): Don't prompt
            if (confidence.score < 25) {
                console.log(`ðŸ“‹ Return: Confidence too low (${confidence.score}), no prompt`);
                return;
            }
            
            // Need a valid game result to proceed
            if (!context.clipboardHasGameResult) {
                console.log('ðŸ“‹ Return: No valid game result in clipboard');
                return;
            }
            
            const result = context.parsedResult;
            
            // Check if already logged today
            if (context.alreadyLoggedToday || getTodayHistory()[result.gameId]) {
                console.log(`ðŸ“‹ Return: ${result.gameId} already logged today`);
                return;
            }
            
            const game = GAMES[result.gameId];
            detectedClipboard = { text: context.currentClipboard, result };
            
            // v1.2.3: If result is for a DIFFERENT game, handle specially
            if (confidence.signals.resultMismatch) {
                const launchedGame = GAMES[context.lastLaunchedGame];
                console.log(`ðŸ“‹ Return: Result mismatch - launched ${launchedGame?.name}, found ${game?.name}`);
                // Show a helpful toast offering to log the detected game
                showToast(`Found ${game?.icon || 'ðŸŽ®'} ${game?.name} result. Tap to log.`, 'info', 5000);
                return;
            }
            
            // High confidence (80+): Auto-log if enabled
            if (confidence.score >= 80 && appData.settings?.autoLog !== false) {
                console.log(`ðŸ“‹ Return: High confidence (${confidence.score}), auto-logging ${game?.name || result.gameId}`);
                autoLogClipboard(game, result);
                clearActiveGame();
                return;
            }
            
            // Medium confidence (60-79): Show standard prompt
            // v1.2.3: Raised threshold from 50 to 60 to reduce false positives
            if (confidence.score >= 60) {
                console.log(`ðŸ“‹ Return: Medium confidence (${confidence.score}), showing prompt for ${game?.name || result.gameId}`);
                promptShownTime = Date.now();
                trackEvent(ANALYTICS_EVENTS.PROMPT_SHOWN, {
                    gameId: result.gameId,
                    promptType: 'clipboard-detected',
                    confidenceScore: confidence.score
                });
                showClipboardPrompt(game, result);
                clearActiveGame();
                return;
            }
            
            // Lower-medium confidence (40-59): Show standard prompt but with less urgency
            // v1.2.3: New band between TOAST and NO ACTION
            if (confidence.score >= 40) {
                console.log(`ðŸ“‹ Return: Lower-medium confidence (${confidence.score}), showing prompt for ${game?.name || result.gameId}`);
                promptShownTime = Date.now();
                trackEvent(ANALYTICS_EVENTS.PROMPT_SHOWN, {
                    gameId: result.gameId,
                    promptType: 'clipboard-detected-low',
                    confidenceScore: confidence.score
                });
                showClipboardPrompt(game, result);
                clearActiveGame();
                return;
            }
            
            // Low confidence (25-39): Show subtle toast
            console.log(`ðŸ“‹ Return: Low confidence (${confidence.score}), showing subtle toast`);
            showToast(`Tap to log ${game?.icon || 'ðŸŽ®'} ${game?.name || 'game'}`, 'info', 5000);
        }
        
        // iOS-friendly: Show tap-to-log card that will check clipboard diff on tap
        // v1.2.3: Added game-aware time thresholds and dismiss time decay
        function showTapToLogCardForClipboardCheck() {
            // Don't show if dismissed recently
            if (tapToLogDismissed) return;
            
            // Don't show during onboarding
            if (document.getElementById('setup-container')?.classList.contains('active')) return;
            
            // Don't show if no game was launched from Game Shelf
            // We need to know WHICH game to avoid false prompts
            if (!lastLaunchedGame || !lastLaunchTime) {
                console.log('ðŸ“‹ iOS: No lastLaunchedGame or lastLaunchTime, skipping tap-to-log');
                return;
            }
            
            // v1.2.3: Game-aware time thresholds
            const elapsed = Date.now() - lastLaunchTime;
            const isQuickGame = QUICK_GAMES.includes(lastLaunchedGame);
            const minTimeMs = isQuickGame ? 20000 : 30000; // 20s for quick games, 30s for others
            
            if (elapsed < minTimeMs) {
                console.log(`ðŸ“‹ iOS: Only away ${Math.round(elapsed/1000)}s, skipping tap-to-log (need ${minTimeMs/1000}s+ for ${isQuickGame ? 'quick' : 'regular'} game)`);
                return;
            }
            
            // Check if already logged today
            const todayHistory = getTodayHistory();
            if (todayHistory[lastLaunchedGame]) {
                console.log(`ðŸ“‹ iOS: ${lastLaunchedGame} already logged today`);
                clearActiveGame();
                return;
            }
            
            // v1.2.3: Check dismiss time decay - if dismissed >2 hours ago, allow showing again
            if (returnPromptDismissedFor === lastLaunchedGame && returnPromptDismissedAt) {
                const hoursSinceDismiss = (Date.now() - returnPromptDismissedAt) / 3600000;
                if (hoursSinceDismiss < 2) {
                    console.log(`ðŸ“‹ iOS: Recently dismissed for ${lastLaunchedGame} (${hoursSinceDismiss.toFixed(1)}h ago), skipping`);
                    return;
                } else {
                    console.log(`ðŸ“‹ iOS: Dismiss for ${lastLaunchedGame} has decayed (${hoursSinceDismiss.toFixed(1)}h ago), allowing`);
                }
            }
            
            const card = document.getElementById('tap-to-log-card');
            if (!card) return;
            
            const game = GAMES[lastLaunchedGame];
            if (game) {
                document.getElementById('tap-to-log-icon').textContent = game.icon;
                document.getElementById('tap-to-log-title').textContent = `Log ${game.name}?`;
                card.style.display = 'block';
                console.log(`ðŸ“‹ iOS: Showing tap-to-log for ${game.name} (away ${Math.round(elapsed/1000)}s)`);
            }
        }
        
        // Enhanced tap handler that checks clipboard diff
        async function tapToLogClipboardWithDiff() {
            try {
                if (!navigator.clipboard || !navigator.clipboard.readText) {
                    hideTapToLogCard();
                    openLogSheet();
                    return;
                }
                
                const currentClipboard = await navigator.clipboard.readText();
                console.log('ðŸ“‹ Tap: Current clipboard', currentClipboard ? currentClipboard.substring(0, 50) + '...' : '(empty)');
                
                // Check if this clipboard was already processed (logged earlier)
                if (lastProcessedClipboard && currentClipboard === lastProcessedClipboard) {
                    hideTapToLogCard();
                    showToast('No new game results found', 'info');
                    console.log('ðŸ“‹ Tap: Clipboard already processed, skipping');
                    return;
                }
                
                // Check if clipboard changed since we left
                // v1.2.3: More flexible handling - allow logging detected game even if different
                let shouldProceed = false;
                const parsedResult = parseShareText(currentClipboard);
                
                if (clipboardOnLeave === CLIPBOARD_UNKNOWN) {
                    // We couldn't capture on leave - allow if we found ANY valid game result
                    if (parsedResult) {
                        shouldProceed = true;
                        if (parsedResult.gameId === lastLaunchedGame) {
                            console.log('ðŸ“‹ Tap: UNKNOWN state, found matching result');
                        } else {
                            console.log(`ðŸ“‹ Tap: UNKNOWN state, found different game (${parsedResult.gameId} vs launched ${lastLaunchedGame})`);
                        }
                    } else {
                        hideTapToLogCard();
                        showToast('No game results found in clipboard', 'info');
                        console.log('ðŸ“‹ Tap: UNKNOWN state, no valid result');
                        return;
                    }
                } else if (clipboardOnLeave !== currentClipboard) {
                    shouldProceed = true;
                    console.log('ðŸ“‹ Tap: Clipboard changed');
                } else {
                    // Clipboard hasn't changed - user didn't copy anything new
                    hideTapToLogCard();
                    showToast('No new game results found', 'info');
                    console.log('ðŸ“‹ Tap: Clipboard unchanged');
                    return;
                }
                
                // Try to parse (may already have parsed above)
                const result = parsedResult || parseShareText(currentClipboard);
                
                if (result) {
                    const todayHistory = getTodayHistory();
                    const game = GAMES[result.gameId];
                    
                    if (todayHistory[result.gameId]) {
                        hideTapToLogCard();
                        renderAll();
                        showToast(`${game?.icon || 'ðŸŽ®'} ${game?.name || 'Game'} already logged today!`, 'info');
                        return;
                    }
                    
                    // v1.2.3: If result is for different game than launched, show which game we're logging
                    const isMatchingGame = result.gameId === lastLaunchedGame;
                    if (!isMatchingGame && lastLaunchedGame) {
                        const launchedGame = GAMES[lastLaunchedGame];
                        console.log(`ðŸ“‹ Tap: Logging ${game?.name} (launched ${launchedGame?.name})`);
                    }
                    
                    // Log it!
                    if (logGame(result, 'prompt')) {
                        // Mark this clipboard as processed
                        lastProcessedClipboard = currentClipboard;
                        console.log('ðŸ“‹ Tap: Marked clipboard as processed');
                        
                        hideTapToLogCard();
                        renderAll();
                        showCelebration(game, result);
                        clearActiveGame();
                    }
                } else {
                    // Has content but not a game result - open manual log
                    hideTapToLogCard();
                    openLogSheet();
                    showToast('Paste your game results', 'info');
                }
            } catch (e) {
                console.log('ðŸ“‹ Tap: Clipboard access denied:', e);
                hideTapToLogCard();
                openLogSheet();
            }
        }
        
        // Check clipboard on app init - catches "copy then open app" flow
        // Only runs once when app loads, not on every return
        let hasCheckedClipboardOnInit = false;
        async function checkClipboardOnInit() {
            if (hasCheckedClipboardOnInit) return;
            hasCheckedClipboardOnInit = true;
            
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            
            // On iOS, can't read clipboard without gesture
            if (isIOS) {
                console.log('ðŸ“‹ Init (iOS): Skipping auto-check, will use tap-to-log');
                return;
            }
            
            try {
                if (!navigator.clipboard || !navigator.clipboard.readText) return;
                
                const text = await navigator.clipboard.readText();
                const result = parseShareText(text);
                
                if (!result) {
                    console.log('ðŸ“‹ Init: No game result in clipboard');
                    return;
                }
                
                // Check if already logged today
                const todayHistory = getTodayHistory();
                if (todayHistory[result.gameId]) {
                    console.log(`ðŸ“‹ Init: ${result.gameId} already logged today`);
                    return;
                }
                
                const game = GAMES[result.gameId];
                detectedClipboard = { text, result };
                
                console.log(`ðŸ“‹ Init: Found unlogged game result for ${game?.name || result.gameId}`);
                
                // Auto-log if enabled, otherwise show prompt
                if (appData.settings?.autoLog !== false) {
                    autoLogClipboard(game, result);
                } else {
                    showClipboardPrompt(game, result);
                }
            } catch (e) {
                console.log('ðŸ“‹ Init: Clipboard check failed:', e.message);
            }
        }
        
        // Clipboard++ Mode - Continuous monitoring (non-iOS only)
        function startClipboardMonitor() {
            // iOS shows paste popup on every read - don't use continuous monitoring
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            if (isIOS) {
                console.log('ðŸ“‹ Clipboard++ mode skipped (iOS)');
                return;
            }
            
            if (clipboardPlusInterval) return; // Already running
            
            console.log('ðŸ“‹ Clipboard++ mode started');
            
            clipboardPlusInterval = setInterval(async () => {
                if (document.visibilityState !== 'visible') return;
                
                try {
                    if (!navigator.clipboard || !navigator.clipboard.readText) return;
                    
                    const text = await navigator.clipboard.readText();
                    
                    // Skip if same as last check
                    if (text === lastClipboardContent) return;
                    lastClipboardContent = text;
                    
                    // Try to parse
                    const result = parseShareText(text);
                    if (result) {
                        const todayHistory = getTodayHistory();
                        if (todayHistory[result.gameId]) return; // Already logged
                        
                        const game = GAMES[result.gameId];
                        detectedClipboard = { text, result };
                        
                        // Dismiss return prompt if showing for same game
                        if (lastLaunchedGame === result.gameId) {
                            dismissReturnPrompt();
                        }
                        
                        // AUTO-LOG MODE: If enabled, log automatically without prompt
                        if (appData.settings?.autoLog !== false) {
                            autoLogClipboard(game, result);
                        } else {
                            // Fallback to old prompt behavior
                            showClipboardPrompt(game, result);
                        }
                        
                        // Clear the launch tracking since we detected via clipboard
                        clearActiveGame();
                    }
                } catch (e) {
                    // Clipboard access denied - that's fine
                }
            }, 3000); // Check every 3 seconds (faster for better UX)
            
            // Show badge briefly
            showClipboardBadge();
        }
        
        // NEW: Auto-log detected clipboard content without user interaction
        function autoLogClipboard(game, result) {
            if (logGame(result, 'auto')) {
                // Store for potential undo
                lastAutoLoggedResult = { game, result, timestamp: Date.now() };
                
                // Mark this clipboard content as processed so we don't prompt again
                if (detectedClipboard?.text) {
                    lastProcessedClipboard = detectedClipboard.text;
                    console.log('ðŸ“‹ Marked clipboard as processed');
                }
                
                // Hide tap-to-log card if showing
                hideTapToLogCard();
                
                // Show BIG celebration (not subtle toast)
                showCelebration(game, result);
                
                // Update UI
                renderAll();
                
                // Clear detected clipboard to prevent re-prompting
                detectedClipboard = null;
                
                console.log(`âœ… Auto-logged: ${game.name} - ${result.score}`);
            }
        }
        
        // NEW: Show auto-log success toast (non-blocking, auto-dismiss)
        function showAutoLogToast(game, result) {
            const stats = appData.stats[result.gameId] || {};
            const streak = stats.currentStreak || 1;
            
            // Build toast message
            let message = `âœ“ ${game.name} logged! ${result.score}`;
            if (streak > 1) {
                message += ` ðŸ”¥ ${streak} day streak`;
            }
            
            // Play success sound
            playSound('complete');
            
            // Show toast with undo action
            showToastWithUndo(message, result.gameId);
        }
        
        // NEW: Toast with undo functionality
        function showToastWithUndo(message, gameId) {
            // Remove any existing undo toast
            const existingToast = document.querySelector('.auto-log-toast');
            if (existingToast) existingToast.remove();
            
            const toast = document.createElement('div');
            toast.className = 'auto-log-toast';
            toast.innerHTML = `
                <span class="toast-message">${message}</span>
                <button class="toast-undo" onclick="undoAutoLog('${gameId}')">Undo</button>
            `;
            
            // Add styles inline for toast
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, #22c55e, #16a34a);
                color: white;
                padding: 12px 20px;
                border-radius: 12px;
                display: flex;
                align-items: center;
                gap: 16px;
                z-index: 10001;
                font-size: 0.95rem;
                font-weight: 500;
                box-shadow: 0 4px 20px rgba(34, 197, 94, 0.4);
                animation: slideDown 0.3s ease;
                max-width: calc(100% - 40px);
            `;
            
            const undoBtn = toast.querySelector('.toast-undo');
            undoBtn.style.cssText = `
                background: rgba(255,255,255,0.2);
                border: none;
                color: white;
                padding: 6px 12px;
                border-radius: 6px;
                font-size: 0.85rem;
                cursor: pointer;
                font-weight: 500;
            `;
            
            document.body.appendChild(toast);
            
            // Auto-dismiss after 4 seconds
            setTimeout(() => {
                if (toast.parentElement) {
                    toast.style.animation = 'slideUp 0.3s ease';
                    setTimeout(() => toast.remove(), 300);
                }
            }, 4000);
        }
        
        // NEW: Undo the last auto-logged game
        function undoAutoLog(gameId) {
            const today = getTodayString();
            if (appData.history[today]?.[gameId]) {
                delete appData.history[today][gameId];
                
                // Also revert stats if possible
                if (appData.stats[gameId]) {
                    appData.stats[gameId].gamesPlayed = Math.max(0, (appData.stats[gameId].gamesPlayed || 1) - 1);
                    // Note: streak reversion is complex, skip for now
                }
                
                saveData();
                renderAll();
                
                // Remove undo toast
                const toast = document.querySelector('.auto-log-toast');
                if (toast) toast.remove();
                
                // Show confirmation
                showToast('Log removed', 'info');
                
                console.log(`â†©ï¸ Undo: removed ${gameId} log`);
            }
        }
        
        // Track last auto-logged for undo
        let lastAutoLoggedResult = null;
        
        function stopClipboardMonitor() {
            if (clipboardPlusInterval) {
                clearInterval(clipboardPlusInterval);
                clipboardPlusInterval = null;
                console.log('ðŸ“‹ Clipboard++ mode stopped');
            }
            hideClipboardBadge();
        }
        
        function showClipboardBadge() {
            const badge = document.getElementById('clipboard-badge');
            if (badge) {
                badge.classList.add('active');
                // Auto-hide after 3 seconds
                setTimeout(() => hideClipboardBadge(), 3000);
            }
        }
        
        function hideClipboardBadge() {
            const badge = document.getElementById('clipboard-badge');
            if (badge) {
                badge.classList.remove('active');
            }
        }
        
        // Quick Capture Sheet
        function openQuickCapture() {
            renderQuickCaptureGrid();
            document.getElementById('quick-capture-sheet').classList.add('active');
        }
        
        function closeQuickCapture() {
            document.getElementById('quick-capture-sheet').classList.remove('active');
        }
        
        function renderQuickCaptureGrid() {
            const container = document.getElementById('quick-capture-grid');
            const todayHistory = getTodayHistory();
            
            // Show user's shelf games (up to 12)
            const shelfGames = appData.games.slice(0, 12);
            
            container.innerHTML = shelfGames.map(g => {
                const game = GAMES[g.id];
                if (!game) return '';
                const done = todayHistory[g.id];
                
                return `
                    <div class="quick-capture-btn ${done ? 'done' : ''}" 
                         onclick="${done ? `showToast('${game.name} already logged!')` : `quickCaptureGame('${g.id}')`}">
                        <span class="quick-capture-icon">${game.icon}</span>
                        <span class="quick-capture-name">${game.name}</span>
                        ${done ? '<span class="quick-capture-status">âœ“ Done</span>' : ''}
                    </div>
                `;
            }).join('');
        }
        
        function quickCaptureGame(gameId) {
            const game = GAMES[gameId];
            if (!game) return;
            
            // Log with generic result
            const result = {
                gameId: gameId,
                score: 'âœ“',
                won: true,
                raw: 'Quick capture'
            };
            
            if (logGame(result, 'quick-log')) {
                closeQuickCapture();
                renderAll();
                SoundManager.play('success');
                showToast(`${game.icon} ${game.name} logged!`, 'success');
            }
        }
        
        // ============ INTERACTIONS ============
        function addToShelf(gameId) {
            if (appData.games.find(g => g.id === gameId)) {
                showToast('Already on your shelf!');
                return;
            }
            
            // Remember which categories are expanded BEFORE re-rendering
            const expandedCats = [];
            document.querySelectorAll('.game-category-content.expanded').forEach(el => {
                const catId = el.id.replace('cat-content-', '');
                expandedCats.push(catId);
            });
            
            appData.games.push({ id: gameId, addedAt: new Date().toISOString() });
            saveData();
            syncToCloud();
            renderAll();
            
            // Restore expanded categories AFTER renderAll's requestAnimationFrame completes
            // Use double requestAnimationFrame to ensure DOM is fully updated
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    expandedCats.forEach(catId => {
                        const header = document.getElementById('cat-header-' + catId);
                        const content = document.getElementById('cat-content-' + catId);
                        if (header) header.classList.add('expanded');
                        if (content) content.classList.add('expanded');
                    });
                });
            });
            
            showToast(`${GAMES[gameId].name} added!`, 'success');
        }
        
        // v1.3.0: Remove game from shelf
        function removeFromShelf(gameId) {
            const game = GAMES[gameId];
            if (!game) return;
            
            const index = appData.games.findIndex(g => g.id === gameId);
            if (index === -1) {
                showToast('Game not on your shelf');
                return;
            }
            
            // Show confirmation
            showConfirmModal({
                icon: game.icon,
                title: `Remove ${game.name}?`,
                message: 'This will remove the game from your shelf. Your stats and history will be kept.',
                confirmText: 'Remove',
                confirmStyle: 'danger',
                onConfirm: () => {
                    appData.games.splice(index, 1);
                    saveData();
                    syncToCloud();
                    renderAll();
                    showToast(`${game.name} removed from shelf`, 'info');
                }
            });
        }
        
        // v1.3.0: Show game options (long-press menu)
        function showGameOptions(gameId) {
            const game = GAMES[gameId];
            if (!game) return;
            
            const todayHistory = getTodayHistory();
            const done = todayHistory[gameId];
            const stats = appData.stats[gameId] || {};
            const isOnShelf = appData.games.some(g => g.id === gameId);
            
            showGenericSheet({
                title: `${game.icon} ${game.name}`,
                content: `
                    <div style="padding: 16px;">
                        ${done ? `
                            <div style="background: var(--accent-green); color: white; padding: 10px; border-radius: 8px; text-align: center; margin-bottom: 16px; font-size: 0.9rem;">
                                âœ“ Played today: ${done.score}
                            </div>
                        ` : ''}
                        
                        <div style="display: flex; flex-direction: column; gap: 10px;">
                            <button onclick="closeGenericSheet(); playGame('${gameId}')" style="
                                width: 100%; padding: 14px; background: var(--accent-purple); border: none;
                                border-radius: 10px; color: white; font-size: 1rem; font-weight: 600; cursor: pointer;
                                display: flex; align-items: center; justify-content: center; gap: 8px;
                            ">
                                <span>ðŸŽ®</span> ${done ? 'Play Again' : 'Play Now'}
                            </button>
                            
                            <button onclick="closeGenericSheet(); showGameStatsDetail('${gameId}')" style="
                                width: 100%; padding: 14px; background: var(--bg-tertiary); border: 1px solid var(--border);
                                border-radius: 10px; color: var(--text-primary); font-size: 1rem; cursor: pointer;
                                display: flex; align-items: center; justify-content: center; gap: 8px;
                            ">
                                <span>ðŸ“Š</span> View Stats
                            </button>
                            
                            ${isOnShelf ? `
                                <button onclick="closeGenericSheet(); removeFromShelf('${gameId}')" style="
                                    width: 100%; padding: 14px; background: var(--bg-tertiary); border: 1px solid var(--accent-red);
                                    border-radius: 10px; color: var(--accent-red); font-size: 1rem; cursor: pointer;
                                    display: flex; align-items: center; justify-content: center; gap: 8px;
                                ">
                                    <span>ðŸ—‘ï¸</span> Remove from Shelf
                                </button>
                            ` : ''}
                        </div>
                    </div>
                `
            });
        }
        
        // v1.3.0: Long-press detection for game cards
        // v1.3.1: Added visual feedback during long-press
        let longPressTimer = null;
        let longPressTarget = null;
        let longPressElement = null;
        
        function setupLongPress(element, gameId) {
            element.addEventListener('touchstart', (e) => {
                longPressTarget = gameId;
                longPressElement = element;
                
                // v1.3.1: Add visual feedback after brief delay (150ms)
                setTimeout(() => {
                    if (longPressTimer && longPressElement === element) {
                        element.classList.add('long-pressing');
                    }
                }, 150);
                
                longPressTimer = setTimeout(() => {
                    element.classList.remove('long-pressing');
                    e.preventDefault();
                    showGameOptions(gameId);
                    longPressTarget = null;
                    longPressElement = null;
                }, 500);
            }, { passive: false });
            
            element.addEventListener('touchend', () => {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                element.classList.remove('long-pressing');
                longPressElement = null;
            });
            
            element.addEventListener('touchmove', () => {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                element.classList.remove('long-pressing');
                longPressElement = null;
            });
            
            // Also support right-click on desktop
            element.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showGameOptions(gameId);
            });
        }
        
        function switchTab(tab) {
            document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.nav-tab[data-tab="${tab}"]`).classList.add('active');
            
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('screen-' + tab).classList.add('active');
            
            // Populate Share screen when selected
            if (tab === 'share') {
                populateShareScreen();
            }
            
            // Populate Stats screen when selected
            if (tab === 'stats') {
                renderStatsScreen();
            }
        }
        
        // ============ LOG SHEET ============
        function openLogSheet() {
            // v1.2.7.6: Clear any previous content for fresh start
            const input = document.getElementById('log-input');
            if (input) input.value = '';
            const preview = document.getElementById('parse-preview');
            if (preview) preview.classList.remove('visible');
            const logBtn = document.getElementById('log-btn');
            if (logBtn) {
                logBtn.disabled = false;
                logBtn.textContent = 'Log Game';
            }
            const bulkBtn = document.getElementById('bulk-log-btn');
            if (bulkBtn) bulkBtn.style.display = 'none';
            
            // v1.2.7.6: Show tap-to-paste button (for iOS especially)
            showTapToPasteButton();
            
            document.getElementById('log-sheet').classList.add('active');
            // Reset to paste tab
            switchLogTab('paste');
            renderQuickLogButtons();
            
            // v1.2.7.6: Auto-paste clipboard if it contains a game result
            // (skipped on iOS due to permission popup - they use tap-to-paste button)
            autoPasteClipboard();
            
            document.getElementById('log-input').focus();
        }
        
        // v1.2.7.6: Auto-paste clipboard content into log sheet
        // Skip on iOS - it shows a disruptive permission popup
        // Skip if game already logged - avoids confusing "Already Logged" message
        async function autoPasteClipboard() {
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            if (isIOS) {
                console.log('ðŸ“‹ Skipping auto-paste on iOS (use tap-to-paste button)');
                return;
            }
            
            try {
                if (!navigator.clipboard || !navigator.clipboard.readText) return;
                
                const text = await navigator.clipboard.readText();
                if (!text) return;
                
                const result = parseShareText(text);
                if (result) {
                    // Don't auto-paste if already logged today
                    const todayHistory = getTodayHistory();
                    if (todayHistory[result.gameId]) {
                        console.log('ðŸ“‹ Skipping auto-paste - game already logged');
                        return;
                    }
                    
                    const input = document.getElementById('log-input');
                    input.value = text;
                    parseLogInput(); // Show preview
                    hideTapToPasteButton(); // Hide button after successful paste
                    console.log('ðŸ“‹ Auto-pasted clipboard content');
                }
            } catch (e) {
                // Clipboard access denied - user will paste manually
                console.log('ðŸ“‹ Could not auto-paste:', e.message);
            }
        }
        
        // v1.2.7.6: User-initiated paste for iOS - shows native paste permission naturally
        async function tapToPaste() {
            const btn = document.getElementById('tap-to-paste-btn');
            
            try {
                if (!navigator.clipboard || !navigator.clipboard.readText) {
                    showToast('Clipboard not available', 'error');
                    return;
                }
                
                const text = await navigator.clipboard.readText();
                
                if (!text) {
                    showToast('Clipboard is empty', 'info');
                    return;
                }
                
                const input = document.getElementById('log-input');
                input.value = text;
                parseLogInput(); // Show preview
                
                // Check if we detected a game
                const result = parseShareText(text);
                if (result) {
                    hideTapToPasteButton();
                    console.log('ðŸ“‹ Pasted from clipboard:', result.gameId);
                } else {
                    showToast('Pasted - but no game detected', 'info');
                }
            } catch (e) {
                // User denied clipboard access or other error
                console.log('ðŸ“‹ Paste failed:', e.message);
                showToast('Could not access clipboard', 'error');
            }
        }
        
        function hideTapToPasteButton() {
            const btn = document.getElementById('tap-to-paste-btn');
            if (btn) btn.style.display = 'none';
        }
        
        function showTapToPasteButton() {
            const btn = document.getElementById('tap-to-paste-btn');
            if (btn) btn.style.display = 'flex';
        }
        
        // ============ STREAMLINED RECORD GAME (v1.2.47) ============
        // Single-button clipboard capture with auto-detection
        // Phase 2: Supports both share text AND stats screenshots via OCR
        
        let ocrWorker = null; // Tesseract worker instance
        
        async function handleRecordGame() {
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            
            try {
                // Try the modern clipboard API first (supports images)
                if (navigator.clipboard && navigator.clipboard.read) {
                    try {
                        const clipboardItems = await navigator.clipboard.read();
                        
                        for (const item of clipboardItems) {
                            // Check for image first
                            if (item.types.includes('image/png') || item.types.includes('image/jpeg')) {
                                const imageType = item.types.find(t => t.startsWith('image/'));
                                const blob = await item.getType(imageType);
                                showToast('ðŸ“· Reading screenshot...', 'info');
                                await processScreenshot(blob);
                                return;
                            }
                            
                            // Check for text
                            if (item.types.includes('text/plain')) {
                                const blob = await item.getType('text/plain');
                                const text = await blob.text();
                                if (text && text.trim().length > 0) {
                                    await processShareText(text);
                                    return;
                                }
                            }
                        }
                        
                        // No usable content found
                        showToast('ðŸ“‹ Nothing to paste - copy results or screenshot', 'info');
                        return;
                        
                    } catch (readErr) {
                        // clipboard.read() failed
                        // On iOS, user already saw paste popup, don't trigger another with readText
                        if (isIOS) {
                            console.log('clipboard.read() failed on iOS, not retrying:', readErr.message);
                            // v1.2.77: Don't show error toast - clipboard often succeeds via other paths
                            // Just silently open log sheet after delay (user can manual log if needed)
                            setTimeout(() => {
                                // Only open log sheet if game wasn't already logged
                                if (!getTodayHistory()[lastLaunchedGame]) {
                                    openLogSheet();
                                }
                            }, 800);
                            return;
                        }
                        console.log('clipboard.read() failed, trying readText:', readErr.message);
                    }
                }
                
                // Fallback to text-only clipboard (non-iOS only, or if read() not supported)
                if (navigator.clipboard && navigator.clipboard.readText) {
                    const text = await navigator.clipboard.readText();
                    if (text && text.trim().length > 0) {
                        await processShareText(text);
                        return;
                    }
                    // v1.3.1: Consistent message with clipboard.read() path
                    showToast('ðŸ“‹ Nothing to paste - copy results or screenshot', 'info');
                    return;
                }
                
                // No clipboard API available
                openLogSheet();
                
            } catch (e) {
                console.log('ðŸ“‹ Record game error:', e.message);
                if (e.name === 'NotAllowedError') {
                    showToast('ðŸ“‹ Clipboard access denied', 'error');
                } else {
                    showToast('ðŸ“‹ Could not read clipboard', 'error');
                }
                setTimeout(() => openLogSheet(), 800);
            }
        }
        
        // Process share text from clipboard
        async function processShareText(text) {
            const results = parseMultipleGames(text);
            
            if (results.length === 0) {
                // v1.3.1: More helpful message when content isn't recognized
                showToast('â“ Not a game result - try copying share text', 'info');
                setTimeout(() => openLogSheet(), 500);
                return;
            }
            
            const todayHistory = getTodayHistory();
            const outcomes = [];
            
            for (const result of results) {
                const gameInfo = GAMES[result.gameId];
                const existing = todayHistory[result.gameId];
                
                if (existing) {
                    if (existing.score === result.score) {
                        outcomes.push({ gameId: result.gameId, action: 'skip', reason: 'duplicate' });
                    } else {
                        outcomes.push({ 
                            gameId: result.gameId, 
                            action: 'conflict', 
                            existing: existing.score, 
                            new: result.score,
                            result: result
                        });
                    }
                } else {
                    if (logGame(result, 'record-game')) {
                        outcomes.push({ 
                            gameId: result.gameId, 
                            action: 'logged', 
                            score: result.score,
                            icon: gameInfo?.icon || 'ðŸŽ®',
                            name: gameInfo?.name || result.gameId
                        });
                    }
                }
            }
            
            // Handle conflicts
            const conflicts = outcomes.filter(o => o.action === 'conflict');
            if (conflicts.length > 0) {
                showScoreConflictModal(conflicts[0]);
                return;
            }
            
            // Show summary
            const logged = outcomes.filter(o => o.action === 'logged');
            const skipped = outcomes.filter(o => o.action === 'skip');
            
            if (logged.length === 1) {
                const g = logged[0];
                showToast(`âœ“ ${g.icon} ${g.name} ${g.score}`, 'success');
                renderAll();
            } else if (logged.length > 1) {
                showToast(`âœ“ ${logged.length} games logged`, 'success');
                renderAll();
            } else if (skipped.length > 0) {
                showToast('âœ“ Already recorded', 'info');
            } else {
                showToast('No new results to log', 'info');
            }
        }
        
        // ============ PHASE 2: OCR STATS IMPORT ============
        
        // Process screenshot from clipboard
        async function processScreenshot(blob) {
            try {
                // Initialize Tesseract worker if needed
                if (!ocrWorker) {
                    showToast('ðŸ”„ Loading OCR engine...', 'info');
                    ocrWorker = await Tesseract.createWorker('eng');
                }
                
                // Run OCR
                const imageUrl = URL.createObjectURL(blob);
                const { data } = await ocrWorker.recognize(imageUrl);
                URL.revokeObjectURL(imageUrl);
                
                const ocrText = data.text;
                console.log('ðŸ“· OCR Result:', ocrText);
                
                if (!ocrText || ocrText.trim().length < 10) {
                    showToast('ðŸ“· Couldn\'t read text from image', 'error');
                    return;
                }
                
                // Try to parse as stats
                const stats = parseStatsFromOCR(ocrText);
                
                if (stats) {
                    await processStatsImport(stats);
                    return;
                }
                
                // Maybe it's a share result screenshot? Try game parsers
                const results = parseMultipleGames(ocrText);
                if (results.length > 0) {
                    await processShareText(ocrText);
                    return;
                }
                
                showToast('ðŸ“· Couldn\'t recognize stats or results', 'info');
                console.log('OCR text that failed to parse:', ocrText);
                
            } catch (e) {
                console.error('OCR error:', e);
                showToast('ðŸ“· Error reading screenshot', 'error');
            }
        }
        
        // Parse stats from OCR text
        function parseStatsFromOCR(text) {
            // Normalize whitespace
            const normalized = text.replace(/\s+/g, ' ').trim();
            const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 0);
            
            console.log('ðŸ“Š Parsing stats from:', normalized.substring(0, 200));
            
            // Detect game type by keywords
            let gameType = null;
            
            if (/GUESS\s*DISTRIBUTION/i.test(normalized) || 
                (/Statistics/i.test(normalized) && /Played/i.test(normalized) && /Streak/i.test(normalized) && !/(MISTAKE|Perfect\s*Puzzles)/i.test(normalized))) {
                gameType = 'wordle';
            } else if (/MISTAKE\s*DISTRIBUTION/i.test(normalized) || /Perfect\s*Puzzles/i.test(normalized)) {
                gameType = 'connections';
            } else if (/Tango\s*#?\d+/i.test(normalized)) {
                gameType = 'tango';
            } else if (/Queens\s*#?\d+/i.test(normalized)) {
                gameType = 'queens';
            } else if (/Pinpoint\s*#?\d+/i.test(normalized)) {
                gameType = 'pinpoint';
            } else if (/Crossclimb\s*#?\d+/i.test(normalized)) {
                gameType = 'crossclimb';
            }
            
            if (!gameType) {
                console.log('ðŸ“Š Could not identify game type from OCR');
                return null;
            }
            
            console.log('ðŸ“Š Detected game type:', gameType);
            
            // Extract numbers - look for the stats row pattern
            // Stats pages typically have: [large number] [percentage] [streak] [max streak]
            // Often with labels below: Played/Completed, Win %, Current Streak, Max Streak
            
            // Find all numbers in the text
            const allNumbers = normalized.match(/\d+/g)?.map(n => parseInt(n)) || [];
            console.log('ðŸ“Š Found numbers:', allNumbers);
            
            // Try to find the 4-stat pattern
            // Look for sequences like: "1361 98 14 115" or similar
            let stats = null;
            
            // Method 1: Look for labeled values
            const playedMatch = normalized.match(/(\d{1,5})\s*(?:Played|Completed|Plays)/i);
            const winMatch = normalized.match(/(\d{1,3})\s*(?:Win\s*%|%)/i);
            const currentStreakMatch = normalized.match(/(\d{1,4})\s*(?:Current|Day)?\s*Streak/i) || 
                                       normalized.match(/Current\s*Streak\s*(\d{1,4})/i);
            const maxStreakMatch = normalized.match(/(\d{1,4})\s*Max\s*(?:Streak)?/i) ||
                                   normalized.match(/Max\s*(?:Streak)?\s*(\d{1,4})/i);
            
            // Method 2: Look for 4 numbers in a row at the start (common stats layout)
            // Pattern: Stats pages often show 4 numbers on one line
            const fourNumberPattern = normalized.match(/(\d{1,5})\s+(\d{1,3})\s+(\d{1,4})\s+(\d{1,4})/);
            
            if (playedMatch || currentStreakMatch) {
                stats = {
                    type: 'stats',
                    game: gameType,
                    gamesPlayed: playedMatch ? parseInt(playedMatch[1]) : null,
                    winPercent: winMatch ? parseInt(winMatch[1]) : null,
                    currentStreak: currentStreakMatch ? parseInt(currentStreakMatch[1]) : null,
                    maxStreak: maxStreakMatch ? parseInt(maxStreakMatch[1]) : null
                };
            } else if (fourNumberPattern) {
                stats = {
                    type: 'stats',
                    game: gameType,
                    gamesPlayed: parseInt(fourNumberPattern[1]),
                    winPercent: parseInt(fourNumberPattern[2]),
                    currentStreak: parseInt(fourNumberPattern[3]),
                    maxStreak: parseInt(fourNumberPattern[4])
                };
            }
            
            // Validate - at minimum need game and current streak
            if (stats && stats.currentStreak !== null) {
                console.log('ðŸ“Š Parsed stats:', stats);
                return stats;
            }
            
            // Fallback: Try to find just streak numbers
            const streakOnly = normalized.match(/(\d{1,4})\s*(?:day)?\s*(?:win\s*)?streak/i);
            if (streakOnly) {
                return {
                    type: 'stats',
                    game: gameType,
                    gamesPlayed: null,
                    winPercent: null,
                    currentStreak: parseInt(streakOnly[1]),
                    maxStreak: null
                };
            }
            
            console.log('ðŸ“Š Could not extract stats values');
            return null;
        }
        
        // Process imported stats - compare with GS and update
        async function processStatsImport(stats) {
            const { game, currentStreak, maxStreak, gamesPlayed, winPercent } = stats;
            const gameInfo = GAMES[game];
            
            if (!gameInfo) {
                showToast(`â“ Unknown game: ${game}`, 'error');
                return;
            }
            
            // Check if game is tracked
            const isTracked = appData.games.some(g => g.id === game);
            if (!isTracked) {
                // Offer to add game with stats
                showAddGameWithStatsModal(stats);
                return;
            }
            
            // Get current GS stats
            const gsStats = appData.stats[game] || { currentStreak: 0, maxStreak: 0, gamesPlayed: 0 };
            const loggedToday = !!getTodayHistory()[game];
            
            console.log('ðŸ“Š Comparing stats:', { 
                gs: gsStats, 
                imported: stats, 
                loggedToday 
            });
            
            // Adjust GS streak for "just logged today" offset
            // If user logged today, their GS streak is 1 higher than what stats page would show
            // (because stats page was screenshot before today's play was reflected)
            const adjustedGSStreak = loggedToday ? gsStats.currentStreak - 1 : gsStats.currentStreak;
            
            // Compare current streaks
            if (currentStreak === null) {
                showToast('ðŸ“Š Couldn\'t read streak from screenshot', 'info');
                return;
            }
            
            let changes = [];
            
            // Current streak comparison
            if (currentStreak === adjustedGSStreak) {
                // Match!
                changes.push('streak matches');
            } else if (currentStreak > adjustedGSStreak) {
                // Stats show higher streak - auto-update
                const newStreak = loggedToday ? currentStreak + 1 : currentStreak;
                const oldStreak = gsStats.currentStreak;
                
                if (!appData.stats[game]) {
                    appData.stats[game] = { currentStreak: 0, maxStreak: 0, gamesPlayed: 0, gamesWon: 0 };
                }
                appData.stats[game].currentStreak = newStreak;
                changes.push(`streak ${oldStreak} â†’ ${newStreak}`);
            } else {
                // Stats show lower streak - need to ask user
                showStreakConflictModal({
                    game: game,
                    gameInfo: gameInfo,
                    gsStreak: gsStats.currentStreak,
                    statsStreak: currentStreak,
                    loggedToday: loggedToday
                });
                return;
            }
            
            // Max streak - always update if higher
            if (maxStreak !== null && maxStreak > (gsStats.maxStreak || 0)) {
                const oldMax = gsStats.maxStreak || 0;
                appData.stats[game].maxStreak = maxStreak;
                changes.push(`max ${oldMax} â†’ ${maxStreak}`);
            }
            
            // Games played - update if higher
            if (gamesPlayed !== null && gamesPlayed > (gsStats.gamesPlayed || 0)) {
                appData.stats[game].gamesPlayed = gamesPlayed;
            }
            
            // Win percent - can derive games won if we have played count
            if (winPercent !== null && gamesPlayed !== null) {
                const gamesWon = Math.round(gamesPlayed * winPercent / 100);
                if (gamesWon > (gsStats.gamesWon || 0)) {
                    appData.stats[game].gamesWon = gamesWon;
                }
            }
            
            saveData();
            syncToCloud();
            renderAll();
            
            // Show result
            if (changes.length > 0 && !changes.every(c => c === 'streak matches')) {
                showToast(`âœ“ ${gameInfo.icon} ${gameInfo.name}: ${changes.join(', ')}`, 'success');
            } else {
                showToast(`âœ“ ${gameInfo.icon} ${gameInfo.name} stats match!`, 'success');
            }
        }
        
        // Show modal when stats show lower streak than GS
        function showStreakConflictModal(data) {
            const modal = document.getElementById('streak-conflict-modal');
            if (!modal) {
                console.warn('Streak conflict modal not found');
                showToast(`${data.gameInfo.name}: streak mismatch (GS: ${data.gsStreak}, stats: ${data.statsStreak})`, 'info');
                return;
            }
            
            document.getElementById('streak-conflict-game-icon').textContent = data.gameInfo.icon;
            document.getElementById('streak-conflict-game-name').textContent = data.gameInfo.name;
            document.getElementById('streak-conflict-gs-value').textContent = data.gsStreak;
            document.getElementById('streak-conflict-stats-value').textContent = data.statsStreak;
            
            modal.dataset.gameId = data.game;
            modal.dataset.newStreak = data.statsStreak;
            
            modal.classList.add('active');
        }
        
        function resolveStreakConflict(action) {
            const modal = document.getElementById('streak-conflict-modal');
            if (!modal) return;
            
            const gameId = modal.dataset.gameId;
            const newStreak = parseInt(modal.dataset.newStreak);
            
            if (action === 'reset') {
                if (!appData.stats[gameId]) {
                    appData.stats[gameId] = { currentStreak: 0, maxStreak: 0, gamesPlayed: 0, gamesWon: 0 };
                }
                appData.stats[gameId].currentStreak = newStreak;
                saveData();
                syncToCloud();
                renderAll();
                
                const gameInfo = GAMES[gameId];
                showToast(`âœ“ ${gameInfo?.icon} Streak reset to ${newStreak}`, 'success');
            } else {
                showToast('âœ“ Kept current streak', 'info');
            }
            
            modal.classList.remove('active');
        }
        
        // Show modal to add untracked game with stats
        function showAddGameWithStatsModal(stats) {
            const gameInfo = GAMES[stats.game];
            if (!gameInfo) return;
            
            // Simple confirm for now
            if (confirm(`Add ${gameInfo.name} to your shelf with imported stats?\n\nStreak: ${stats.currentStreak || '?'}\nMax: ${stats.maxStreak || '?'}\nPlayed: ${stats.gamesPlayed || '?'}`)) {
                // Add game to shelf
                if (!appData.games.find(g => g.id === stats.game)) {
                    appData.games.push({ id: stats.game, addedAt: new Date().toISOString() });
                }
                
                // Set stats
                appData.stats[stats.game] = {
                    currentStreak: stats.currentStreak || 0,
                    maxStreak: stats.maxStreak || 0,
                    gamesPlayed: stats.gamesPlayed || 0,
                    gamesWon: stats.winPercent && stats.gamesPlayed ? 
                        Math.round(stats.gamesPlayed * stats.winPercent / 100) : 0,
                    lastPlayed: null
                };
                
                saveData();
                syncToCloud();
                renderAll();
                
                showToast(`âœ“ Added ${gameInfo.icon} ${gameInfo.name} with stats!`, 'success');
            }
        }
        
        // Show conflict modal when logged score differs from clipboard
        function showScoreConflictModal(conflict) {
            const gameInfo = GAMES[conflict.gameId];
            const modal = document.getElementById('score-conflict-modal');
            if (!modal) {
                // Fallback if modal doesn't exist
                console.warn('Score conflict modal not found');
                showToast(`${gameInfo?.name}: already logged as ${conflict.existing}`, 'info');
                return;
            }
            
            document.getElementById('conflict-game-icon').textContent = gameInfo?.icon || 'ðŸŽ®';
            document.getElementById('conflict-game-name').textContent = gameInfo?.name || conflict.gameId;
            document.getElementById('conflict-old-score').textContent = conflict.existing;
            document.getElementById('conflict-new-score').textContent = conflict.new;
            
            // Store conflict data for resolution
            modal.dataset.gameId = conflict.gameId;
            modal.dataset.newScore = JSON.stringify(conflict.result);
            
            modal.classList.add('active');
        }
        
        function resolveScoreConflict(action) {
            const modal = document.getElementById('score-conflict-modal');
            if (!modal) return;
            
            if (action === 'replace') {
                const gameId = modal.dataset.gameId;
                const result = JSON.parse(modal.dataset.newScore);
                
                // Update today's history with new score
                const today = getTodayString();
                if (appData.history[today] && appData.history[today][gameId]) {
                    appData.history[today][gameId] = {
                        score: result.score,
                        won: result.won,
                        numericScore: result.numericScore || 0,
                        time: new Date().toISOString()
                    };
                    saveData();
                    syncToCloud();
                    renderAll();
                    
                    // v1.2.77: Update battle scores with the new score and meta
                    updateBattleScore(gameId, result.numericScore || 0, result);
                    
                    const gameInfo = GAMES[gameId];
                    showToast(`âœ“ Updated to ${result.score}`, 'success');
                }
            } else {
                showToast('âœ“ Kept original', 'info');
            }
            
            modal.classList.remove('active');
        }
        
        // Long-press handler for manual entry fallback
        let recordButtonTimer = null;
        let recordButtonHandled = false; // v1.2.77: Prevent double execution from touch+mouse
        
        function handleRecordButtonDown(e) {
            // v1.2.77: Prevent mouse events after touch events
            if (e && e.type === 'mousedown' && recordButtonHandled) {
                return;
            }
            
            recordButtonTimer = setTimeout(() => {
                openLogSheet();
                recordButtonTimer = null;
                recordButtonHandled = false;
            }, 600);
        }
        function handleRecordButtonUp(e) {
            // v1.2.77: Prevent mouse events after touch events  
            if (e && e.type === 'mouseup' && recordButtonHandled) {
                recordButtonHandled = false; // Reset for next interaction
                return;
            }
            
            if (recordButtonTimer) {
                clearTimeout(recordButtonTimer);
                recordButtonTimer = null;
                recordButtonHandled = true; // Mark as handled
                handleRecordGame();
                
                // v1.2.77: Reset after a delay to allow for next tap
                setTimeout(() => { recordButtonHandled = false; }, 500);
            }
        }
        
        function closeLogSheet(e) {
            if (e && e.target.id !== 'log-sheet') return;
            document.getElementById('log-sheet').classList.remove('active');
            document.getElementById('log-input').value = '';
            document.getElementById('parse-preview').classList.remove('visible');
            const quickOptions = document.getElementById('quick-log-options');
            if (quickOptions) quickOptions.style.display = 'none';
        }
        
        function switchLogTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.log-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.log-tab[onclick*="${tab}"]`)?.classList.add('active');
            
            // Show/hide content
            document.getElementById('log-tab-paste').style.display = tab === 'paste' ? 'block' : 'none';
            document.getElementById('log-tab-quick').style.display = tab === 'quick' ? 'block' : 'none';
            
            // Render quick log buttons when switching to quick tab
            if (tab === 'quick') {
                renderQuickLogButtons();
                const quickOptions = document.getElementById('quick-log-options');
                if (quickOptions) quickOptions.style.display = 'none';
            }
        }
        
        function parseLogInput() {
            const input = document.getElementById('log-input').value;
            const results = parseMultipleGames(input);
            const preview = document.getElementById('parse-preview');
            const todayHistory = getTodayHistory();
            const bulkBtn = document.getElementById('bulk-log-btn');
            
            if (results.length > 0) {
                const result = results[0];
                const game = GAMES[result.gameId];
                const alreadyLogged = !!todayHistory[result.gameId];
                
                let previewText = `${game?.icon || 'ðŸŽ®'} ${game?.name || result.gameId}`;
                if (results.length > 1) {
                    previewText += ` + ${results.length - 1} more`;
                }
                
                document.getElementById('parse-game-name').textContent = previewText;
                
                // v1.2.7.6: Show bulk button only when 2+ games detected
                if (bulkBtn) {
                    if (results.length > 1) {
                        const unlogged = results.filter(r => !todayHistory[r.gameId]).length;
                        bulkBtn.textContent = `Log All (${unlogged} games)`;
                        bulkBtn.style.display = unlogged > 0 ? 'block' : 'none';
                    } else {
                        bulkBtn.style.display = 'none';
                    }
                }
                
                // Show different message if already logged
                if (alreadyLogged) {
                    document.getElementById('parse-score').innerHTML = `
                        <span style="color: var(--accent-green);">âœ“ Already logged today!</span>
                        <div style="display: flex; gap: 8px; margin-top: 8px;">
                            <button onclick="showShareHub()" style="flex: 1; padding: 6px 10px; background: var(--accent-purple); border: none; border-radius: 6px; color: white; font-size: 0.85rem; cursor: pointer;">Share Instead</button>
                            <button onclick="adjustRecording('${result.gameId}')" style="flex: 1; padding: 6px 10px; background: var(--accent-orange); border: none; border-radius: 6px; color: white; font-size: 0.85rem; cursor: pointer;">Adjust</button>
                        </div>
                    `;
                    // Disable the log button
                    const logBtn = document.getElementById('log-btn');
                    if (logBtn) {
                        logBtn.disabled = true;
                        logBtn.textContent = 'Already Logged âœ“';
                    }
                } else {
                    document.getElementById('parse-score').textContent = `Score: ${result.score}`;
                    // Enable the log button
                    const logBtn = document.getElementById('log-btn');
                    if (logBtn) {
                        logBtn.disabled = false;
                        logBtn.textContent = 'Log Game';
                    }
                }
                
                preview.classList.add('visible');
            } else {
                preview.classList.remove('visible');
                // Reset log button
                const logBtn = document.getElementById('log-btn');
                if (logBtn) {
                    logBtn.disabled = false;
                    logBtn.textContent = 'Log Game';
                }
                // Hide bulk button
                if (bulkBtn) {
                    bulkBtn.style.display = 'none';
                }
            }
        }
        
        // v1.2.7.6: Remove a game's recording so user can re-log with correct info
        function adjustRecording(gameId) {
            const today = getTodayString();
            const game = GAMES[gameId];
            
            // Remove from history
            if (appData.history[today] && appData.history[today][gameId]) {
                delete appData.history[today][gameId];
                saveData();
                
                showToast(`${game?.icon || 'ðŸŽ®'} ${game?.name || gameId} removed - you can now re-log`, 'info');
                
                // Re-parse the input to update the UI
                parseLogInput();
                
                // Re-render quick log buttons
                renderQuickLogButtons();
            }
        }
        
        // v1.2.7.6: Called from "Already Played" modal - removes recording and opens log sheet
        function adjustRecordingFromModal(gameId) {
            const today = getTodayString();
            const game = GAMES[gameId];
            
            // Remove from history
            if (appData.history[today] && appData.history[today][gameId]) {
                delete appData.history[today][gameId];
                saveData();
                renderAll(); // Update UI to show game as unplayed
            }
            
            showToast(`${game?.icon || 'ðŸŽ®'} ${game?.name || gameId} removed - log your correct result`, 'info');
            
            // Open the log sheet so user can re-log
            openLogSheet();
        }
        
        function submitLog() {
            const input = document.getElementById('log-input').value;
            const result = parseShareText(input);
            
            if (!result) {
                showToast('Could not detect game. Try pasting share text.', 'error');
                return;
            }
            
            const game = GAMES[result.gameId];
            const todayHistory = getTodayHistory();
            
            if (todayHistory[result.gameId]) {
                showToast(`${game?.name || result.gameId} already logged today!`);
                closeLogSheet({ target: { id: 'log-sheet' } });
                renderAll(); // Ensure UI shows the logged game
                return;
            }
            
            if (logGame(result, 'manual')) {
                // v1.2.7.6: Mark clipboard as processed to prevent duplicate prompts
                lastProcessedClipboard = input;
                detectedClipboard = null;
                
                closeLogSheet({ target: { id: 'log-sheet' } });
                renderAll();
                
                // Use auto-log toast instead of modal when auto-log is enabled
                if (appData.settings?.autoLog !== false) {
                    showAutoLogToast(game, result);
                } else {
                    showSuccessModal(game, result);
                }
            }
        }
        
        // ============ CLIPBOARD DETECTION ============
        async function checkClipboard() {
            try {
                if (!navigator.clipboard || !navigator.clipboard.readText) return;
                
                const text = await navigator.clipboard.readText();
                const result = parseShareText(text);
                
                if (result) {
                    const todayHistory = getTodayHistory();
                    if (todayHistory[result.gameId]) return; // Already logged
                    
                    const game = GAMES[result.gameId];
                    detectedClipboard = { text, result };
                    
                    // AUTO-LOG: If enabled, log automatically
                    if (appData.settings?.autoLog !== false) {
                        autoLogClipboard(game, result);
                    } else {
                        showClipboardPrompt(game, result);
                    }
                }
            } catch (e) {
                // Clipboard access denied - that's fine
                console.log('Clipboard check:', e.message);
            }
        }
        
        function acceptClipboard() {
            if (detectedClipboard) {
                if (logGame(detectedClipboard.result, 'prompt')) {
                    const game = GAMES[detectedClipboard.result.gameId];
                    renderAll();
                    showToast(`${game?.icon || 'ðŸŽ®'} Logged!`, 'success');
                }
            }
            dismissClipboard();
        }
        
        function dismissClipboard() {
            const prompt = document.getElementById('clipboard-prompt');
            if (prompt) {
                prompt.style.display = 'none';
                prompt.classList.remove('visible');
            }
            detectedClipboard = null;
        }
        
        function showClipboardPrompt(game, result) {
            const prompt = document.getElementById('clipboard-prompt');
            if (!prompt) return;
            
            document.getElementById('prompt-icon').textContent = game?.icon || 'ðŸŽ®';
            document.getElementById('prompt-text').textContent = `Log ${game?.name || result.gameId} ${result.score}?`;
            
            prompt.style.display = 'flex';
            // Small delay to trigger CSS transition
            setTimeout(() => prompt.classList.add('visible'), 10);
            
            // Play notification sound and vibrate to alert user
            playSound('notification');
            if (navigator.vibrate) {
                navigator.vibrate([100, 50, 100]); // Short buzz pattern
            }
            
            // Auto-dismiss after 15 seconds (longer to give user time)
            setTimeout(() => {
                if (prompt.classList.contains('visible')) {
                    dismissClipboard();
                }
            }, 15000);
        }
        
        // ============ SUCCESS MODAL ============
        // Store last result for sharing
        let lastLoggedResult = null;
        let lastLoggedGame = null;
        
        // Store current battle for impact display
        let currentBattleImpact = null;
        
        function showSuccessModal(game, result) {
            const modal = document.getElementById('success-modal');
            const stats = appData.stats[result.gameId] || {};
            const streak = stats.currentStreak || 1;
            
            // Store for sharing
            lastLoggedResult = result;
            lastLoggedGame = game;
            
            // Play success sound
            playSound('complete');
            
            // Determine celebration emoji based on score
            let celebration = 'ðŸŽ‰';
            if (result.score?.includes('1/') || result.score === 'Perfect! ðŸŽ¯' || result.score === 'Queen Bee! ðŸ‘‘') {
                celebration = 'ðŸ†';
                playSound('achievement'); // Extra sound for perfect scores
            } else if (result.score?.includes('2/') || result.score === 'No hints!' || result.score === 'Genius!') {
                celebration = 'ðŸŒŸ';
            }
            
            document.getElementById('success-celebration').textContent = celebration;
            document.getElementById('success-icon').textContent = game?.icon || 'ðŸŽ®';
            document.getElementById('success-game').textContent = game?.name || result.gameId;
            document.getElementById('success-score').textContent = result.score;
            document.getElementById('success-points').textContent = `+${result.numericScore || 15} pts`;
            
            if (streak > 1) {
                document.getElementById('success-streak').textContent = `ðŸ”¥ ${streak} day streak!`;
                document.getElementById('success-streak').style.display = 'block';
                if (streak % 7 === 0) playSound('streak'); // Milestone streaks
            } else {
                document.getElementById('success-streak').style.display = 'none';
            }
            
            // Add context: games played today
            const gamesPlayedToday = getGamesPlayedToday();
            const contextEl = document.getElementById('success-context');
            const gamesContextEl = document.getElementById('success-context-games');
            const extraContextEl = document.getElementById('success-context-extra');
            
            if (gamesPlayedToday > 1) {
                gamesContextEl.textContent = `ðŸŽ® ${gamesPlayedToday} games completed today`;
                contextEl.style.display = 'block';
                
                // Check for personal best (simple version)
                if (result.score?.includes('1/') || result.score === 'Perfect! ðŸŽ¯') {
                    extraContextEl.textContent = 'â­ Personal best today!';
                    extraContextEl.style.display = 'block';
                } else {
                    extraContextEl.style.display = 'none';
                }
            } else {
                contextEl.style.display = 'none';
            }
            
            // Check for active battles with this game and show impact
            updateBattleImpact(result);
            
            modal.classList.add('active');
            
            // Don't auto-dismiss - let user choose to share or dismiss
        }
        
        // Update battle impact card in success modal
        function updateBattleImpact(result) {
            const impactCard = document.getElementById('battle-impact-card');
            if (!impactCard) return;
            
            // Find active battles that include this game
            const activeBattle = userBattles.find(b => 
                b.status === 'active' && 
                b.games?.includes(result.gameId)
            );
            
            if (!activeBattle) {
                impactCard.style.display = 'none';
                currentBattleImpact = null;
                return;
            }
            
            currentBattleImpact = activeBattle;
            
            // Get participants sorted by score
            const participants = Object.entries(activeBattle.participants || {})
                .map(([uid, data]) => ({ odId: uid, ...data }))
                .sort((a, b) => (b.score || 0) - (a.score || 0));
            
            const myUid = currentUser?.uid;
            const myParticipant = participants.find(p => p.odId === myUid);
            const myPosition = participants.findIndex(p => p.odId === myUid) + 1;
            const leader = participants[0];
            const isLeading = leader?.odId === myUid;
            
            // Calculate days remaining
            const daysLeft = Math.max(0, Math.ceil((activeBattle.endDate - Date.now()) / 86400000));
            
            // Update card content
            document.getElementById('battle-impact-name').textContent = activeBattle.name;
            document.getElementById('battle-impact-score').textContent = `${myParticipant?.score || 0} pts (+${result.numericScore || 0})`;
            
            // Position display
            const positionEl = document.getElementById('battle-impact-position');
            const rankEmojis = ['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰'];
            positionEl.innerHTML = `
                <span>${rankEmojis[myPosition - 1] || myPosition}</span>
                <span>${myPosition}${getOrdinalSuffix(myPosition)} of ${participants.length}</span>
            `;
            positionEl.className = 'battle-impact-position ' + (isLeading ? 'leading' : 'trailing');
            
            // Leader info
            if (isLeading) {
                document.getElementById('battle-impact-leader').textContent = 'You\'re winning! ðŸŽ¯';
                document.getElementById('battle-impact-gap').textContent = participants.length > 1 ? 
                    `+${(myParticipant?.score || 0) - (participants[1]?.score || 0)} ahead` : 'No competition yet';
            } else {
                document.getElementById('battle-impact-leader').textContent = `${leader?.displayName || 'Leader'} (${leader?.score || 0})`;
                document.getElementById('battle-impact-gap').textContent = `-${(leader?.score || 0) - (myParticipant?.score || 0)} behind`;
            }
            
            // Tip based on situation
            const tipEl = document.getElementById('battle-impact-tip');
            let tip = `${daysLeft} day${daysLeft !== 1 ? 's' : ''} remaining`;
            if (isLeading && daysLeft > 1) {
                tip += ' - stay consistent!';
            } else if (!isLeading && daysLeft > 0) {
                tip += ' - keep pushing!';
            }
            tipEl.innerHTML = `<span>ðŸ’¡</span><span>${escapeHtml(tip)}</span>`;
            
            impactCard.style.display = 'block';
        }
        
        // Share battle progress
        function shareBattleProgress() {
            if (!currentBattleImpact) return;
            
            const participants = Object.entries(currentBattleImpact.participants || {})
                .map(([uid, data]) => ({ odId: uid, ...data }))
                .sort((a, b) => (b.score || 0) - (a.score || 0));
            
            const myUid = currentUser?.uid;
            const myParticipant = participants.find(p => p.odId === myUid);
            const myPosition = participants.findIndex(p => p.odId === myUid) + 1;
            const daysLeft = Math.max(0, Math.ceil((currentBattleImpact.endDate - Date.now()) / 86400000));
            
            const rankEmojis = ['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰'];
            const message = [
                `âš”ï¸ Battle Update!`,
                ``,
                `"${currentBattleImpact.name}"`,
                ``,
                `${lastLoggedGame?.icon || 'ðŸŽ®'} ${lastLoggedGame?.name || 'Game'}: ${lastLoggedResult?.score || ''} (+${lastLoggedResult?.numericScore || 0} pts)`,
                `Total: ${myParticipant?.score || 0} pts | ${rankEmojis[myPosition - 1] || ''} ${myPosition}${getOrdinalSuffix(myPosition)} place`,
                ``,
                `${daysLeft} day${daysLeft !== 1 ? 's' : ''} left in battle!`,
                ``,
                `Track your games: gameshelf.app`
            ].join('\n');
            
            if (navigator.share) {
                navigator.share({ text: message }).catch(() => {
                    navigator.clipboard.writeText(message).then(() => {
                        showToast('Copied to clipboard!');
                    }).catch(() => {
                        showToast('Could not copy', 'error');
                    });
                });
            } else {
                navigator.clipboard.writeText(message).then(() => {
                    showToast('Copied to clipboard!');
                }).catch(() => {
                    showToast('Could not copy', 'error');
                });
            }
            
            closeSuccessModal();
        }
        
        // Helper for ordinal suffix
        function getOrdinalSuffix(n) {
            const s = ['th', 'st', 'nd', 'rd'];
            const v = n % 100;
            return s[(v - 20) % 10] || s[v] || s[0];
        }
        
        function closeSuccessModal() {
            document.getElementById('success-modal').classList.remove('active');
        }
        
        // ============ INSTANT SHARE ============
        function openInstantShare() {
            closeSuccessModal();
            
            // Generate enhanced share message
            const message = generateEnhancedShareMessage(lastLoggedGame, lastLoggedResult);
            document.getElementById('instant-share-preview').value = message;
            
            // Generate image card
            generateShareCard();
            
            // Show the sheet
            document.getElementById('instant-share-backdrop').classList.add('active');
            document.getElementById('instant-share-sheet').classList.add('active');
        }
        
        function closeInstantShare() {
            document.getElementById('instant-share-backdrop').classList.remove('active');
            document.getElementById('instant-share-sheet').classList.remove('active');
        }
        
        function generateEnhancedShareMessage(game, result) {
            if (!game || !result) {
                return generateTodayRecapMessage();
            }
            
            const stats = appData.stats[result.gameId] || {};
            const streak = stats.currentStreak || 0;
            const gamesPlayedToday = getGamesPlayedToday();
            
            let lines = [];
            
            // Header with game and score
            lines.push(`${game.icon} ${game.name} - ${result.score}`);
            lines.push('');
            
            // Context line(s)
            let contextParts = [];
            
            if (result.score?.includes('1/') || result.score === 'Perfect! ðŸŽ¯') {
                contextParts.push('â­ Perfect!');
            }
            
            // Per-game friend comparison
            const gameComparison = getPerGameFriendComparison(result.gameId);
            if (gameComparison.total > 0 && gameComparison.beat > 0) {
                contextParts.push(`ðŸ‘‘ Beat ${gameComparison.beat} friend${gameComparison.beat !== 1 ? 's' : ''}`);
            }
            
            if (streak > 1) {
                contextParts.push(`ðŸ”¥ ${streak}-day streak`);
            }
            
            if (gamesPlayedToday > 1) {
                contextParts.push(`ðŸŽ® ${gamesPlayedToday} games today`);
            }
            
            if (contextParts.length > 0) {
                lines.push(contextParts.join(' â€¢ '));
                lines.push('');
            }
            
            // CTA
            lines.push('via Game Shelf ðŸ§©');
            
            return lines.join('\n');
        }
        
        function generateTodayRecapMessage() {
            const todayHistory = getTodayHistory();
            const gameIds = Object.keys(todayHistory);
            
            if (gameIds.length === 0) {
                return 'No games played yet today!\n\nvia Game Shelf ðŸ§©';
            }
            
            let lines = [];
            
            // Header with date
            const today = new Date();
            const dateStr = today.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
            lines.push(`ðŸ§© My Puzzle Results â€¢ ${dateStr}`);
            lines.push('');
            
            // Show each game with its grid (the actual pasted results)
            for (const gameId of gameIds) {
                const game = GAMES[gameId];
                const entry = todayHistory[gameId];
                if (game) {
                    // Game header with score
                    lines.push(`${game.icon} ${game.name} ${entry.score}`);
                    
                    // Include the grid if we have it
                    if (entry.grid) {
                        lines.push(entry.grid);
                    }
                    lines.push('');
                }
            }
            
            // Current streak if notable
            const maxStreak = getMaxStreak(appData);
            if (maxStreak > 1) {
                lines.push(`ðŸ”¥ ${maxStreak}-day streak`);
                lines.push('');
            }
            
            lines.push('Track your puzzles: gameshelf.app ðŸ§©');
            
            return lines.join('\n');
        }
        
        // Generate weekly recap message
        function generateWeeklyRecapMessage() {
            const weekData = getWeeklyStats();
            
            if (weekData.totalGames === 0) {
                return 'No games played this week yet!\n\nvia Game Shelf ðŸ§©';
            }
            
            let lines = [];
            
            // Header
            lines.push('ðŸ“Š Weekly Puzzle Recap');
            lines.push(`${weekData.startDate} - ${weekData.endDate}`);
            lines.push('');
            
            // Key stats
            lines.push(`ðŸŽ® ${weekData.totalGames} games played`);
            lines.push(`ðŸ“… ${weekData.daysActive}/7 days active`);
            
            if (weekData.winRate > 0) {
                lines.push(`ðŸ† ${weekData.winRate}% win rate`);
            }
            
            if (weekData.perfectCount > 0) {
                lines.push(`â­ ${weekData.perfectCount} perfect${weekData.perfectCount !== 1 ? 's' : ''}`);
            }
            
            lines.push('');
            
            // Top games
            if (weekData.topGames.length > 0) {
                lines.push('Top games:');
                weekData.topGames.slice(0, 3).forEach((g, i) => {
                    const medal = ['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰'][i];
                    lines.push(`${medal} ${g.icon} ${g.name} (${g.count}x)`);
                });
                lines.push('');
            }
            
            // Friend comparison
            if (weekData.friendsBeaten > 0) {
                lines.push(`ðŸ‘‘ Beat ${weekData.friendsBeaten} friend${weekData.friendsBeaten !== 1 ? 's' : ''} this week!`);
                lines.push('');
            }
            
            // Best streak
            if (weekData.bestStreak > 1) {
                lines.push(`ðŸ”¥ Best streak: ${weekData.bestStreak} days`);
                lines.push('');
            }
            
            lines.push('via Game Shelf ðŸ§©');
            
            return lines.join('\n');
        }
        
        // Get weekly statistics
        function getWeeklyStats() {
            const today = new Date();
            const dayOfWeek = today.getDay(); // 0 = Sunday
            const startOfWeek = new Date(today);
            startOfWeek.setDate(today.getDate() - dayOfWeek);
            
            const stats = {
                totalGames: 0,
                daysActive: 0,
                perfectCount: 0,
                wins: 0,
                losses: 0,
                winRate: 0,
                topGames: [],
                bestStreak: 0,
                friendsBeaten: 0,
                startDate: startOfWeek.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
                endDate: today.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })
            };
            
            const gameCounts = {};
            const activeDays = new Set();
            
            // Iterate through each day of the week
            for (let i = 0; i <= dayOfWeek; i++) {
                const date = new Date(startOfWeek);
                date.setDate(startOfWeek.getDate() + i);
                // v1.3.0: Use local date format to match getTodayString() (fixes timezone mismatch)
                const dateStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
                const dayHistory = appData.history?.[dateStr] || {};
                
                const dayGames = Object.keys(dayHistory);
                if (dayGames.length > 0) {
                    activeDays.add(dateStr);
                }
                
                for (const gameId of dayGames) {
                    const entry = dayHistory[gameId];
                    const game = GAMES[gameId];
                    
                    stats.totalGames++;
                    
                    // Count by game
                    if (!gameCounts[gameId]) {
                        gameCounts[gameId] = { count: 0, icon: game?.icon || 'ðŸŽ®', name: game?.name || gameId };
                    }
                    gameCounts[gameId].count++;
                    
                    // Win/loss
                    if (entry.won === true) stats.wins++;
                    else if (entry.won === false) stats.losses++;
                    
                    // Perfects
                    const score = entry.score || '';
                    if (score.includes('1/') || score.includes('Perfect') || score.includes('ðŸŽ¯')) {
                        stats.perfectCount++;
                    }
                }
            }
            
            stats.daysActive = activeDays.size;
            stats.winRate = stats.totalGames > 0 ? Math.round((stats.wins / stats.totalGames) * 100) : 0;
            stats.bestStreak = getMaxStreak(appData);
            
            // Sort games by count
            stats.topGames = Object.values(gameCounts)
                .sort((a, b) => b.count - a.count)
                .slice(0, 5);
            
            // Count friends beaten (simplified - just count friends with less activity)
            if (friendsData && friendsData.length > 0) {
                for (const friend of friendsData) {
                    const shelfData = friend.shelfData || friendsShelfData[friend.odataId] || {};
                    const friendWeekGames = shelfData.weekCount || 0;
                    if (stats.totalGames > friendWeekGames) {
                        stats.friendsBeaten++;
                    }
                }
            }
            
            return stats;
        }
        
        // Open weekly recap share
        function openWeeklyRecap() {
            const message = generateWeeklyRecapMessage();
            document.getElementById('instant-share-preview').value = message;
            
            // Generate weekly card
            generateWeeklyShareCard();
            
            document.getElementById('instant-share-backdrop').classList.add('active');
            document.getElementById('instant-share-sheet').classList.add('active');
        }
        
        // Get friend comparison stats for sharing
        function getFriendComparisonStats(gameIds) {
            const result = { beat: 0, tied: 0, lost: 0, total: 0 };
            
            if (!currentUser || friendsData.length === 0) return result;
            
            const today = getTodayString();
            const myTodayHistory = appData.history?.[today] || {};
            const myGamesCount = gameIds.length;
            
            // Count friends who played today
            for (const friend of friendsData) {
                const shelfData = friend.shelfData || friendsShelfData[friend.odataId] || {};
                const friendTodayCount = shelfData.todayCount || 0;
                
                // Only compare with friends who have played at least one game
                if (friendTodayCount > 0 || myGamesCount > 0) {
                    result.total++;
                    
                    if (myGamesCount > friendTodayCount) {
                        result.beat++;
                    } else if (myGamesCount === friendTodayCount) {
                        result.tied++;
                    } else {
                        result.lost++;
                    }
                }
            }
            
            return result;
        }
        
        // Get detailed per-game friend comparison
        function getPerGameFriendComparison(gameId) {
            const result = { beat: 0, total: 0 };
            
            if (!currentUser || friendsData.length === 0) return result;
            
            const today = getTodayString();
            const myEntry = appData.history?.[today]?.[gameId];
            if (!myEntry) return result;
            
            const myScore = parseScoreForComparison(gameId, myEntry.score);
            
            for (const friend of friendsData) {
                const shelfData = friend.shelfData || friendsShelfData[friend.odataId] || {};
                const friendHistory = shelfData.history?.[today];
                
                if (friendHistory?.[gameId]) {
                    result.total++;
                    const friendScore = parseScoreForComparison(gameId, friendHistory[gameId].score);
                    
                    // Lower is better for most games (fewer guesses)
                    if (myScore !== null && friendScore !== null) {
                        if (myScore < friendScore) {
                            result.beat++;
                        }
                    }
                }
            }
            
            return result;
        }
        
        // Parse score for comparison (lower = better for most games)
        function parseScoreForComparison(gameId, scoreStr) {
            if (!scoreStr) return null;
            
            // Handle formats like "3/6", "4/5", "X/6"
            const slashMatch = scoreStr.match(/^(\d+|X)\/(\d+)/i);
            if (slashMatch) {
                if (slashMatch[1].toUpperCase() === 'X') return 99; // Failed
                return parseInt(slashMatch[1]);
            }
            
            // Handle plain numbers
            const numMatch = scoreStr.match(/^(\d+)/);
            if (numMatch) {
                return parseInt(numMatch[1]);
            }
            
            // For games where higher is better (like points)
            if (gameId === 'nyt-digits' || gameId === 'nerdle') {
                // These might have different scoring
                return null;
            }
            
            return null;
        }
        
        function instantShareTo(platform) {
            const message = document.getElementById('instant-share-preview').value;
            const encoded = encodeURIComponent(message);
            
            let url;
            switch(platform) {
                case 'twitter':
                    url = `https://twitter.com/intent/tweet?text=${encoded}`;
                    break;
                case 'discord':
                    // Discord doesn't have a share URL, copy instead
                    copyInstantShare();
                    showToast('ðŸ“‹ Copied! Paste in Discord');
                    return;
                case 'reddit':
                    url = `https://www.reddit.com/submit?title=${encodeURIComponent('My Daily Puzzle Results')}&text=${encoded}`;
                    break;
                case 'bluesky':
                    url = `https://bsky.app/intent/compose?text=${encoded}`;
                    break;
                default:
                    copyInstantShare();
                    return;
            }
            
            window.open(url, '_blank');
            closeInstantShare();
            showToast('ðŸš€ Opening ' + platform + '...');
            unlockSocialAchievement();
        }
        
        function copyInstantShare() {
            const message = document.getElementById('instant-share-preview').value;
            navigator.clipboard.writeText(message).then(() => {
                showToast('ðŸ“‹ Copied to clipboard!');
                closeInstantShare();
            }).catch(() => {
                // Fallback
                const textarea = document.createElement('textarea');
                textarea.value = message;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showToast('ðŸ“‹ Copied to clipboard!');
                closeInstantShare();
            });
        }
        
        function nativeInstantShare() {
            const message = document.getElementById('instant-share-preview').value;
            
            if (navigator.share) {
                navigator.share({
                    title: 'ðŸŽ® Daily Puzzle Results',
                    text: message
                }).then(() => {
                    closeInstantShare();
                    unlockSocialAchievement();
                }).catch((err) => {
                    if (err.name !== 'AbortError') {
                        copyInstantShare();
                    }
                });
            } else {
                copyInstantShare();
            }
        }
        
        function quickShareRecap() {
            // Generate recap message and open instant share
            const message = generateTodayRecapMessage();
            document.getElementById('instant-share-preview').value = message;
            
            // Generate image card
            generateShareCard();
            
            // Show the sheet
            document.getElementById('instant-share-backdrop').classList.add('active');
            document.getElementById('instant-share-sheet').classList.add('active');
        }
        
        // ============ PHASE 2: IMAGE CARD GENERATOR ============
        let currentImageStyle = 'default';
        let currentImageFormat = 'landscape'; // 'landscape' or 'story'
        let currentCardData = null;
        
        const IMAGE_STYLES = {
            default: {
                bg: '#1a1a2e',
                bgGradient: ['#1a1a2e', '#16213e'],
                text: '#ffffff',
                accent: '#667eea',
                secondary: '#a0a0b0'
            },
            dark: {
                bg: '#0a0a0f',
                bgGradient: ['#0a0a0f', '#12121a'],
                text: '#ffffff',
                accent: '#10b981',
                secondary: '#666680'
            },
            gradient: {
                bg: '#667eea',
                bgGradient: ['#667eea', '#764ba2'],
                text: '#ffffff',
                accent: '#fbbf24',
                secondary: '#e0e0ff'
            },
            minimal: {
                bg: '#ffffff',
                bgGradient: ['#ffffff', '#f5f5f5'],
                text: '#1a1a2e',
                accent: '#667eea',
                secondary: '#666666'
            }
        };
        
        function setImageStyle(style) {
            currentImageStyle = style;
            
            // Update button states
            document.querySelectorAll('.image-style-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.style === style);
            });
            
            // Regenerate card
            generateShareCard();
        }
        
        function setImageFormat(format) {
            currentImageFormat = format;
            
            // Update button states
            document.querySelectorAll('.image-format-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.format === format);
            });
            
            // Update preview container class
            const container = document.getElementById('image-card-preview-container');
            if (container) {
                container.classList.toggle('story-mode', format === 'story');
            }
            
            // Regenerate card
            generateShareCard();
        }
        
        function generateShareCard() {
            const canvas = document.getElementById('share-card-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const style = IMAGE_STYLES[currentImageStyle];
            
            // Set canvas size based on format (2x for retina)
            const isStory = currentImageFormat === 'story';
            const width = isStory ? 540 : 600;  // Story: 9:16 aspect
            const height = isStory ? 960 : 400;
            
            canvas.width = width * 2;
            canvas.height = height * 2;
            canvas.style.width = (isStory ? 180 : 300) + 'px';  // Preview size
            canvas.style.height = (isStory ? 320 : 200) + 'px';
            ctx.scale(2, 2);
            
            // Draw background gradient
            const gradient = ctx.createLinearGradient(0, 0, width, height);
            gradient.addColorStop(0, style.bgGradient[0]);
            gradient.addColorStop(1, style.bgGradient[1]);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            // Get data to display
            const todayHistory = getTodayHistory();
            const gameIds = Object.keys(todayHistory);
            const isRecap = !lastLoggedGame || gameIds.length > 1;
            
            if (isStory) {
                drawStoryCard(ctx, width, height, style, todayHistory, gameIds);
            } else if (isRecap) {
                drawRecapCard(ctx, width, height, style, todayHistory, gameIds);
            } else {
                drawSingleGameCard(ctx, width, height, style);
            }
            
            // Draw branding
            ctx.font = `600 ${isStory ? 18 : 14}px -apple-system, BlinkMacSystemFont, sans-serif`;
            ctx.fillStyle = style.secondary;
            ctx.textAlign = 'center';
            ctx.fillText('via Game Shelf ðŸ§©', width / 2, height - (isStory ? 40 : 20));
        }
        
        function drawStoryCard(ctx, width, height, style, todayHistory, gameIds) {
            const gameCount = gameIds.length;
            
            // Title at top
            ctx.font = '700 36px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = style.text;
            ctx.textAlign = 'center';
            ctx.fillText('ðŸŽ® Daily Recap', width / 2, 80);
            
            // Date
            const today = new Date();
            const dateStr = today.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' });
            ctx.font = '500 20px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = style.secondary;
            ctx.fillText(dateStr, width / 2, 120);
            
            // Game count badge
            ctx.font = '700 24px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = style.accent;
            ctx.fillText(`${gameCount} game${gameCount !== 1 ? 's' : ''} played`, width / 2, 170);
            
            // Games list (centered, stacked vertically)
            const displayGames = gameIds.slice(0, 8);
            const startY = 230;
            const rowHeight = 60;
            
            ctx.textAlign = 'center';
            let totalPoints = 0;
            let perfectCount = 0;
            
            displayGames.forEach((gameId, i) => {
                const game = GAMES[gameId];
                const entry = todayHistory[gameId];
                const y = startY + (i * rowHeight);
                const score = entry?.score || 'âœ“';
                
                totalPoints += entry?.numericScore || 0;
                if (score.includes('1/') || score.includes('Perfect') || score.includes('ðŸŽ¯')) {
                    perfectCount++;
                }
                
                // Icon and name
                ctx.font = '32px serif';
                ctx.fillStyle = style.text;
                ctx.fillText(`${game?.icon || 'ðŸŽ®'}`, width / 2, y);
                
                // Score below
                ctx.font = '600 20px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = style.accent;
                ctx.fillText(score, width / 2, y + 28);
            });
            
            // Stats at bottom
            const statsY = height - 120;
            let statsLine = [];
            
            if (perfectCount > 0) {
                statsLine.push(`â­ ${perfectCount} perfect`);
            }
            if (totalPoints > 0) {
                statsLine.push(`ðŸ’Ž ${totalPoints} pts`);
            }
            
            if (statsLine.length > 0) {
                ctx.font = '600 22px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = style.accent;
                ctx.fillText(statsLine.join('  â€¢  '), width / 2, statsY);
            }
            
            // Friend comparison
            const friendComparison = getFriendComparisonStats(gameIds);
            if (friendComparison.total > 0 && friendComparison.beat > 0) {
                ctx.font = '700 24px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = style.accent;
                ctx.fillText(`ðŸ‘‘ Beat ${friendComparison.beat}/${friendComparison.total} friends!`, width / 2, statsY + 40);
            }
        }
        
        function drawSingleGameCard(ctx, width, height, style) {
            const game = lastLoggedGame;
            const result = lastLoggedResult;
            const stats = appData.stats[result?.gameId] || {};
            const streak = stats.currentStreak || 0;
            
            // Game icon (large)
            ctx.font = '80px serif';
            ctx.textAlign = 'center';
            ctx.fillText(game?.icon || 'ðŸŽ®', width / 2, 100);
            
            // Game name
            ctx.font = '700 32px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = style.text;
            ctx.fillText(game?.name || 'Game', width / 2, 150);
            
            // Score (large)
            ctx.font = '800 56px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = style.accent;
            ctx.fillText(result?.score || 'âœ“', width / 2, 220);
            
            // Context line
            let contextParts = [];
            if (result?.score?.includes('1/') || result?.score === 'Perfect! ðŸŽ¯') {
                contextParts.push('â­ Perfect');
            }
            if (streak > 1) {
                contextParts.push(`ðŸ”¥ ${streak}-day streak`);
            }
            
            if (contextParts.length > 0) {
                ctx.font = '600 20px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = style.secondary;
                ctx.fillText(contextParts.join('  â€¢  '), width / 2, 270);
            }
            
            // Points
            ctx.font = '600 24px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = style.accent;
            ctx.fillText(`+${result?.numericScore || 15} pts`, width / 2, 320);
        }
        
        function drawRecapCard(ctx, width, height, style, todayHistory, gameIds) {
            // Title
            ctx.font = '700 28px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = style.text;
            ctx.textAlign = 'center';
            ctx.fillText('ðŸ§© Daily Puzzle Recap', width / 2, 50);
            
            // Date
            const today = new Date();
            const dateStr = today.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' });
            ctx.font = '500 16px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = style.secondary;
            ctx.fillText(dateStr, width / 2, 80);
            
            // Games list (max 6)
            const displayGames = gameIds.slice(0, 6);
            const startY = 120;
            const rowHeight = 45;
            
            ctx.textAlign = 'left';
            displayGames.forEach((gameId, i) => {
                const game = GAMES[gameId];
                const entry = todayHistory[gameId];
                const y = startY + (i * rowHeight);
                
                // Icon
                ctx.font = '28px serif';
                ctx.fillText(game?.icon || 'ðŸŽ®', 80, y + 8);
                
                // Name
                ctx.font = '600 18px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = style.text;
                ctx.fillText(game?.name || gameId, 130, y);
                
                // Score
                ctx.font = '700 18px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = style.accent;
                ctx.textAlign = 'right';
                ctx.fillText(entry?.score || 'âœ“', width - 80, y);
                ctx.textAlign = 'left';
            });
            
            if (gameIds.length > 6) {
                ctx.font = '500 14px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = style.secondary;
                ctx.textAlign = 'center';
                ctx.fillText(`+${gameIds.length - 6} more`, width / 2, startY + (6 * rowHeight));
            }
            
            // Stats summary - friend comparison or streak
            const friendComparison = getFriendComparisonStats(gameIds);
            const maxStreak = getMaxStreak(appData);
            
            ctx.textAlign = 'center';
            
            // Show friend comparison if available, otherwise streak
            if (friendComparison.total > 0 && friendComparison.beat > 0) {
                ctx.font = '600 20px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = style.accent;
                ctx.fillText(`ðŸ‘‘ Beat ${friendComparison.beat}/${friendComparison.total} friend${friendComparison.total !== 1 ? 's' : ''}!`, width / 2, height - 60);
            } else if (maxStreak > 1) {
                ctx.font = '600 20px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = style.accent;
                ctx.fillText(`ðŸ”¥ Best streak: ${maxStreak} days`, width / 2, height - 60);
            }
        }
        
        // Generate weekly recap image card
        function generateWeeklyShareCard() {
            const canvas = document.getElementById('share-card-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const style = IMAGE_STYLES[currentImageStyle];
            const weekData = getWeeklyStats();
            
            // Use landscape format for weekly
            const width = 600;
            const height = 400;
            canvas.width = width * 2;
            canvas.height = height * 2;
            canvas.style.width = '300px';
            canvas.style.height = '200px';
            ctx.scale(2, 2);
            
            // Background gradient
            const gradient = ctx.createLinearGradient(0, 0, width, height);
            gradient.addColorStop(0, style.bgGradient[0]);
            gradient.addColorStop(1, style.bgGradient[1]);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            // Title
            ctx.font = '700 28px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = style.text;
            ctx.textAlign = 'center';
            ctx.fillText('ðŸ“Š Weekly Recap', width / 2, 45);
            
            // Date range
            ctx.font = '500 14px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = style.secondary;
            ctx.fillText(`${weekData.startDate} - ${weekData.endDate}`, width / 2, 70);
            
            // Stats grid (2x2)
            const statsData = [
                { label: 'Games', value: weekData.totalGames, icon: 'ðŸŽ®' },
                { label: 'Days Active', value: `${weekData.daysActive}/7`, icon: 'ðŸ“…' },
                { label: 'Win Rate', value: `${weekData.winRate}%`, icon: 'ðŸ†' },
                { label: 'Perfects', value: weekData.perfectCount, icon: 'â­' }
            ];
            
            const gridStartY = 100;
            const cellWidth = width / 2;
            const cellHeight = 70;
            
            statsData.forEach((stat, i) => {
                const col = i % 2;
                const row = Math.floor(i / 2);
                const x = col * cellWidth + cellWidth / 2;
                const y = gridStartY + row * cellHeight;
                
                // Icon
                ctx.font = '24px serif';
                ctx.fillStyle = style.text;
                ctx.fillText(stat.icon, x, y);
                
                // Value
                ctx.font = '700 28px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = style.accent;
                ctx.fillText(String(stat.value), x, y + 35);
                
                // Label
                ctx.font = '500 12px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = style.secondary;
                ctx.fillText(stat.label, x, y + 52);
            });
            
            // Top games row
            if (weekData.topGames.length > 0) {
                ctx.font = '600 14px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = style.secondary;
                ctx.fillText('Top Games', width / 2, 265);
                
                const topGamesStr = weekData.topGames.slice(0, 3)
                    .map(g => `${g.icon} ${g.name}`)
                    .join('  â€¢  ');
                
                ctx.font = '500 16px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = style.text;
                ctx.fillText(topGamesStr, width / 2, 290);
            }
            
            // Bottom stats
            let bottomY = 330;
            
            if (weekData.friendsBeaten > 0) {
                ctx.font = '600 18px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = style.accent;
                ctx.fillText(`ðŸ‘‘ Beat ${weekData.friendsBeaten} friend${weekData.friendsBeaten !== 1 ? 's' : ''} this week!`, width / 2, bottomY);
                bottomY += 30;
            } else if (weekData.bestStreak > 1) {
                ctx.font = '600 18px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = style.accent;
                ctx.fillText(`ðŸ”¥ ${weekData.bestStreak}-day streak`, width / 2, bottomY);
                bottomY += 30;
            }
            
            // Branding
            ctx.font = '600 14px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = style.secondary;
            ctx.fillText('via Game Shelf ðŸ§©', width / 2, height - 20);
        }
        
        function downloadShareCard() {
            const canvas = document.getElementById('share-card-canvas');
            if (!canvas) return;
            
            const link = document.createElement('a');
            const dateStr = new Date().toISOString().split('T')[0];
            link.download = `gameshelf-${dateStr}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
            
            showToast('ðŸ“¥ Image downloaded!');
        }
        
        async function shareCardImage() {
            const canvas = document.getElementById('share-card-canvas');
            if (!canvas) return;
            
            try {
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                const file = new File([blob], 'gameshelf-results.png', { type: 'image/png' });
                
                if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
                    await navigator.share({
                        title: 'ðŸŽ® My Daily Puzzle Results',
                        text: 'Check out my puzzle results!',
                        files: [file]
                    });
                    closeInstantShare();
                    showToast('ðŸš€ Shared!');
                } else {
                    // Fallback to download
                    downloadShareCard();
                }
            } catch (err) {
                if (err.name !== 'AbortError') {
                    downloadShareCard();
                }
            }
        }
        
        // ============ PHASE 2: STREAK MILESTONE CELEBRATION ============
        const MILESTONE_MESSAGES = {
            7: "One week strong! ðŸ’ª",
            14: "Two weeks of dedication!",
            30: "A whole month! Amazing!",
            50: "Halfway to 100! Incredible!",
            100: "LEGENDARY! 100 days! ðŸ†",
            200: "Unstoppable force! 200 days!",
            365: "ONE YEAR! You're a champion! ðŸ‘‘"
        };
        
        let currentMilestoneData = null;
        
        function checkStreakMilestone(gameId, newStreak, oldStreak) {
            const milestones = [7, 14, 30, 50, 100, 200, 365];
            
            // Check if we just crossed a milestone
            for (const milestone of milestones) {
                if (newStreak >= milestone && oldStreak < milestone) {
                    const game = GAMES[gameId];
                    showMilestoneCelebration(milestone, game, gameId);
                    return true;
                }
            }
            return false;
        }
        
        function showMilestoneCelebration(milestone, game, gameId) {
            currentMilestoneData = { milestone, game, gameId };
            
            // Update UI
            document.getElementById('milestone-number').textContent = milestone;
            document.getElementById('milestone-game').textContent = `${game?.icon || 'ðŸŽ®'} ${game?.name || 'Game'}`;
            document.getElementById('milestone-message').textContent = MILESTONE_MESSAGES[milestone] || 'Amazing streak!';
            
            // Play celebration sound
            playSound('achievement');
            
            // Show confetti
            launchConfetti();
            
            // Show modal
            document.getElementById('milestone-overlay').classList.add('active');
        }
        
        function closeMilestone() {
            document.getElementById('milestone-overlay').classList.remove('active');
            clearConfetti();
        }
        
        function shareMilestone() {
            if (!currentMilestoneData) return;
            
            const { milestone, game, gameId } = currentMilestoneData;
            
            // Set last logged for share generation
            lastLoggedGame = game;
            lastLoggedResult = {
                gameId: gameId,
                score: `${milestone}-day streak! ðŸ”¥`,
                won: true,
                numericScore: milestone
            };
            
            closeMilestone();
            openInstantShare();
        }
        
        // ============ CONFETTI ============
        function launchConfetti() {
            const container = document.getElementById('confetti-container');
            if (!container) return;
            
            const colors = ['#667eea', '#764ba2', '#f59e0b', '#ef4444', '#10b981', '#fbbf24'];
            const confettiCount = 50;
            
            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.width = (Math.random() * 10 + 5) + 'px';
                confetti.style.height = (Math.random() * 10 + 5) + 'px';
                confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                confetti.style.animation = `confettiFall ${Math.random() * 2 + 2}s ease-out forwards`;
                confetti.style.animationDelay = Math.random() * 0.5 + 's';
                container.appendChild(confetti);
            }
        }
        
        function clearConfetti() {
            const container = document.getElementById('confetti-container');
            if (container) {
                container.innerHTML = '';
            }
        }
        
        // ============ PHASE 2: BATTLE WIN SHARE PROMPT ============
        function showBattleWinShare(battle, isWinner, finalScore, opponentScore) {
            if (!isWinner) return;
            
            // Set up share data
            lastLoggedGame = { name: battle.name, icon: 'âš”ï¸' };
            lastLoggedResult = {
                gameId: 'battle',
                score: `Victory! ${finalScore} pts`,
                won: true,
                numericScore: finalScore,
                meta: {
                    battleName: battle.name,
                    opponentScore: opponentScore,
                    prizePool: battle.prizePool
                }
            };
            
            // Generate special battle win message
            const message = generateBattleWinMessage(battle, finalScore, opponentScore);
            document.getElementById('instant-share-preview').value = message;
            
            // Generate image card
            generateBattleWinCard(battle, finalScore, opponentScore);
            
            // Show instant share
            document.getElementById('instant-share-backdrop').classList.add('active');
            document.getElementById('instant-share-sheet').classList.add('active');
        }
        
        function generateBattleWinMessage(battle, finalScore, opponentScore) {
            let lines = [];
            
            lines.push('ðŸ† VICTORY!');
            lines.push('');
            lines.push(`âš”ï¸ ${battle.name}`);
            lines.push('');
            lines.push(`My score: ${finalScore} pts`);
            if (opponentScore) {
                lines.push(`Opponent: ${opponentScore} pts`);
            }
            lines.push('');
            if (battle.prizePool > 0) {
                lines.push(`ðŸª™ Won ${battle.prizePool} coins!`);
                lines.push('');
            }
            lines.push('via Game Shelf âš”ï¸');
            
            return lines.join('\n');
        }
        
        function generateBattleWinCard(battle, finalScore, opponentScore) {
            const canvas = document.getElementById('share-card-canvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const style = IMAGE_STYLES[currentImageStyle];
            
            const width = 600;
            const height = 400;
            canvas.width = width * 2;
            canvas.height = height * 2;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(2, 2);
            
            // Background
            const gradient = ctx.createLinearGradient(0, 0, width, height);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(1, '#16213e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            // Victory banner
            ctx.font = '80px serif';
            ctx.textAlign = 'center';
            ctx.fillText('ðŸ†', width / 2, 90);
            
            ctx.font = '800 40px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = '#fbbf24';
            ctx.fillText('VICTORY!', width / 2, 145);
            
            // Battle name
            ctx.font = '600 24px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = '#ffffff';
            ctx.fillText(battle.name, width / 2, 190);
            
            // Scores
            ctx.font = '700 48px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = '#10b981';
            ctx.fillText(`${finalScore} pts`, width / 2, 260);
            
            if (opponentScore) {
                ctx.font = '500 20px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = '#a0a0b0';
                ctx.fillText(`vs ${opponentScore} pts`, width / 2, 295);
            }
            
            // Prize
            if (battle.prizePool > 0) {
                ctx.font = '600 24px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = '#fbbf24';
                ctx.fillText(`ðŸª™ Won ${battle.prizePool} coins!`, width / 2, 345);
            }
            
            // Branding
            ctx.font = '600 14px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = '#666680';
            ctx.fillText('via Game Shelf âš”ï¸', width / 2, height - 20);
        }
        
        // ============ SHARE HUB ============
        function showShareHub() {
            // Share is now a tab - switch to it
            switchTab('share');
        }
        
        function closeShareHub() {
            // No longer needed - Share is a tab, not a modal
            switchTab('home');
        }
        
        function populateShareScreen() {
            const container = document.getElementById('share-screen-results');
            if (!container) return;
            
            const todayHistory = getTodayHistory();
            
            const results = [];
            
            // Check all games in shelf and catalog
            for (const gameId of Object.keys(todayHistory)) {
                const game = GAMES[gameId];
                if (game) {
                    results.push({
                        name: game.name,
                        icon: game.icon,
                        score: todayHistory[gameId].score || 'âœ“'
                    });
                }
            }
            
            if (results.length === 0) {
                container.innerHTML = '<span style="color: var(--text-muted);">No games logged today yet</span>';
            } else {
                container.innerHTML = results.map(r => `
                    <span class="share-result-tag">${r.icon} ${r.name}: <span class="score">${r.score}</span></span>
                `).join('');
            }
            
            // Set date
            const dateEl = document.getElementById('share-screen-date');
            if (dateEl) {
                const today = new Date();
                dateEl.textContent = today.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
            }
            
            // Apply default template
            applyShareTemplate();
            
            // Render share history
            renderShareHistory();
        }
        
        // Keep old function name for backward compatibility
        function populateShareHubResults() {
            populateShareScreen();
        }
        
        function applyShareTemplate(fromHistory = null) {
            const templateSelect = document.getElementById('share-screen-template') || document.getElementById('share-template-select');
            const template = fromHistory?.template || (templateSelect ? templateSelect.value : 'default');
            const todayHistory = getTodayHistory();
            
            // If loading from history, use saved message
            if (fromHistory?.message) {
                const textarea = document.getElementById('share-screen-message') || document.getElementById('share-message');
                if (textarea) textarea.value = fromHistory.message;
                return;
            }
            
            let gamesPlayed = 0;
            let gamesList = [];
            
            for (const gameId of Object.keys(todayHistory)) {
                const game = GAMES[gameId];
                if (game) {
                    gamesPlayed++;
                    gamesList.push(`${game.icon} ${todayHistory[gameId].score || 'âœ“'}`);
                }
            }
            
            const maxStreak = getMaxStreak();
            let message = '';
            
            switch(template) {
                case 'brag':
                    message = `ðŸ† Crushed it today!\n\n${gamesList.join('\n')}\n\n${gamesPlayed} games completed. Who else is keeping up? ðŸ’ª`;
                    break;
                case 'humble':
                    message = `Just another day of puzzles ðŸ˜…\n\n${gamesList.join('\n')}\n\nSome wins, some struggles. That's the game!`;
                    break;
                case 'streak':
                    message = `ðŸ”¥ ${maxStreak} day streak!\n\n${gamesList.join('\n')}\n\nKeeping the daily puzzle habit going strong!`;
                    break;
                case 'challenge':
                    message = `âš”ï¸ Daily puzzle challenge!\n\n${gamesList.join('\n')}\n\nThink you can beat my scores? Let's see what you got!`;
                    break;
                case 'minimal':
                    message = gamesList.join(' | ');
                    break;
                default:
                    message = `ðŸŽ® Daily Puzzles Complete!\n\n${gamesList.join('\n')}\n\n${gamesPlayed > 0 ? `${gamesPlayed} game${gamesPlayed > 1 ? 's' : ''} down for today!` : 'Time to play some puzzles!'}`;
            }
            
            // Add referral link if enabled
            const includeLink = document.getElementById('share-include-link')?.checked ?? true;
            if (includeLink && template !== 'minimal') {
                const referralLink = getReferralLink();
                message += `\n\nðŸ“² Track your puzzles: ${referralLink}`;
            }
            
            const textarea = document.getElementById('share-screen-message') || document.getElementById('share-message');
            if (textarea) textarea.value = message;
        }
        
        function insertShareEmoji(emoji) {
            const textarea = document.getElementById('share-screen-message') || document.getElementById('share-message');
            if (!textarea) return;
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const text = textarea.value;
            textarea.value = text.substring(0, start) + emoji + text.substring(end);
            textarea.selectionStart = textarea.selectionEnd = start + emoji.length;
            textarea.focus();
        }
        
        function getShareMessage() {
            const textarea = document.getElementById('share-screen-message') || document.getElementById('share-message');
            return textarea ? textarea.value : '';
        }
        
        // ============ SMART HASHTAG DISCOVERY (v1.2.47) ============
        // Platform-specific hashtags for better discoverability
        const PLATFORM_HASHTAGS = {
            twitter: ['#Wordle', '#Connections', '#DailyPuzzles', '#NYTGames'],
            threads: ['#Wordle', '#Connections', '#PuzzleGames'],
            bluesky: ['#Wordle', '#Connections'],
            mastodon: ['#Wordle', '#Connections', '#PuzzleGames']
        };
        
        function appendDiscoveryHashtags(message, platform) {
            const hashtags = PLATFORM_HASHTAGS[platform];
            if (!hashtags || hashtags.length === 0) return { message, added: [] };
            
            // Check which hashtags aren't already in the message (case-insensitive)
            const messageLower = message.toLowerCase();
            const newTags = hashtags.filter(tag => !messageLower.includes(tag.toLowerCase()));
            
            if (newTags.length === 0) return { message, added: [] };
            
            // Append hashtags on a new line
            const enhancedMessage = message.trim() + '\n\n' + newTags.join(' ');
            return { message: enhancedMessage, added: newTags };
        }
        
        function shareToTwitter() {
            let message = getShareMessage();
            const { message: enhanced, added } = appendDiscoveryHashtags(message, 'twitter');
            const url = `https://twitter.com/intent/tweet?text=${encodeURIComponent(enhanced)}`;
            window.open(url, '_blank');
            if (added.length > 0) {
                showToast(`ðŸ“¤ Shared with ${added.slice(0, 2).join(' ')}...`);
            } else {
                showToast('Opening Twitter...');
            }
            unlockSocialAchievement();
            saveShareToHistory('twitter', enhanced);
        }
        
        function shareToFacebook() {
            const message = getShareMessage();
            copyShareMessage(true);
            const url = `https://www.facebook.com/`;
            window.open(url, '_blank');
            showToast('ðŸ“‹ Copied! Paste in Facebook');
            unlockSocialAchievement();
            saveShareToHistory('facebook', message);
        }
        
        function shareToLinkedIn() {
            const message = getShareMessage();
            copyShareMessage(true);
            const url = `https://www.linkedin.com/`;
            window.open(url, '_blank');
            showToast('ðŸ“‹ Copied! Paste in LinkedIn');
            unlockSocialAchievement();
            saveShareToHistory('linkedin', message);
        }
        
        function shareToThreads() {
            let message = getShareMessage();
            const { message: enhanced, added } = appendDiscoveryHashtags(message, 'threads');
            const url = `https://www.threads.net/intent/post?text=${encodeURIComponent(enhanced)}`;
            window.open(url, '_blank');
            if (added.length > 0) {
                showToast(`ðŸ“¤ Shared with ${added.slice(0, 2).join(' ')}...`);
            } else {
                showToast('Opening Threads...');
            }
            unlockSocialAchievement();
            saveShareToHistory('threads', enhanced);
        }
        
        function shareToReddit() {
            const message = getShareMessage();
            // Smarter Reddit title based on games played
            const todayHistory = getTodayHistory();
            const gameNames = Object.keys(todayHistory)
                .map(id => GAMES[id]?.name)
                .filter(Boolean)
                .slice(0, 3);
            const title = gameNames.length > 0 
                ? `ðŸŽ® Daily Results: ${gameNames.join(', ')}` 
                : 'ðŸŽ® Daily Puzzle Results';
            const url = `https://www.reddit.com/submit?title=${encodeURIComponent(title)}&text=${encodeURIComponent(message)}`;
            window.open(url, '_blank');
            showToast('ðŸ“¤ Opening Reddit... Try r/wordle!');
            unlockSocialAchievement();
            saveShareToHistory('reddit', message);
        }
        
        function shareToDiscord() {
            const message = getShareMessage();
            copyShareMessage();
            showToast('ðŸ“‹ Copied! Paste in Discord');
            unlockSocialAchievement();
            saveShareToHistory('discord', message);
        }
        
        function shareToBlueSky() {
            let message = getShareMessage();
            const { message: enhanced, added } = appendDiscoveryHashtags(message, 'bluesky');
            const url = `https://bsky.app/intent/compose?text=${encodeURIComponent(enhanced)}`;
            window.open(url, '_blank');
            if (added.length > 0) {
                showToast(`ðŸ“¤ Shared with ${added.slice(0, 2).join(' ')}`);
            } else {
                showToast('Opening BlueSky...');
            }
            unlockSocialAchievement();
            saveShareToHistory('bluesky', enhanced);
        }
        
        function shareToMastodon() {
            let message = getShareMessage();
            const { message: enhanced, added } = appendDiscoveryHashtags(message, 'mastodon');
            const url = `https://mastodonshare.com/?text=${encodeURIComponent(enhanced)}`;
            window.open(url, '_blank');
            if (added.length > 0) {
                showToast(`ðŸ“¤ Shared with ${added.slice(0, 2).join(' ')}...`);
            } else {
                showToast('Opening Mastodon...');
            }
            unlockSocialAchievement();
            saveShareToHistory('mastodon', enhanced);
        }
        
        function unlockSocialAchievement() {
            if (!appData.achievements) appData.achievements = {};
            if (!appData.achievements['social']) {
                unlockAchievement('social');
            }
            // Trigger referral engagement (advanced feature)
            triggerReferralEngagement('Share Hub');
        }
        
        function copyShareMessage(silent = false) {
            const message = getShareMessage();
            navigator.clipboard.writeText(message).then(() => {
                if (!silent) {
                    showToast('ðŸ“‹ Copied to clipboard!');
                    // Trigger referral engagement (advanced feature)
                    triggerReferralEngagement('Share Hub');
                    saveShareToHistory('copy', message);
                }
            }).catch(() => {
                // Fallback
                const textarea = document.createElement('textarea');
                textarea.value = message;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                if (!silent) {
                    showToast('ðŸ“‹ Copied to clipboard!');
                    triggerReferralEngagement('Share Hub');
                    saveShareToHistory('copy', message);
                }
            });
        }
        
        function shareNative() {
            const message = getShareMessage();
            
            if (navigator.share) {
                navigator.share({
                    title: 'ðŸŽ® Daily Puzzle Results',
                    text: message
                }).then(() => {
                    // Trigger referral engagement (advanced feature)
                    triggerReferralEngagement('Share Hub');
                    saveShareToHistory('native', message);
                }).catch((err) => {
                    if (err.name !== 'AbortError') {
                        copyShareMessage();
                    }
                });
            } else {
                copyShareMessage();
            }
        }
        
        // ============ SHARE HISTORY ============
        const MAX_SHARE_HISTORY = 20;
        
        function saveShareToHistory(platform, message) {
            // Check if save to history is enabled
            const saveEnabled = document.getElementById('share-save-history')?.checked ?? true;
            if (!saveEnabled) return;
            
            if (!appData.shareHistory) {
                appData.shareHistory = [];
            }
            
            // Get current template
            const templateSelect = document.getElementById('share-screen-template');
            const template = templateSelect ? templateSelect.value : 'default';
            
            // Create history entry
            const entry = {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                platform: platform,
                template: template,
                message: message,
                gamesCount: Object.keys(getTodayHistory()).length
            };
            
            // Add to beginning of array
            appData.shareHistory.unshift(entry);
            
            // Trim to max size
            if (appData.shareHistory.length > MAX_SHARE_HISTORY) {
                appData.shareHistory = appData.shareHistory.slice(0, MAX_SHARE_HISTORY);
            }
            
            saveData();
            renderShareHistory();
        }
        
        function getShareHistory() {
            return appData.shareHistory || [];
        }
        
        function renderShareHistory() {
            const container = document.getElementById('share-history-list');
            const section = document.getElementById('share-history-section');
            if (!container || !section) return;
            
            const history = getShareHistory();
            
            if (history.length === 0) {
                section.style.display = 'none';
                return;
            }
            
            section.style.display = 'block';
            
            const platformIcons = {
                'twitter': 'ð•',
                'facebook': 'ðŸ“˜',
                'linkedin': 'ðŸ’¼',
                'threads': 'ðŸ§µ',
                'reddit': 'ðŸ”´',
                'discord': 'ðŸ’¬',
                'bluesky': 'ðŸ¦‹',
                'mastodon': 'ðŸ˜',
                'copy': 'ðŸ“‹',
                'native': 'ðŸ“¤'
            };
            
            container.innerHTML = history.slice(0, 10).map((entry, index) => {
                const date = new Date(entry.timestamp);
                const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                const timeStr = date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
                const icon = platformIcons[entry.platform] || 'ðŸ“¤';
                const rawPreview = entry.message.split('\n')[0].substring(0, 50) + (entry.message.length > 50 ? '...' : '');
                
                return `
                    <div class="share-history-item" onclick="useShareFromHistory(${parseInt(index)})">
                        <div class="share-history-item-header">
                            <span class="share-history-item-platform">${icon} ${escapeHtml(entry.platform)}</span>
                            <span class="share-history-item-date">${escapeHtml(dateStr)} ${escapeHtml(timeStr)}</span>
                        </div>
                        <div class="share-history-item-preview">${escapeHtml(rawPreview)}</div>
                    </div>
                `;
            }).join('');
        }
        
        function toggleShareHistory() {
            const section = document.getElementById('share-history-section');
            if (section) {
                section.classList.toggle('expanded');
            }
        }
        
        function useShareFromHistory(index) {
            const history = getShareHistory();
            if (index >= 0 && index < history.length) {
                const entry = history[index];
                
                // Load the message into textarea
                const textarea = document.getElementById('share-screen-message');
                if (textarea) {
                    textarea.value = entry.message;
                }
                
                // Update template selector if it matches
                const templateSelect = document.getElementById('share-screen-template');
                if (templateSelect && entry.template) {
                    // Reset to default first, as history option isn't a real template
                    templateSelect.value = 'default';
                }
                
                // Collapse history section
                const section = document.getElementById('share-history-section');
                if (section) {
                    section.classList.remove('expanded');
                }
                
                showToast('ðŸ“œ Loaded from history');
            }
        }
        
        // Handle template select change for history option
        function handleTemplateChange() {
            const templateSelect = document.getElementById('share-screen-template');
            if (templateSelect && templateSelect.value === 'history') {
                // Show history section expanded
                const section = document.getElementById('share-history-section');
                if (section) {
                    section.style.display = 'block';
                    section.classList.add('expanded');
                }
                // Reset select to previous valid option
                templateSelect.value = 'default';
            } else {
                applyShareTemplate();
            }
        }
        
        // Bind clipboard prompt buttons (call after DOM ready)
        function bindClipboardButtons() {
            const yesBtn = document.getElementById('prompt-yes-btn');
            const noBtn = document.getElementById('prompt-no-btn');
            
            if (yesBtn) {
                yesBtn.onclick = function(e) {
                    e.preventDefault();
                    acceptClipboard();
                };
            }
            if (noBtn) {
                noBtn.onclick = function(e) {
                    e.preventDefault();
                    dismissClipboard();
                };
            }
        }
        
        // ============ ACCOUNT MODAL ============
        function openAccountModal() {
            const sheet = document.getElementById('account-sheet');
            const content = document.getElementById('modal-content');
            
            if (currentUser) {
                const initial = (currentUser.displayName || currentUser.email || '?')[0].toUpperCase();
                content.innerHTML = `
                    <div class="account-info">
                        <div class="account-avatar">${escapeHtml(initial)}</div>
                        <div class="account-name">${escapeHtml(currentUser.displayName || 'Player')}</div>
                        <div class="account-email">${escapeHtml(currentUser.email)}</div>
                        <div class="sync-status">â˜ï¸ Synced</div>
                        <button class="signout-btn" onclick="signOut()">Sign Out</button>
                    </div>
                `;
            } else {
                content.innerHTML = `
                    <div style="text-align: center; padding: 20px 0;">
                        <div style="font-size: 1.1rem; font-weight: 600; margin-bottom: 8px;">Sign In</div>
                        <div style="color: var(--text-muted); font-size: 0.9rem; margin-bottom: 20px;">Sync your progress across devices</div>
                        <button class="google-btn" onclick="signInWithGoogle()">
                            <svg width="20" height="20" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>
                            Continue with Google
                        </button>
                        <button style="margin-top: 12px; background: none; border: none; color: var(--text-muted); cursor: pointer; padding: 8px;" onclick="closeAccountModal()">Maybe later</button>
                    </div>
                `;
            }
            
            sheet.classList.add('active');
        }
        
        function closeAccountModal() {
            document.getElementById('account-sheet').classList.remove('active');
        }
        
        // ============ SHEET MANAGER (Consolidated open/close) ============
        const SheetManager = {
            open(sheetId) {
                const sheet = document.getElementById(sheetId);
                if (sheet) sheet.classList.add('active');
            },
            close(sheetId) {
                const sheet = document.getElementById(sheetId);
                if (sheet) sheet.classList.remove('active');
            },
            toggle(sheetId) {
                const sheet = document.getElementById(sheetId);
                if (sheet) sheet.classList.toggle('active');
            },
            isOpen(sheetId) {
                const sheet = document.getElementById(sheetId);
                return sheet?.classList.contains('active') || false;
            }
        };
        
        // ============ TOAST ============
        function showToast(message, type = '') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast visible ' + type;
            
            // Play sounds for certain toast types
            if (type === 'error') {
                playSound('error');
            } else if (message.includes('coins') || message.includes('ðŸª™')) {
                playSound('coin');
            }
            
            setTimeout(() => toast.classList.remove('visible'), 2500);
        }
        
        // ============ PWA / SERVICE WORKER ============
        if ('serviceWorker' in navigator) {
            // Register service worker with cache bypass for faster updates
            navigator.serviceWorker.register('sw.js', { updateViaCache: 'none' })
                .then(reg => {
                    console.log('SW registered');
                    
                    // Check for updates every 5 minutes
                    setInterval(() => {
                        reg.update();
                    }, 5 * 60 * 1000);
                    
                    // Handle waiting service worker
                    reg.addEventListener('updatefound', () => {
                        const newWorker = reg.installing;
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                // New version available
                                console.log('New version available!');
                                showUpdateToast();
                            }
                        });
                    });
                })
                .catch(e => console.log('SW registration failed:', e));
            
            // Listen for messages from service worker
            navigator.serviceWorker.addEventListener('message', (event) => {
                if (event.data.type === 'SW_UPDATED') {
                    console.log('SW updated to:', event.data.version);
                    // Auto-reload to get new version
                    window.location.reload();
                }
            });
            
            // Handle controller change (new SW took over)
            navigator.serviceWorker.addEventListener('controllerchange', () => {
                console.log('New service worker activated');
                window.location.reload();
            });
        }
        
        function showUpdateToast() {
            // Show a toast prompting refresh
            const toast = document.createElement('div');
            toast.innerHTML = `
                <div style="position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); 
                    background: var(--accent-purple); color: white; padding: 12px 20px; 
                    border-radius: 12px; z-index: 9999; display: flex; align-items: center; gap: 12px;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                    <span>ðŸ”„ Update available!</span>
                    <button onclick="window.location.reload()" style="background: white; color: var(--accent-purple); 
                        border: none; padding: 6px 12px; border-radius: 6px; font-weight: 600; cursor: pointer;">
                        Refresh
                    </button>
                </div>
            `;
            document.body.appendChild(toast);
        }
        
        // Force refresh function (can be called from console)
        // Force update check (called from Settings)
        function forceAppUpdate() {
            showToast('ðŸ”„ Checking for updates...', 'info');
            
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistration().then(reg => {
                    if (reg) {
                        // Force SW to check for updates
                        reg.update().then(() => {
                            console.log('SW update check triggered');
                            
                            // Check if there's a waiting worker
                            if (reg.waiting) {
                                // Tell it to skip waiting and take over
                                reg.waiting.postMessage('SKIP_WAITING');
                                showToast('âœ… Update installing...', 'success');
                            } else if (reg.installing) {
                                showToast('â³ Update downloading...', 'info');
                            } else {
                                // No update found, do a hard reload anyway to be sure
                                showToast('âœ… Already on latest version! Reloading...', 'success');
                                setTimeout(() => {
                                    window.location.reload(true);
                                }, 1000);
                            }
                        }).catch(err => {
                            console.error('Update check failed:', err);
                            showToast('âš ï¸ Update check failed, forcing refresh...', 'warning');
                            setTimeout(() => window.forceRefresh(), 1000);
                        });
                    } else {
                        // No SW registered, just reload
                        window.location.reload(true);
                    }
                }).catch(err => {
                    console.error('getRegistration failed:', err);
                    window.location.reload(true);
                });
            } else {
                window.location.reload(true);
            }
        }
        
        window.forceRefresh = function() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistrations().then(registrations => {
                    registrations.forEach(reg => reg.unregister());
                }).then(() => {
                    return caches.keys();
                }).then(names => {
                    return Promise.all(names.map(name => caches.delete(name)));
                }).then(() => {
                    window.location.reload(true);
                }).catch(e => {
                    console.error('Force refresh error:', e);
                    window.location.reload(true);
                });
            } else {
                window.location.reload(true);
            }
        };
        
        // ============ INSTALL BANNER ============
        function isStandalone() {
            return window.matchMedia('(display-mode: standalone)').matches ||
                   window.navigator.standalone === true;
        }
        
        function isIOS() {
            return /iPad|iPhone|iPod/.test(navigator.userAgent);
        }
        
        function showInstallBanner() {
            console.log('showInstallBanner called');
            console.log('  isStandalone:', isStandalone());
            console.log('  isIOS:', isIOS());
            
            // Don't show if already installed
            if (isStandalone()) {
                console.log('Already installed - skipping banner');
                return;
            }
            
            // Don't show if dismissed in last 24 hours
            const dismissed = localStorage.getItem('installBannerDismissed');
            const dismissedAgo = dismissed ? (Date.now() - parseInt(dismissed)) : null;
            console.log('  dismissed:', dismissed, 'ago (hrs):', dismissedAgo ? (dismissedAgo / 3600000).toFixed(1) : 'never');
            
            if (dismissed && dismissedAgo < 24 * 60 * 60 * 1000) {
                console.log('Banner dismissed recently - skipping');
                return;
            }
            
            const banner = document.getElementById('install-banner');
            const desc = document.getElementById('install-desc');
            const icon = document.getElementById('install-icon');
            const arrow = document.getElementById('install-arrow');
            
            if (isIOS()) {
                // iOS: Point user to Safari's share button (cannot trigger programmatically)
                icon.textContent = 'ðŸ“±';
                desc.innerHTML = 'Tap Safari\'s <span style="font-size: 1.2em;">â¬†</span> share button below, then "Add to Home Screen"';
                // Show arrow pointing down to Safari toolbar
                if (arrow) {
                    arrow.style.display = 'flex';
                }
            } else if (window.deferredPrompt) {
                // Chrome/Android: Can trigger install prompt
                icon.textContent = 'ðŸ“²';
                desc.innerHTML = 'Tap to install the app';
                if (arrow) arrow.style.display = 'none';
            } else {
                // Other browsers
                icon.textContent = 'ðŸ“²';
                desc.innerHTML = 'Use browser menu â†’ "Add to Home Screen"';
                if (arrow) arrow.style.display = 'none';
            }
            
            console.log('Showing install banner');
            banner.classList.add('visible');
        }
        
        function dismissInstallBanner(event) {
            if (event) {
                event.stopPropagation();
            }
            document.getElementById('install-banner').classList.remove('visible');
            localStorage.setItem('installBannerDismissed', Date.now().toString());
        }
        
        // Trigger native install/share dialog
        function triggerInstall() {
            // For Chrome/Android with beforeinstallprompt
            if (window.deferredPrompt) {
                window.deferredPrompt.prompt();
                window.deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        showToast('Installing...');
                        dismissInstallBanner();
                    }
                    window.deferredPrompt = null;
                });
                return;
            }
            
            // For iOS Safari - CANNOT programmatically trigger "Add to Home Screen"
            // navigator.share() opens a DIFFERENT share sheet (for sharing content)
            // We must instruct user to tap Safari's share button manually
            if (isIOS()) {
                // Show helpful toast with instructions
                showToast('Tap the share button â†‘ in Safari toolbar, then scroll down and tap "Add to Home Screen"', 'info', 5000);
                
                // Pulse the arrow hint if visible
                const arrow = document.getElementById('install-arrow');
                if (arrow) {
                    arrow.style.display = 'flex';
                    arrow.style.animation = 'pulse 0.5s ease-in-out 3';
                    setTimeout(() => {
                        arrow.style.animation = '';
                    }, 1500);
                }
                return;
            }
            
            // For other browsers without beforeinstallprompt
            showToast('Use your browser menu to "Add to Home Screen" or "Install App"');
        }
        
        // Capture beforeinstallprompt for Chrome/Android
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            window.deferredPrompt = e;
            showInstallBanner();
        });
        
        // Handle share target (when app receives shared text)
        function handleShareTarget() {
            const params = new URLSearchParams(window.location.search);
            
            if (params.get('share-target') === 'true') {
                // Get shared text from URL params (GET method)
                const sharedText = params.get('text') || params.get('title') || '';
                const sharedUrl = params.get('url') || '';
                const combinedText = [sharedText, sharedUrl].filter(Boolean).join('\n');
                
                console.log('ðŸ“¤ Share target received:', combinedText.substring(0, 100));
                
                if (combinedText) {
                    // Try to parse the shared text
                    const result = parseShareText(combinedText);
                    
                    if (result) {
                        const todayHistory = getTodayHistory();
                        
                        // Check if already logged
                        if (todayHistory[result.gameId]) {
                            showToast(`${GAMES[result.gameId]?.icon || 'ðŸŽ®'} Already logged today!`, 'info');
                            renderAll(); // Ensure UI shows the logged game
                        } else {
                            const game = GAMES[result.gameId];
                            
                            // AUTO-LOG: If enabled, log automatically from share target
                            if (appData.settings?.autoLog !== false) {
                                autoLogClipboard(game, result);
                            } else {
                                // Fallback to confirmation modal
                                detectedClipboard = { text: combinedText, result };
                                showShareTargetConfirmation(game, result);
                            }
                        }
                    } else {
                        // Couldn't parse - open log sheet with text pre-filled
                        setTimeout(() => {
                            openLogSheet();
                            const textarea = document.querySelector('#log-sheet textarea');
                            if (textarea) {
                                textarea.value = combinedText;
                                textarea.dispatchEvent(new Event('input', { bubbles: true }));
                            }
                        }, 500);
                    }
                } else {
                    // No text - just open log sheet
                    setTimeout(openLogSheet, 500);
                }
                
                // Clean URL (remove query params)
                const cleanUrl = window.location.pathname + window.location.hash;
                window.history.replaceState({}, '', cleanUrl);
            }
            
            // Handle action=log shortcut
            if (params.get('action') === 'log') {
                setTimeout(openLogSheet, 300);
            }
            
            // Handle tab deep link: ?tab=home|share|settings
            const tabParam = params.get('tab');
            if (tabParam && ['home', 'share', 'settings'].includes(tabParam)) {
                setTimeout(() => switchTab(tabParam), 300);
                // Clean URL
                const cleanUrl = window.location.pathname + window.location.hash;
                window.history.replaceState({}, '', cleanUrl);
            }
            
            // Handle game launch deep link: ?game=wordle or ?play=wordle
            const gameParam = params.get('game') || params.get('play');
            if (gameParam) {
                const gameId = gameParam.toLowerCase();
                if (GAMES[gameId]) {
                    console.log(`ðŸ”— Deep link: launching ${gameId}`);
                    setTimeout(() => playGame(gameId), 500);
                } else {
                    console.warn(`ðŸ”— Deep link: unknown game ${gameId}`);
                    showToast(`Unknown game: ${gameParam}`, 'error');
                }
                // Clean URL
                const cleanUrl = window.location.pathname + window.location.hash;
                window.history.replaceState({}, '', cleanUrl);
            }
            
            // Log PWA launch for analytics (if standalone mode)
            if (isStandalone()) {
                console.log('ðŸš€ Launched as PWA (standalone mode)');
            }
        }
        
        // Show confirmation modal for share target
        function showShareTargetConfirmation(game, result) {
            // Create modal if doesn't exist
            let modal = document.getElementById('share-target-modal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'share-target-modal';
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content" style="text-align: center; padding: 32px;">
                        <div id="st-icon" style="font-size: 64px; margin-bottom: 16px;">ðŸŽ®</div>
                        <div id="st-title" style="font-size: 1.5rem; font-weight: bold; margin-bottom: 8px;">Game Result Found!</div>
                        <div id="st-score" style="font-size: 1.2rem; color: var(--text-muted); margin-bottom: 24px;"></div>
                        <div style="display: flex; gap: 12px; justify-content: center;">
                            <button onclick="dismissShareTarget()" style="padding: 12px 24px; border-radius: 8px; background: var(--bg-tertiary); border: none; color: var(--text-secondary); font-size: 1rem; cursor: pointer;">Cancel</button>
                            <button onclick="acceptShareTarget()" style="padding: 12px 24px; border-radius: 8px; background: var(--accent-green); border: none; color: white; font-size: 1rem; font-weight: bold; cursor: pointer;">Log Game âœ“</button>
                        </div>
                    </div>
                `;
                modal.onclick = (e) => { if (e.target === modal) dismissShareTarget(); };
                document.body.appendChild(modal);
            }
            
            // Update content
            document.getElementById('st-icon').textContent = game?.icon || 'ðŸŽ®';
            document.getElementById('st-title').textContent = `Log ${game?.name || 'Game'}?`;
            document.getElementById('st-score').textContent = `Score: ${result.score}`;
            
            // Show modal
            modal.classList.add('active');
            
            // Play sound
            playSound('success');
        }
        
        function acceptShareTarget() {
            if (detectedClipboard) {
                if (logGame(detectedClipboard.result, 'prompt')) {
                    const game = GAMES[detectedClipboard.result.gameId];
                    renderAll();
                    showSuccessModal(game, detectedClipboard.result);
                }
            }
            dismissShareTarget();
        }
        
        function dismissShareTarget() {
            const modal = document.getElementById('share-target-modal');
            if (modal) modal.classList.remove('active');
            detectedClipboard = null;
        }
        
        // ============ SETUP FLOW ============
        const SETUP_GAMES = {
            // ===== NYT Games (6) =====
            wordle: { 
                name: 'Wordle', icon: 'ðŸŸ©', publisher: 'NYT',
                statsScreen: 'Tap ðŸ“Š after completing puzzle',
                urls: {
                    browser: { direct: 'https://www.nytimes.com/games/wordle', hub: 'https://www.nytimes.com/games' },
                    app: { direct: 'nytimes://games/wordle', hub: 'nytimes://games' }
                }
            },
            connections: { 
                name: 'Connections', icon: 'ðŸ”—', publisher: 'NYT',
                statsScreen: 'Tap "View Stats" after solving',
                urls: {
                    browser: { direct: 'https://www.nytimes.com/games/connections', hub: 'https://www.nytimes.com/games' },
                    app: { direct: 'nytimes://games/connections', hub: 'nytimes://games' }
                }
            },
            strands: { 
                name: 'Strands', icon: 'ðŸ§µ', publisher: 'NYT',
                statsScreen: 'Results screen after completing',
                urls: {
                    browser: { direct: 'https://www.nytimes.com/games/strands', hub: 'https://www.nytimes.com/games' },
                    app: { direct: 'nytimes://games/strands', hub: 'nytimes://games' }
                }
            },
            mini: { 
                name: 'Mini Crossword', icon: 'ðŸ“', publisher: 'NYT',
                statsScreen: 'Completion time after solving',
                urls: {
                    browser: { direct: 'https://www.nytimes.com/crosswords/game/mini', hub: 'https://www.nytimes.com/games' },
                    app: { direct: 'nytimes://crosswords/game/mini', hub: 'nytimes://games' }
                }
            },
            'spelling-bee': { 
                name: 'Spelling Bee', icon: 'ðŸ', publisher: 'NYT',
                statsScreen: 'Shows rank (Genius, Queen Bee)',
                urls: {
                    browser: { direct: 'https://www.nytimes.com/puzzles/spelling-bee', hub: 'https://www.nytimes.com/games' },
                    app: { direct: 'nytimes://puzzles/spelling-bee', hub: 'nytimes://games' }
                }
            },
            letterboxed: { 
                name: 'Letterboxed', icon: 'ðŸ“¦', publisher: 'NYT',
                statsScreen: 'Results after solving',
                urls: {
                    browser: { direct: 'https://www.nytimes.com/puzzles/letter-boxed', hub: 'https://www.nytimes.com/games' },
                    app: { direct: 'nytimes://puzzles/letter-boxed', hub: 'nytimes://games' }
                }
            },
            
            // ===== LinkedIn Games (5) =====
            queens: { 
                name: 'Queens', icon: 'ðŸ‘‘', publisher: 'LinkedIn',
                statsScreen: 'Results after completing',
                urls: {
                    browser: { direct: 'https://www.linkedin.com/games/queens', hub: 'https://www.linkedin.com/games' },
                    app: { direct: 'linkedin://games/queens', hub: 'linkedin://games' }
                }
            },
            tango: { 
                name: 'Tango', icon: 'ðŸ’ƒ', publisher: 'LinkedIn',
                statsScreen: 'Results after completing',
                urls: {
                    browser: { direct: 'https://www.linkedin.com/games/tango', hub: 'https://www.linkedin.com/games' },
                    app: { direct: 'linkedin://games/tango', hub: 'linkedin://games' }
                }
            },
            pinpoint: { 
                name: 'Pinpoint', icon: 'ðŸ“', publisher: 'LinkedIn',
                statsScreen: 'Shows clues used',
                urls: {
                    browser: { direct: 'https://www.linkedin.com/games/pinpoint', hub: 'https://www.linkedin.com/games' },
                    app: { direct: 'linkedin://games/pinpoint', hub: 'linkedin://games' }
                }
            },
            crossclimb: { 
                name: 'Crossclimb', icon: 'ðŸ§—', publisher: 'LinkedIn',
                statsScreen: 'Time after completing',
                urls: {
                    browser: { direct: 'https://www.linkedin.com/games/crossclimb', hub: 'https://www.linkedin.com/games' },
                    app: { direct: 'linkedin://games/crossclimb', hub: 'linkedin://games' }
                }
            },
            zip: { 
                name: 'Zip', icon: 'âš¡', publisher: 'LinkedIn',
                statsScreen: 'Results after completing',
                urls: {
                    browser: { direct: 'https://www.linkedin.com/games/zip', hub: 'https://www.linkedin.com/games' },
                    app: { direct: 'linkedin://games/zip', hub: 'linkedin://games' }
                }
            },
            
            // ===== Word Games (6) =====
            quordle: { 
                name: 'Quordle', icon: '4ï¸âƒ£', publisher: 'Word Games',
                statsScreen: 'Results grid after all 4 words',
                urls: {
                    browser: { direct: 'https://www.quordle.com', hub: 'https://www.quordle.com' },
                    app: { direct: 'https://www.quordle.com', hub: 'https://www.quordle.com' }
                }
            },
            octordle: { 
                name: 'Octordle', icon: '8ï¸âƒ£', publisher: 'Word Games',
                statsScreen: 'Results after all 8 words',
                urls: {
                    browser: { direct: 'https://octordle.com', hub: 'https://octordle.com' },
                    app: { direct: 'https://octordle.com', hub: 'https://octordle.com' }
                }
            },
            waffle: { 
                name: 'Waffle', icon: 'ðŸ§‡', publisher: 'Word Games',
                statsScreen: 'Stars earned after solving',
                urls: {
                    browser: { direct: 'https://wafflegame.net', hub: 'https://wafflegame.net' },
                    app: { direct: 'https://wafflegame.net', hub: 'https://wafflegame.net' }
                }
            },
            redactle: { 
                name: 'Redactle', icon: 'â–ˆ', publisher: 'Word Games',
                statsScreen: 'Guesses to reveal article',
                urls: {
                    browser: { direct: 'https://redactle.net', hub: 'https://redactle.net' },
                    app: { direct: 'https://redactle.net', hub: 'https://redactle.net' }
                }
            },
            semantle: { 
                name: 'Semantle', icon: 'ðŸ§ ', publisher: 'Word Games',
                statsScreen: 'Guesses to find word',
                urls: {
                    browser: { direct: 'https://semantle.com', hub: 'https://semantle.com' },
                    app: { direct: 'https://semantle.com', hub: 'https://semantle.com' }
                }
            },
            nerdle: { 
                name: 'Nerdle', icon: 'ðŸ§®', publisher: 'Word Games',
                statsScreen: 'Guesses to solve equation',
                urls: {
                    browser: { direct: 'https://nerdlegame.com', hub: 'https://nerdlegame.com' },
                    app: { direct: 'https://nerdlegame.com', hub: 'https://nerdlegame.com' }
                }
            },
            contexto: { 
                name: 'Contexto', icon: 'ðŸŽ¯', publisher: 'Word Games',
                statsScreen: 'Guesses to find word by context',
                urls: {
                    browser: { direct: 'https://contexto.me', hub: 'https://contexto.me' },
                    app: { direct: 'https://contexto.me', hub: 'https://contexto.me' }
                }
            },
            dordle: { 
                name: 'Dordle', icon: '2ï¸âƒ£', publisher: 'Word Games',
                statsScreen: 'Guesses for both words',
                urls: {
                    browser: { direct: 'https://zaratustra.itch.io/dordle', hub: 'https://zaratustra.itch.io/dordle' },
                    app: { direct: 'https://zaratustra.itch.io/dordle', hub: 'https://zaratustra.itch.io/dordle' }
                }
            },
            
            // ===== Geography Games (5) =====
            worldle: { 
                name: 'Worldle', icon: 'ðŸŒ', publisher: 'Geography',
                statsScreen: 'Guesses to identify country',
                urls: {
                    browser: { direct: 'https://worldle.teuteuf.fr', hub: 'https://worldle.teuteuf.fr' },
                    app: { direct: 'https://worldle.teuteuf.fr', hub: 'https://worldle.teuteuf.fr' }
                }
            },
            globle: { 
                name: 'Globle', icon: 'ðŸŒŽ', publisher: 'Geography',
                statsScreen: 'Guesses to find country',
                urls: {
                    browser: { direct: 'https://globle-game.com', hub: 'https://globle-game.com' },
                    app: { direct: 'https://globle-game.com', hub: 'https://globle-game.com' }
                }
            },
            tradle: { 
                name: 'Tradle', icon: 'ðŸš¢', publisher: 'Geography',
                statsScreen: 'Guesses to identify by exports',
                urls: {
                    browser: { direct: 'https://oec.world/en/tradle', hub: 'https://oec.world/en/tradle' },
                    app: { direct: 'https://oec.world/en/tradle', hub: 'https://oec.world/en/tradle' }
                }
            },
            wheretaken: { 
                name: 'WhereTaken', icon: 'ðŸ“¸', publisher: 'Geography',
                statsScreen: 'Guesses to locate photo',
                urls: {
                    browser: { direct: 'https://wheretaken.teuteuf.fr', hub: 'https://wheretaken.teuteuf.fr' },
                    app: { direct: 'https://wheretaken.teuteuf.fr', hub: 'https://wheretaken.teuteuf.fr' }
                }
            },
            foodguessr: { 
                name: 'FoodGuessr', icon: 'ðŸ•', publisher: 'Geography',
                statsScreen: 'Score after guessing dishes',
                urls: {
                    browser: { direct: 'https://www.foodguessr.com', hub: 'https://www.foodguessr.com' },
                    app: { direct: 'https://www.foodguessr.com', hub: 'https://www.foodguessr.com' }
                }
            },
            travle: { 
                name: 'Travle', icon: 'âœˆï¸', publisher: 'Geography',
                statsScreen: 'Countries to reach destination',
                urls: {
                    browser: { direct: 'https://travle.earth', hub: 'https://travle.earth' },
                    app: { direct: 'https://travle.earth', hub: 'https://travle.earth' }
                }
            },
            
            // ===== Entertainment Games (5) =====
            framed: { 
                name: 'Framed', icon: 'ðŸŽ¬', publisher: 'Entertainment',
                statsScreen: 'Frames needed to guess movie',
                urls: {
                    browser: { direct: 'https://framed.wtf', hub: 'https://framed.wtf' },
                    app: { direct: 'https://framed.wtf', hub: 'https://framed.wtf' }
                }
            },
            actorle: { 
                name: 'Actorle', icon: 'ðŸŽ­', publisher: 'Entertainment',
                statsScreen: 'Guesses to identify actor',
                urls: {
                    browser: { direct: 'https://actorle.com', hub: 'https://actorle.com' },
                    app: { direct: 'https://actorle.com', hub: 'https://actorle.com' }
                }
            },
            moviedle: { 
                name: 'Moviedle', icon: 'ðŸŽ¥', publisher: 'Entertainment',
                statsScreen: 'Speed to identify movie',
                urls: {
                    browser: { direct: 'https://moviedle.app', hub: 'https://moviedle.app' },
                    app: { direct: 'https://moviedle.app', hub: 'https://moviedle.app' }
                }
            },
            heardle: { 
                name: 'Heardle', icon: 'ðŸŽµ', publisher: 'Entertainment',
                statsScreen: 'Seconds to identify song',
                urls: {
                    browser: { direct: 'https://www.spotify.com/heardle', hub: 'https://www.spotify.com/heardle' },
                    app: { direct: 'https://www.spotify.com/heardle', hub: 'https://www.spotify.com/heardle' }
                }
            },
            bandle: { 
                name: 'Bandle', icon: 'ðŸŽ¸', publisher: 'Entertainment',
                statsScreen: 'Instruments to identify song',
                urls: {
                    browser: { direct: 'https://bandle.app', hub: 'https://bandle.app' },
                    app: { direct: 'https://bandle.app', hub: 'https://bandle.app' }
                }
            },
            
            // ===== Sports & Misc (5) =====
            'immaculate-grid': { 
                name: 'Immaculate Grid', icon: 'âš¾', publisher: 'Sports',
                statsScreen: 'Rarity score after completing',
                urls: {
                    browser: { direct: 'https://www.immaculategrid.com', hub: 'https://www.immaculategrid.com' },
                    app: { direct: 'https://www.immaculategrid.com', hub: 'https://www.immaculategrid.com' }
                }
            },
            costcodle: { 
                name: 'Costcodle', icon: 'ðŸ›’', publisher: 'Sports',
                statsScreen: 'Guesses to find price',
                urls: {
                    browser: { direct: 'https://costcodle.com', hub: 'https://costcodle.com' },
                    app: { direct: 'https://costcodle.com', hub: 'https://costcodle.com' }
                }
            },
            
            // ===== Game Shelf Originals (4) =====
            quotle: { 
                name: 'Quotle', icon: 'ðŸ’¬', publisher: 'Game Shelf',
                statsScreen: 'Stats after completing',
                urls: {
                    browser: { direct: 'https://stewartdavidp-ship-it.github.io/Quotle/', hub: 'https://stewartdavidp-ship-it.github.io/Quotle/' },
                    app: { direct: 'https://stewartdavidp-ship-it.github.io/Quotle/', hub: 'https://stewartdavidp-ship-it.github.io/Quotle/' }
                }
            },
            slate: { 
                name: 'Slate', icon: 'ðŸ“', publisher: 'Game Shelf',
                statsScreen: 'Stats after completing',
                urls: {
                    browser: { direct: 'https://stewartdavidp-ship-it.github.io/Slate/', hub: 'https://stewartdavidp-ship-it.github.io/Slate/' },
                    app: { direct: 'https://stewartdavidp-ship-it.github.io/Slate/', hub: 'https://stewartdavidp-ship-it.github.io/Slate/' }
                }
            },
            rungs: { 
                name: 'Rungs', icon: 'ðŸªœ', publisher: 'Game Shelf',
                statsScreen: 'Steps to complete ladder',
                urls: {
                    browser: { direct: 'https://stewartdavidp-ship-it.github.io/Rungstest/', hub: 'https://stewartdavidp-ship-it.github.io/Rungstest/' },
                    app: { direct: 'https://stewartdavidp-ship-it.github.io/Rungstest/', hub: 'https://stewartdavidp-ship-it.github.io/Rungstest/' }
                }
            },
            wordboxing: { 
                name: 'Word Boxing', icon: 'ðŸ¥Š', publisher: 'Game Shelf',
                statsScreen: 'Match results',
                urls: {
                    browser: { direct: 'https://stewartdavidp-ship-it.github.io/WordBoxing/', hub: 'https://stewartdavidp-ship-it.github.io/WordBoxing/' },
                    app: { direct: 'https://stewartdavidp-ship-it.github.io/WordBoxing/', hub: 'https://stewartdavidp-ship-it.github.io/WordBoxing/' }
                }
            }
        };
        
        const SETUP_PUBLISHERS = {
            'NYT': { name: 'New York Times', icon: 'ðŸ“°', hasSubscription: true },
            'LinkedIn': { name: 'LinkedIn', icon: 'ðŸ’¼', hasSubscription: false },
            'Word Games': { name: 'Word Games', icon: 'ðŸ”¤', hasSubscription: false },
            'Geography': { name: 'Geography', icon: 'ðŸŒ', hasSubscription: false },
            'Entertainment': { name: 'Entertainment', icon: 'ðŸŽ¬', hasSubscription: false },
            'Sports': { name: 'Sports & Misc', icon: 'âš¾', hasSubscription: false },
            'Game Shelf': { name: 'Game Shelf Originals', icon: 'ðŸŽ®', hasSubscription: false }
        };
        
        const SETUP_SOCIALS = [
            { id: 'imessage', name: 'iMessage', icon: 'ðŸ’¬' },
            { id: 'twitter', name: 'X', icon: 'ð•' },
            { id: 'threads', name: 'Threads', icon: 'ðŸ§µ' },
            { id: 'facebook', name: 'Facebook', icon: 'ðŸ“˜' },
            { id: 'discord', name: 'Discord', icon: 'ðŸŽ®' },
            { id: 'slack', name: 'Slack', icon: 'ðŸ’¼' },
            { id: 'whatsapp', name: 'WhatsApp', icon: 'ðŸ’š' },
            { id: 'other', name: 'Other', icon: 'âž•' }
        ];
        
        const SETUP_STAT_PATTERNS = {
            played: [
                /([\d,]+)\s*\n?\s*played/i,
                /played\s*\n?\s*([\d,]+)/i,
                /([\d,]+)\s+games?\s+played/i
            ],
            winPercent: [
                /([\d,]+)\s*\n?\s*win\s*%/i,
                /win\s*%?\s*\n?\s*([\d,]+)/i,
                /([\d]+)\s*%/i
            ],
            streak: [
                /([\d,]+)\s*\n?\s*current\s*\n?\s*streak/i,
                /current\s*\n?\s*streak\s*\n?\s*([\d,]+)/i,
                /([\d]+)\s*day\s*streak/i
            ],
            maxStreak: [
                /([\d,]+)\s*\n?\s*max\s*\n?\s*streak/i,
                /max\s*\n?\s*streak\s*\n?\s*([\d,]+)/i
            ]
        };
        
        // Setup State
        let setupSelectedGames = new Set();
        let setupPublisherConfig = {};
        let setupGameConfigs = [];
        let setupScreenshotQueue = [];
        let setupCurrentScreenshotIndex = 0;
        let setupCurrentImage = null;
        let setupCurrentStats = {};
        let setupSharingMethods = new Set();
        let setupSocialPlatforms = new Set();
        let setupLaunchFeedbackData = {};
        let setupConfirmedPublishers = new Set();
        let setupPendingPublisherConfirm = null;
        
        function isSetupComplete() {
            return localStorage.getItem('gameshelf_setup_complete') === 'true';
        }
        
        function startSetupFlow() {
            // Reset setup state
            setupSelectedGames = new Set();
            setupPublisherConfig = {};
            setupGameConfigs = [];
            setupScreenshotQueue = [];
            setupCurrentScreenshotIndex = 0;
            setupCurrentImage = null;
            setupCurrentStats = {};
            setupSharingMethods = new Set();
            setupSocialPlatforms = new Set();
            setupLaunchFeedbackData = {};
            setupConfirmedPublishers = new Set();
            setupPendingPublisherConfirm = null;
            
            // Only pre-select current games if RECONFIGURING (setup was previously completed)
            // Don't pre-select for fresh users - let them choose
            const isReconfiguring = localStorage.getItem('gameshelf_setup_complete') === 'true';
            if (isReconfiguring && appData && appData.games && appData.games.length > 0) {
                appData.games.forEach(g => {
                    if (SETUP_GAMES[g.id]) {
                        setupSelectedGames.add(g.id);
                    }
                });
            }
            
            // Render grids
            setupRenderGameGrid();
            setupRenderSocialGrid();
            
            // Show setup container
            document.getElementById('setup-container').classList.add('active');
            setupGoToScreen('setup-welcome');
        }
        
        function setupRenderGameGrid() {
            const grid = document.getElementById('setup-game-grid');
            
            // Group games by publisher
            const byPublisher = {};
            Object.entries(SETUP_GAMES).forEach(([id, g]) => {
                if (!byPublisher[g.publisher]) byPublisher[g.publisher] = [];
                byPublisher[g.publisher].push({ id, ...g });
            });
            
            // Define display order - Game Shelf Originals right after NYT (best auto-sync UX)
            const publisherOrder = ['NYT', 'Game Shelf', 'LinkedIn', 'Word Games', 'Geography', 'Entertainment', 'Sports'];
            
            let html = '';
            publisherOrder.forEach(pub => {
                const games = byPublisher[pub];
                if (!games) return;
                
                const pubInfo = SETUP_PUBLISHERS[pub];
                const gameIds = games.map(g => g.id).join(',');
                html += `<div class="setup-section-header">
                    <div class="setup-section-title">${pubInfo.icon} ${pubInfo.name}</div>
                    <div class="setup-select-all" onclick="setupToggleCategory('${gameIds}', this)">Select All</div>
                </div>`;
                html += `<div class="setup-game-grid-inner" data-category="${pub}">`;
                html += games.map(g => `
                    <div class="setup-game-btn${setupSelectedGames.has(g.id) ? ' selected' : ''}" data-game="${g.id}" onclick="setupToggleGame('${g.id}', this)">
                        <div class="icon">${g.icon}</div>
                        <div class="name">${g.name}</div>
                        <div class="check">âœ“</div>
                    </div>
                `).join('');
                html += `</div>`;
            });
            
            grid.innerHTML = html;
            setupUpdateNextButton();
            setupUpdateSelectAllButtons();
        }
        
        function setupToggleCategory(gameIdsStr, selectAllEl) {
            const gameIds = gameIdsStr.split(',');
            const allSelected = gameIds.every(id => setupSelectedGames.has(id));
            
            // Find the grid for this category
            const grid = selectAllEl.closest('.setup-section-header').nextElementSibling;
            
            gameIds.forEach(id => {
                if (allSelected) {
                    setupSelectedGames.delete(id);
                } else {
                    setupSelectedGames.add(id);
                }
                // Update individual button UI
                const btn = grid.querySelector(`[data-game="${id}"]`);
                if (btn) {
                    btn.classList.toggle('selected', !allSelected);
                }
            });
            
            setupUpdateNextButton();
            setupUpdateSelectAllButtons();
        }
        
        function setupUpdateSelectAllButtons() {
            document.querySelectorAll('.setup-section-header').forEach(header => {
                const selectAllEl = header.querySelector('.setup-select-all');
                const grid = header.nextElementSibling;
                if (!selectAllEl || !grid) return;
                
                const buttons = grid.querySelectorAll('.setup-game-btn');
                const allSelected = Array.from(buttons).every(btn => btn.classList.contains('selected'));
                selectAllEl.textContent = allSelected ? 'Deselect All' : 'Select All';
            });
        }
        
        function setupRenderSocialGrid() {
            document.getElementById('setup-social-grid').innerHTML = SETUP_SOCIALS.map(s => `
                <div class="setup-social-btn" data-social="${s.id}" onclick="setupToggleSocial('${s.id}', this)">
                    <div class="icon">${s.icon}</div>
                    <div class="name">${s.name}</div>
                </div>
            `).join('');
        }
        
        function setupGoToScreen(id) {
            document.querySelectorAll('.setup-screen').forEach(s => s.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }
        
        function setupToggleGame(gameId, el) {
            el.classList.toggle('selected');
            if (el.classList.contains('selected')) {
                setupSelectedGames.add(gameId);
            } else {
                setupSelectedGames.delete(gameId);
            }
            setupUpdateNextButton();
            setupUpdateSelectAllButtons();
        }
        
        function setupUpdateNextButton() {
            const btn = document.getElementById('setup-btn-games-next');
            btn.disabled = setupSelectedGames.size === 0;
        }
        
        function setupGoToAccessConfig() {
            // Group selected games by publisher
            const byPublisher = {};
            setupSelectedGames.forEach(gameId => {
                const pub = SETUP_GAMES[gameId].publisher;
                if (!byPublisher[pub]) byPublisher[pub] = [];
                byPublisher[pub].push(gameId);
            });
            
            // Initialize config with defaults
            Object.keys(byPublisher).forEach(pub => {
                setupPublisherConfig[pub] = {
                    platform: 'browser',
                    launchType: 'hub',
                    subscription: pub === 'NYT' ? null : undefined
                };
            });
            
            // Render publisher config cards
            const container = document.getElementById('setup-publisher-config');
            container.innerHTML = Object.entries(byPublisher).map(([pub, gameIds]) => {
                const pubInfo = SETUP_PUBLISHERS[pub];
                const gameIcons = gameIds.map(id => SETUP_GAMES[id].icon).join(' ');
                
                let html = `
                    <div class="setup-publisher-card" data-publisher="${pub}">
                        <div class="setup-publisher-header">
                            <span class="icon">${pubInfo.icon}</span>
                            <span class="name">${pubInfo.name}</span>
                            <span class="count">${gameIcons}</span>
                        </div>
                        
                        <div class="setup-section-title">How do you play?</div>
                        <div class="setup-config-row">
                            <div class="setup-config-option selected" data-config="platform" data-value="browser" onclick="setupSetConfig('${pub}', 'platform', 'browser', this)">
                                ðŸŒ Browser
                            </div>
                            <div class="setup-config-option" data-config="platform" data-value="app" onclick="setupSetConfig('${pub}', 'platform', 'app', this)">
                                ðŸ“± App
                            </div>
                        </div>
                        
                        <div class="setup-section-title">Launch preference</div>
                        <div class="setup-config-row">
                            <div class="setup-config-option selected" data-config="launchType" data-value="hub" onclick="setupSetConfig('${pub}', 'launchType', 'hub', this)">
                                ðŸ  Games Hub
                            </div>
                            <div class="setup-config-option" data-config="launchType" data-value="direct" onclick="setupSetConfig('${pub}', 'launchType', 'direct', this)">
                                ðŸŽ¯ Direct Link
                            </div>
                        </div>
                `;
                
                if (pubInfo.hasSubscription) {
                    html += `
                        <div class="setup-section-title">Subscription</div>
                        <div class="setup-config-row">
                            <div class="setup-config-option" data-config="subscription" data-value="true" onclick="setupSetConfig('${pub}', 'subscription', true, this)">
                                âœ“ Subscriber
                            </div>
                            <div class="setup-config-option selected" data-config="subscription" data-value="false" onclick="setupSetConfig('${pub}', 'subscription', false, this)">
                                Free Only
                            </div>
                        </div>
                    `;
                }
                
                html += '</div>';
                return html;
            }).join('');
            
            setupGoToScreen('setup-access-config');
        }
        
        function setupSetConfig(publisher, configType, value, el) {
            setupPublisherConfig[publisher][configType] = value;
            const row = el.parentElement;
            row.querySelectorAll('.setup-config-option').forEach(opt => opt.classList.remove('selected'));
            el.classList.add('selected');
        }
        
        // NEW: Skip Configure Access and use smart defaults
        function setupSkipToEnhance() {
            // Use smart defaults for all publishers
            const SMART_DEFAULTS = {
                'NYT': { platform: 'browser', launchType: 'hub', subscription: false },
                'LinkedIn': { platform: 'browser', launchType: 'hub' },
                'Merriam-Webster': { platform: 'browser', launchType: 'direct' },
                'Apple': { platform: 'browser', launchType: 'direct' },
                'Game Shelf': { platform: 'browser', launchType: 'direct' }
            };
            
            // Build game configs using smart defaults
            setupGameConfigs = [];
            setupSelectedGames.forEach(gameId => {
                const game = SETUP_GAMES[gameId];
                if (!game) return; // Skip if game not found
                const defaults = SMART_DEFAULTS[game.publisher] || { platform: 'browser', launchType: 'hub' };
                const url = game.urls[defaults.platform]?.[defaults.launchType] || game.urls.browser?.hub || game.urls.browser?.direct;
                
                setupGameConfigs.push({
                    gameId,
                    name: game.name,
                    icon: game.icon,
                    publisher: game.publisher,
                    platform: defaults.platform,
                    launchType: defaults.launchType,
                    launchUrl: url,
                    customUrl: false,
                    urlVerified: false,
                    subscription: defaults.subscription,
                    stats: {},
                    usingSmartDefaults: true
                });
            });
            
            // Skip directly to complete (no sharing preferences screen)
            setupFinishAndShowComplete();
        }
        
        // NEW: Finish setup and show complete screen (simplified)
        function setupFinishAndShowComplete() {
            // Replace appData.games with only the selected games
            appData.games = setupGameConfigs.map(g => ({ 
                id: g.gameId, 
                addedAt: new Date().toISOString(),
                launchUrl: g.launchUrl 
            }));
            
            localStorage.setItem('gameshelf_setup_complete', 'true');
            saveData();
            
            // Update complete screen
            document.getElementById('setup-complete-summary').textContent = 
                `${setupGameConfigs.length} game${setupGameConfigs.length !== 1 ? 's' : ''} ready to track`;
            
            document.getElementById('setup-final-games-list').innerHTML = setupGameConfigs.map(g => `
                <div style="padding: 12px; background: var(--bg-tertiary); border-radius: 10px; margin-bottom: 8px; display: flex; align-items: center; gap: 12px;">
                    <span style="font-size: 1.5rem;">${g.icon}</span>
                    <span style="font-weight: 500;">${g.name}</span>
                </div>
            `).join('');
            
            setupGoToScreen('setup-complete');
        }
        
        // Skip everything (user clicked "Skip for now" on game selection)
        function setupSkipToComplete() {
            // If no games selected, add some defaults
            if (setupSelectedGames.size === 0) {
                setupSelectedGames.add('wordle');
                setupSelectedGames.add('connections');
            }
            
            // Use same logic as setupSkipToEnhance
            setupSkipToEnhance();
        }
        
        // Quick Start - pre-select common games and go straight to complete
        function setupQuickStart() {
            // Clear any existing selections
            setupSelectedGames.clear();
            
            // Add quick start games (NYT core + Game Shelf Originals)
            QUICK_START_GAMES.forEach(gameId => {
                if (SETUP_GAMES[gameId]) {
                    setupSelectedGames.add(gameId);
                }
            });
            
            // Use the existing flow which goes to complete with smart defaults
            setupSkipToEnhance();
        }
        
        function setupGoToEnhance() {
            // Build game configs from selections
            setupGameConfigs = [];
            setupSelectedGames.forEach(gameId => {
                const game = SETUP_GAMES[gameId];
                const pubConfig = setupPublisherConfig[game.publisher];
                const url = game.urls[pubConfig.platform][pubConfig.launchType];
                
                setupGameConfigs.push({
                    gameId,
                    name: game.name,
                    icon: game.icon,
                    publisher: game.publisher,
                    platform: pubConfig.platform,
                    launchType: pubConfig.launchType,
                    launchUrl: url,
                    customUrl: false,
                    urlVerified: false,
                    subscription: pubConfig.subscription,
                    stats: {}
                });
            });
            
            setupGoToScreen('setup-enhance');
        }
        
        function setupStartScreenshotFlow() {
            setupScreenshotQueue = [...setupGameConfigs];
            setupCurrentScreenshotIndex = 0;
            setupConfirmedPublishers = new Set();
            setupShowCurrentGameScreenshot();
        }
        
        function setupShowCurrentGameScreenshot() {
            if (setupCurrentScreenshotIndex >= setupScreenshotQueue.length) {
                setupGoToSharing();
                return;
            }
            
            const game = setupScreenshotQueue[setupCurrentScreenshotIndex];
            const gameData = SETUP_GAMES[game.gameId];
            
            document.getElementById('setup-screenshot-flow-title').textContent = `${game.icon} ${game.name}`;
            document.getElementById('setup-screenshot-flow-subtitle').textContent = 
                `Game ${setupCurrentScreenshotIndex + 1} of ${setupScreenshotQueue.length}`;
            
            document.getElementById('setup-screenshot-flow-content').innerHTML = `
                <div class="setup-screenshot-card">
                    <div class="setup-screenshot-card-header">
                        <span class="icon">${game.icon}</span>
                        <h3>${game.name}</h3>
                        <span class="status">${game.stats.streak ? 'Done âœ“' : 'Pending'}</span>
                    </div>
                    <div class="setup-screenshot-instructions">
                        <p><strong>To see your stats:</strong> ${gameData.statsScreen}</p>
                    </div>
                </div>
            `;
            
            document.getElementById('setup-screenshot-flow-actions').innerHTML = `
                <button class="setup-btn setup-btn-primary" onclick="setupLaunchGame()">
                    ðŸš€ Open ${game.name}
                </button>
                <div class="setup-back-link" onclick="setupSkipCurrentGame()">Skip this game</div>
            `;
            
            setupGoToScreen('setup-screenshot-flow');
        }
        
        function setupLaunchGame() {
            const game = setupScreenshotQueue[setupCurrentScreenshotIndex];
            const url = game.launchUrl;
            
            // Handle app URLs
            if (game.platform === 'app') {
                const gameData = SETUP_GAMES[game.gameId];
                game.fallbackUrl = gameData.urls.browser[game.launchType];
                
                setTimeout(() => {
                    if (document.hasFocus()) {
                        window.open(game.fallbackUrl, '_blank');
                    }
                }, 1500);
            }
            
            window.open(url, '_blank');
            
            document.getElementById('setup-feedback-title').textContent = `Did ${game.name} open?`;
            document.getElementById('setup-feedback-subtitle').textContent = `We tried: ${url}`;
            setupGoToScreen('setup-launch-feedback');
        }
        
        function setupLaunchFeedback(result) {
            const game = setupScreenshotQueue[setupCurrentScreenshotIndex];
            
            setupLaunchFeedbackData[game.gameId] = {
                result,
                url: game.launchUrl,
                platform: game.platform,
                launchType: game.launchType
            };
            
            if (result === 'success') {
                game.urlVerified = true;
                setupShowUploadScreen();
            } else if (result === 'wrong-screen') {
                if (game.platform === 'browser') {
                    setupShowCustomUrlScreen(game, 'wrong-screen');
                } else {
                    game.urlVerified = true;
                    setupShowUploadScreen();
                }
            } else {
                if (game.platform === 'browser') {
                    setupShowCustomUrlScreen(game, 'didnt-open');
                } else {
                    setupShowLaunchFailedScreen(game);
                }
            }
        }
        
        function setupShowCustomUrlScreen(game, reason) {
            document.getElementById('setup-custom-url-title').textContent = 
                reason === 'wrong-screen' 
                    ? `What URL opens ${game.name}?`
                    : `Enter your ${game.name} URL`;
            
            document.getElementById('setup-custom-url-subtitle').textContent = 
                reason === 'wrong-screen'
                    ? `The link opened the wrong page. What URL do you normally use?`
                    : `We couldn't open the game. What URL do you use to play?`;
            
            document.getElementById('setup-custom-url-input').value = game.launchUrl;
            
            const hint = document.getElementById('setup-custom-url-hint');
            if (game.publisher === 'LinkedIn') {
                hint.textContent = 'Tip: Open LinkedIn Games in Safari, navigate to ' + game.name + ', then copy the URL';
            } else if (game.publisher === 'NYT') {
                hint.textContent = 'Tip: Try https://www.nytimes.com/games or the direct game URL';
            } else {
                hint.textContent = 'Tip: Open the game in Safari, copy the URL from the address bar';
            }
            
            setupGoToScreen('setup-custom-url');
        }
        
        function setupTestCustomUrl() {
            const game = setupScreenshotQueue[setupCurrentScreenshotIndex];
            const customUrl = document.getElementById('setup-custom-url-input').value.trim();
            
            if (!customUrl) {
                alert('Please enter a URL');
                return;
            }
            
            game.launchUrl = customUrl;
            game.customUrl = true;
            
            window.open(customUrl, '_blank');
            
            document.getElementById('setup-feedback-title').textContent = `Did ${game.name} open correctly?`;
            document.getElementById('setup-feedback-subtitle').textContent = `We opened: ${customUrl}`;
            setupGoToScreen('setup-launch-feedback');
        }
        
        function setupUseCustomUrlAndContinue() {
            const game = setupScreenshotQueue[setupCurrentScreenshotIndex];
            const customUrl = document.getElementById('setup-custom-url-input').value.trim();
            
            if (customUrl) {
                game.launchUrl = customUrl;
                game.customUrl = true;
            }
            
            const configIndex = setupGameConfigs.findIndex(g => g.gameId === game.gameId);
            if (configIndex >= 0) {
                setupGameConfigs[configIndex].launchUrl = game.launchUrl;
                setupGameConfigs[configIndex].customUrl = game.customUrl;
            }
            
            setupShowUploadScreen();
        }
        
        function setupShowLaunchFailedScreen(game) {
            document.getElementById('setup-failed-title').textContent = `${game.name} didn't open`;
            document.getElementById('setup-failed-subtitle').textContent = `Let's try some alternatives`;
            
            const gameData = SETUP_GAMES[game.gameId];
            const isHub = game.launchType === 'hub';
            const isApp = game.platform === 'app';
            
            let optionsHtml = '';
            
            if (isApp) {
                const browserUrl = gameData.urls.browser[game.launchType];
                optionsHtml += `
                    <div class="setup-fix-option" onclick="setupTryAlternativeUrl('${browserUrl}', 'browser')">
                        <span class="icon">ðŸŒ</span>
                        <div class="text">
                            <h4>Try Browser Instead</h4>
                            <p>Open in Safari/Chrome</p>
                        </div>
                        <span class="arrow">â†’</span>
                    </div>
                `;
            }
            
            if (isHub) {
                const directUrl = gameData.urls[game.platform].direct;
                optionsHtml += `
                    <div class="setup-fix-option" onclick="setupTryAlternativeUrl('${directUrl}', null)">
                        <span class="icon">ðŸŽ¯</span>
                        <div class="text">
                            <h4>Try Direct Link</h4>
                            <p>Go straight to ${game.name}</p>
                        </div>
                        <span class="arrow">â†’</span>
                    </div>
                `;
            }
            
            if (isApp) {
                optionsHtml += `
                    <div class="setup-fix-option" onclick="setupSwitchToBrowserAndAskUrl()">
                        <span class="icon">âœï¸</span>
                        <div class="text">
                            <h4>I Use a Website</h4>
                            <p>Enter the URL I use instead</p>
                        </div>
                        <span class="arrow">â†’</span>
                    </div>
                `;
            }
            
            optionsHtml += `
                <div class="setup-fix-option" onclick="setupShowUploadScreen()">
                    <span class="icon">ðŸ“¸</span>
                    <div class="text">
                        <h4>I'll Open It Myself</h4>
                        <p>Skip to screenshot upload</p>
                    </div>
                    <span class="arrow">â†’</span>
                </div>
            `;
            
            document.getElementById('setup-failed-options').innerHTML = optionsHtml;
            setupGoToScreen('setup-launch-failed');
        }
        
        function setupSwitchToBrowserAndAskUrl() {
            const game = setupScreenshotQueue[setupCurrentScreenshotIndex];
            game.platform = 'browser';
            setupShowCustomUrlScreen(game, 'didnt-open');
        }
        
        function setupTryAlternativeUrl(url, newPlatform) {
            const game = setupScreenshotQueue[setupCurrentScreenshotIndex];
            game.launchUrl = url;
            if (newPlatform) game.platform = newPlatform;
            
            window.open(url, '_blank');
            
            document.getElementById('setup-feedback-title').textContent = `Did ${game.name} open?`;
            document.getElementById('setup-feedback-subtitle').textContent = `We tried: ${url}`;
            setupGoToScreen('setup-launch-feedback');
        }
        
        function setupShowUploadScreen() {
            const game = setupScreenshotQueue[setupCurrentScreenshotIndex];
            
            document.getElementById('setup-upload-title').textContent = `ðŸ“¸ Screenshot ${game.name}`;
            
            const uploadArea = document.getElementById('setup-upload-area');
            uploadArea.classList.remove('has-image');
            uploadArea.innerHTML = `
                <div class="icon">ðŸ“·</div>
                <p>Tap to upload screenshot</p>
            `;
            
            document.getElementById('setup-stats-result').style.display = 'none';
            document.getElementById('setup-btn-save-stats').disabled = true;
            setupCurrentImage = null;
            setupCurrentStats = {};
            
            setupGoToScreen('setup-upload');
        }
        
        async function setupHandleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                setupCurrentImage = e.target.result;
                
                const uploadArea = document.getElementById('setup-upload-area');
                uploadArea.classList.add('has-image');
                uploadArea.innerHTML = `<img src="${escapeAttr(setupCurrentImage)}" class="setup-upload-preview">`;
                
                setupGoToScreen('setup-analyzing');
                try {
                    const result = await Tesseract.recognize(setupCurrentImage, 'eng', {
                        logger: m => {
                            if (m.status === 'recognizing text') {
                                document.getElementById('setup-analyzing-status').textContent = 
                                    `Analyzing... ${Math.round(m.progress * 100)}%`;
                            }
                        }
                    });
                    
                    setupCurrentStats = setupExtractStats(result.data.text);
                    setupShowStatsResult();
                    setupGoToScreen('setup-upload');
                    
                } catch (err) {
                    console.error(err);
                    alert('Error analyzing. Try again or skip.');
                    setupGoToScreen('setup-upload');
                }
            };
            reader.readAsDataURL(file);
        }
        
        function setupExtractStats(text) {
            const stats = {};
            const normalizedText = text.replace(/\r\n/g, '\n').replace(/[ \t]+/g, ' ');
            console.log('OCR Text:', normalizedText);
            
            for (const [id, patterns] of Object.entries(SETUP_STAT_PATTERNS)) {
                for (const p of patterns) {
                    const m = normalizedText.match(p);
                    if (m?.[1]) { 
                        const value = m[1].replace(/,/g, '');
                        stats[id] = parseInt(value); 
                        console.log(`Found ${id}:`, stats[id]);
                        break; 
                    }
                }
            }
            
            if (Object.keys(stats).length < 4) {
                const numbers = normalizedText.match(/[\d,]+/g);
                if (numbers && numbers.length >= 4) {
                    console.log('Found numbers:', numbers);
                    const statsIndex = normalizedText.toLowerCase().indexOf('statistic');
                    if (statsIndex >= 0) {
                        const afterStats = normalizedText.slice(statsIndex);
                        const statsNumbers = afterStats.match(/[\d,]+/g);
                        if (statsNumbers && statsNumbers.length >= 4) {
                            if (!stats.played) stats.played = parseInt(statsNumbers[0].replace(/,/g, ''));
                            if (!stats.winPercent) stats.winPercent = parseInt(statsNumbers[1].replace(/,/g, ''));
                            if (!stats.streak) stats.streak = parseInt(statsNumbers[2].replace(/,/g, ''));
                            if (!stats.maxStreak) stats.maxStreak = parseInt(statsNumbers[3].replace(/,/g, ''));
                        }
                    }
                }
            }
            
            return stats;
        }
        
        function setupShowStatsResult() {
            const preview = document.getElementById('setup-stats-preview');
            const hasStats = Object.keys(setupCurrentStats).length > 0;
            
            if (hasStats) {
                preview.innerHTML = `
                    <div class="setup-stat-box">
                        <div class="value">${setupCurrentStats.played || '--'}</div>
                        <div class="label">Played</div>
                    </div>
                    <div class="setup-stat-box">
                        <div class="value">${setupCurrentStats.winPercent || '--'}%</div>
                        <div class="label">Win %</div>
                    </div>
                    <div class="setup-stat-box">
                        <div class="value">${setupCurrentStats.streak || '--'}</div>
                        <div class="label">Streak</div>
                    </div>
                    <div class="setup-stat-box">
                        <div class="value">${setupCurrentStats.maxStreak || '--'}</div>
                        <div class="label">Max Streak</div>
                    </div>
                `;
            } else {
                preview.innerHTML = `
                    <p style="text-align: center; color: var(--text-muted); padding: 16px;">
                        Couldn't find stats. You can still save the screenshot or try another.
                    </p>
                `;
            }
            
            document.getElementById('setup-stats-result').style.display = 'block';
            document.getElementById('setup-btn-save-stats').disabled = false;
        }
        
        function setupSaveStatsAndNext() {
            const game = setupScreenshotQueue[setupCurrentScreenshotIndex];
            
            const configIndex = setupGameConfigs.findIndex(g => g.gameId === game.gameId);
            if (configIndex >= 0) {
                setupGameConfigs[configIndex].stats = setupCurrentStats;
                setupGameConfigs[configIndex].urlVerified = true;
                setupGameConfigs[configIndex].launchUrl = game.launchUrl;
                setupGameConfigs[configIndex].platform = game.platform;
            }
            
            const publisher = game.publisher;
            const otherGamesInPublisher = setupScreenshotQueue.filter((g, i) => 
                g.publisher === publisher && i > setupCurrentScreenshotIndex
            );
            
            if (otherGamesInPublisher.length > 0 && !setupConfirmedPublishers.has(publisher)) {
                setupShowSameSettingsConfirmation(game, otherGamesInPublisher);
                return;
            }
            
            setupCurrentScreenshotIndex++;
            setupShowCurrentGameScreenshot();
        }
        
        function setupShowSameSettingsConfirmation(confirmedGame, otherGames) {
            setupPendingPublisherConfirm = confirmedGame.publisher;
            
            const pubInfo = SETUP_PUBLISHERS[confirmedGame.publisher];
            document.getElementById('setup-confirm-same-title').textContent = 
                `Same for other ${pubInfo.name} games?`;
            document.getElementById('setup-confirm-same-subtitle').textContent = 
                `You also selected ${otherGames.map(g => g.name).join(' and ')}`;
            
            document.getElementById('setup-confirmed-game-name').textContent = 
                `${confirmedGame.icon} ${confirmedGame.name} worked!`;
            
            const platformLabel = confirmedGame.platform === 'app' ? 'ðŸ“± App' : 'ðŸŒ Browser';
            const launchLabel = confirmedGame.launchType === 'hub' ? 'Hub' : 'Direct';
            document.getElementById('setup-confirmed-settings').textContent = 
                `${platformLabel} â†’ ${launchLabel}`;
            
            document.getElementById('setup-other-games-list').innerHTML = otherGames.map(g => `
                <span class="setup-mini-chip">${g.icon} ${g.name}</span>
            `).join('');
            
            setupGoToScreen('setup-confirm-same');
        }
        
        function setupConfirmSameSettings(useSame) {
            const publisher = setupPendingPublisherConfirm;
            const confirmedGame = setupScreenshotQueue[setupCurrentScreenshotIndex];
            
            if (useSame) {
                setupConfirmedPublishers.add(publisher);
                
                setupScreenshotQueue.forEach((game, i) => {
                    if (game.publisher === publisher && i > setupCurrentScreenshotIndex) {
                        game.launchUrl = confirmedGame.launchUrl;
                        game.platform = confirmedGame.platform;
                        game.launchType = confirmedGame.launchType;
                        game.urlVerified = true;
                        
                        const configIndex = setupGameConfigs.findIndex(g => g.gameId === game.gameId);
                        if (configIndex >= 0) {
                            setupGameConfigs[configIndex].launchUrl = confirmedGame.launchUrl;
                            setupGameConfigs[configIndex].platform = confirmedGame.platform;
                            setupGameConfigs[configIndex].launchType = confirmedGame.launchType;
                            setupGameConfigs[configIndex].urlVerified = true;
                        }
                    }
                });
            }
            
            setupPendingPublisherConfirm = null;
            setupCurrentScreenshotIndex++;
            setupShowCurrentGameScreenshot();
        }
        
        function setupSkipCurrentGame() {
            setupCurrentScreenshotIndex++;
            setupShowCurrentGameScreenshot();
        }
        
        function setupGoToSharing() {
            setupSharingMethods.clear();
            setupSocialPlatforms.clear();
            document.querySelectorAll('#setup-sharing-methods .setup-sharing-option').forEach(o => o.classList.remove('selected'));
            document.querySelectorAll('#setup-social-grid .setup-social-btn').forEach(o => o.classList.remove('selected'));
            document.getElementById('setup-social-section').style.display = 'none';
            document.getElementById('setup-sharing-actions').style.display = 'none';
            document.getElementById('setup-sharing-skip').style.display = 'block';
            
            setupGoToScreen('setup-sharing');
        }
        
        function setupToggleSharing(method, el) {
            if (method === 'none') {
                setupSharingMethods.clear();
                setupSharingMethods.add('none');
                document.querySelectorAll('#setup-sharing-methods .setup-sharing-option').forEach(o => o.classList.remove('selected'));
                el.classList.add('selected');
                document.getElementById('setup-social-section').style.display = 'none';
            } else {
                setupSharingMethods.delete('none');
                document.querySelector('#setup-sharing-methods .setup-sharing-option:last-child').classList.remove('selected');
                
                if (setupSharingMethods.has(method)) {
                    setupSharingMethods.delete(method);
                    el.classList.remove('selected');
                } else {
                    setupSharingMethods.add(method);
                    el.classList.add('selected');
                }
                
                document.getElementById('setup-social-section').style.display = 
                    setupSharingMethods.size > 0 ? 'block' : 'none';
            }
            
            setupUpdateSharingActions();
        }
        
        function setupUpdateSharingActions() {
            const hasSelection = setupSharingMethods.size > 0;
            document.getElementById('setup-sharing-actions').style.display = hasSelection ? 'flex' : 'none';
            document.getElementById('setup-sharing-skip').style.display = hasSelection ? 'none' : 'block';
        }
        
        function setupToggleSocial(id, el) {
            el.classList.toggle('selected');
            if (el.classList.contains('selected')) setupSocialPlatforms.add(id);
            else setupSocialPlatforms.delete(id);
        }
        
        function setupSkipSharing() {
            setupFinish();
        }
        
        function setupFinish() {
            const config = {
                games: setupGameConfigs,
                publisherConfig: setupPublisherConfig,
                sharing: {
                    methods: [...setupSharingMethods],
                    platforms: [...setupSocialPlatforms]
                },
                launchFeedback: setupLaunchFeedbackData,
                setupDate: new Date().toISOString()
            };
            
            localStorage.setItem('gameshelf_config', JSON.stringify(config));
            localStorage.setItem('gameshelf_games', JSON.stringify(setupGameConfigs));
            localStorage.setItem('gameshelf_setup_complete', 'true');
            
            // Update PWA appData with new games
            appData.games = setupGameConfigs.map(g => ({ id: g.gameId, addedAt: new Date().toISOString() }));
            saveData();
            
            document.getElementById('setup-complete-summary').textContent = 
                `${setupGameConfigs.length} game${setupGameConfigs.length !== 1 ? 's' : ''} ready to track`;
            
            document.getElementById('setup-final-games-list').innerHTML = setupGameConfigs.map(g => `
                <div class="setup-final-game">
                    <span class="icon">${g.icon}</span>
                    <div class="info">
                        <div class="name">${g.name}</div>
                        <div class="meta">
                            ${g.platform === 'app' ? 'ðŸ“±' : 'ðŸŒ'} ${g.launchType === 'hub' ? 'Hub' : 'Direct'}
                            ${g.urlVerified ? 'âœ“' : ''}
                            ${g.stats.streak ? `Â· ðŸ”¥ ${g.stats.streak}` : ''}
                        </div>
                    </div>
                    <span class="launch" onclick="window.open('${g.launchUrl}', '_blank')">ðŸš€</span>
                </div>
            `).join('');
            
            setupGoToScreen('setup-complete');
            console.log('Setup complete:', config);
        }
        
        function setupOpenGameShelf() {
            document.getElementById('setup-container').classList.remove('active');
            renderAll();
            showToast(`${setupGameConfigs.length} games configured! ðŸŽ®`);
            
            // Show install banner after setup completes (with delay for UI to settle)
            setTimeout(showInstallBanner, 2000);
        }
        
        function setupOpenGameShelfWithTutorial() {
            document.getElementById('setup-container').classList.remove('active');
            renderAll();
            // Start tutorial after a brief delay to let UI settle
            setTimeout(() => {
                startTutorial();
            }, 500);
            // Note: Install banner will show when tutorial finishes (in finishTutorial)
        }
        
        // ============ TUTORIAL SYSTEM ============
        let tutorialCurrentStep = 0;
        let tutorialSteps = [];
        
        const TUTORIAL_STEPS = [
            {
                id: 'home-games',
                title: 'ðŸ  Your Games',
                content: 'This is your <strong>Home screen</strong>. It shows all the games you\'re tracking today. Tap any game card to launch it directly.',
                target: '#home-games-grid',
                position: 'bottom',
                tip: 'ðŸ’¡ Games you haven\'t played yet show a play button'
            },
            {
                id: 'progress',
                title: 'ðŸ“Š Daily Progress',
                content: 'Track your <strong>daily goal</strong> and current <strong>streak</strong>. The progress bar fills as you complete games.',
                target: '.progress-section',
                position: 'bottom',
                tip: 'ðŸ”¥ Keep your streak alive by playing at least one game each day'
            },
            {
                id: 'log-button',
                title: 'ðŸ“‹ Log Your Results',
                content: 'After playing a game, tap this button to <strong>log your result</strong>. You can paste share text or enter scores manually.',
                target: '.big-log-button',
                position: 'top',
                tip: 'ðŸ’¡ Pro tip: Copy your share text before returning - we\'ll detect it automatically!'
            },
            {
                id: 'share-fab',
                title: 'ðŸ“¤ Quick Share Button',
                content: 'This floating button shows how many games you\'ve <strong>logged today</strong>. Tap it to instantly share all your results!',
                target: '#share-fab',
                position: 'left',
                action: () => {
                    switchTab('home');
                    // Ensure FAB is visible for tutorial
                    const fab = document.getElementById('share-fab');
                    if (fab) fab.classList.add('visible');
                },
                tip: 'ðŸ’¡ The badge shows your logged game count'
            },
            {
                id: 'hint-fab',
                title: 'ðŸ’¡ AI Hint Helper',
                content: 'Stuck on a puzzle? Tap the <strong>hint button</strong> for AI-powered help! Choose from 10 hint levels - from subtle nudges to full answers.',
                target: '#hint-fab',
                position: 'left',
                action: () => {
                    switchTab('home');
                },
                tip: 'ðŸŽ¯ Works with NYT Games, LinkedIn Games, and GS Originals - sign in to use hints'
            },
            {
                id: 'nav-games',
                title: 'ðŸ§© Games Tab',
                content: 'The <strong>Games tab</strong> shows your full game shelf. Browse all 36+ supported games and add new ones to track.',
                target: '[data-tab="games"]',
                position: 'top',
                action: () => switchTab('games')
            },
            {
                id: 'games-browse',
                title: 'ðŸ“š Browse Games',
                content: 'Explore games by category: <strong>NYT Games, LinkedIn Games, Word Games</strong>, and more. Tap a category to expand it.',
                target: '#browse-categories',
                position: 'bottom',
                tip: 'ðŸ’¡ Tap "+ Add" to add a game to your shelf'
            },
            {
                id: 'nav-social',
                title: 'âš”ï¸ Battles Tab',
                content: 'Connect with <strong>friends</strong> and compete in <strong>battles</strong>! See who can rack up the highest scores.',
                target: '[data-tab="social"]',
                position: 'top',
                action: () => switchTab('social')
            },
            {
                id: 'social-overview',
                title: 'ðŸ† Friends & Battles',
                content: 'Add friends, see their <strong>activity</strong>, and create <strong>battles</strong> to compete over multiple days!',
                target: '#social-tabs-container',
                position: 'bottom',
                tip: 'âš”ï¸ Battles track scores across days - challenge your friends!'
            },
            {
                id: 'nav-share',
                title: 'ðŸ“¢ Share Tab',
                content: 'Share your daily results with friends! Create <strong>custom messages</strong> or <strong>image cards</strong> for social media.',
                target: '[data-tab="share"]',
                position: 'top',
                action: () => switchTab('share')
            },
            {
                id: 'share-hub',
                title: 'ðŸŽ¨ Share Hub',
                content: 'Compose messages, pick platforms, and share! You can also create <strong>weekly recaps</strong> to show your progress.',
                target: '.share-hub-header',
                position: 'bottom',
                tip: 'ðŸ“¸ Download image cards to post on Instagram or Twitter'
            },
            {
                id: 'menu-button',
                title: 'â˜° Menu & Settings',
                content: 'Access your <strong>account</strong>, <strong>achievements</strong>, <strong>rewards shop</strong>, and settings here.',
                target: '.menu-btn',
                position: 'bottom',
                action: () => switchTab('home'),
                tip: 'ðŸŽ Invite friends to earn bonus tokens!'
            }
        ];
        
        function startTutorial() {
            tutorialCurrentStep = 0;
            const overlay = document.getElementById('tutorial-overlay');
            const welcome = document.getElementById('tutorial-welcome');
            const card = document.getElementById('tutorial-card');
            const spotlight = document.getElementById('tutorial-spotlight');
            
            // Show overlay and welcome screen, hide spotlight and card
            overlay.classList.add('active');
            welcome.style.display = 'block';
            card.style.display = 'none';
            spotlight.style.display = 'none';
            
            // Make sure we're on home tab
            switchTab('home');
        }
        
        function skipTutorial() {
            const overlay = document.getElementById('tutorial-overlay');
            overlay.classList.remove('active');
            showToast('Tutorial skipped. Access anytime from Menu â†’ Help & About', 'info');
            
            // Show install banner after skipping tutorial
            setTimeout(showInstallBanner, 1500);
        }
        
        function startTutorialSteps() {
            const welcome = document.getElementById('tutorial-welcome');
            const card = document.getElementById('tutorial-card');
            const spotlight = document.getElementById('tutorial-spotlight');
            
            // Hide welcome, show spotlight and card
            welcome.style.display = 'none';
            spotlight.style.display = 'block';
            card.style.display = 'block';
            
            // Initialize spotlight to center of screen as fallback
            spotlight.style.left = '50%';
            spotlight.style.top = '50%';
            spotlight.style.width = '100px';
            spotlight.style.height = '100px';
            spotlight.style.transform = 'translate(-50%, -50%)';
            
            tutorialCurrentStep = 0;
            showTutorialStep(0);
        }
        
        function showTutorialStep(stepIndex) {
            if (stepIndex < 0 || stepIndex >= TUTORIAL_STEPS.length) {
                finishTutorial();
                return;
            }
            
            tutorialCurrentStep = stepIndex;
            const step = TUTORIAL_STEPS[stepIndex];
            
            // Execute action if present (e.g., switch tabs)
            if (step.action) {
                step.action();
                // Give UI more time to update after navigation
                setTimeout(() => positionTutorialElements(step, stepIndex), 300);
            } else {
                positionTutorialElements(step, stepIndex);
            }
        }
        
        function positionTutorialElements(step, stepIndex) {
            const spotlight = document.getElementById('tutorial-spotlight');
            const card = document.getElementById('tutorial-card');
            const arrow = document.getElementById('tutorial-arrow');
            const title = document.getElementById('tutorial-title');
            const content = document.getElementById('tutorial-content');
            const indicator = document.getElementById('tutorial-step-indicator');
            const backBtn = document.getElementById('tutorial-back-btn');
            const nextBtn = document.getElementById('tutorial-next-btn');
            
            // Find target element
            const target = document.querySelector(step.target);
            if (!target) {
                console.warn('Tutorial target not found:', step.target);
                tutorialNext();
                return;
            }
            
            // Get target position
            const rect = target.getBoundingClientRect();
            const padding = 8;
            
            // Position spotlight
            spotlight.style.transform = 'none'; // Clear any initial centering
            spotlight.style.left = (rect.left - padding) + 'px';
            spotlight.style.top = (rect.top - padding) + 'px';
            spotlight.style.width = (rect.width + padding * 2) + 'px';
            spotlight.style.height = (rect.height + padding * 2) + 'px';
            
            // Build step indicators
            let indicatorHtml = '';
            for (let i = 0; i < TUTORIAL_STEPS.length; i++) {
                const dotClass = i < stepIndex ? 'complete' : (i === stepIndex ? 'active' : '');
                indicatorHtml += `<div class="tutorial-step-dot ${dotClass}"></div>`;
            }
            indicator.innerHTML = indicatorHtml;
            
            // Set content
            title.innerHTML = `<span class="icon">${step.title.split(' ')[0]}</span> ${step.title.split(' ').slice(1).join(' ')}`;
            
            let contentHtml = `<p>${step.content}</p>`;
            if (step.tip) {
                contentHtml += `<div class="tutorial-tip"><span class="tip-icon">ðŸ’¡</span><span>${step.tip.replace('ðŸ’¡ ', '').replace('ðŸ”¥ ', '').replace('âš”ï¸ ', '').replace('ðŸ“¸ ', '').replace('ðŸŽ ', '')}</span></div>`;
            }
            content.innerHTML = contentHtml;
            
            // Position card based on target position
            const cardWidth = 320;
            const cardHeight = card.offsetHeight || 200;
            let cardLeft, cardTop;
            
            // Reset arrow classes
            arrow.className = 'tutorial-card-arrow';
            
            if (step.position === 'bottom') {
                // Card below target
                cardTop = rect.bottom + 20;
                cardLeft = rect.left + rect.width / 2 - cardWidth / 2;
                arrow.classList.add('top');
            } else if (step.position === 'top') {
                // Card above target
                cardTop = rect.top - cardHeight - 30;
                cardLeft = rect.left + rect.width / 2 - cardWidth / 2;
                arrow.classList.add('bottom');
            } else if (step.position === 'left') {
                cardTop = rect.top + rect.height / 2 - cardHeight / 2;
                cardLeft = rect.left - cardWidth - 20;
                arrow.classList.add('right');
            } else {
                cardTop = rect.top + rect.height / 2 - cardHeight / 2;
                cardLeft = rect.right + 20;
                arrow.classList.add('left');
            }
            
            // Keep card on screen
            cardLeft = Math.max(16, Math.min(cardLeft, window.innerWidth - cardWidth - 16));
            cardTop = Math.max(16, Math.min(cardTop, window.innerHeight - cardHeight - 16));
            
            card.style.left = cardLeft + 'px';
            card.style.top = cardTop + 'px';
            
            // Update buttons
            backBtn.style.display = stepIndex === 0 ? 'none' : 'block';
            nextBtn.textContent = stepIndex === TUTORIAL_STEPS.length - 1 ? 'Finish âœ“' : 'Next â†’';
        }
        
        function tutorialNext() {
            if (tutorialCurrentStep < TUTORIAL_STEPS.length - 1) {
                showTutorialStep(tutorialCurrentStep + 1);
            } else {
                finishTutorial();
            }
        }
        
        function tutorialBack() {
            if (tutorialCurrentStep > 0) {
                showTutorialStep(tutorialCurrentStep - 1);
            }
        }
        
        function finishTutorial() {
            const overlay = document.getElementById('tutorial-overlay');
            overlay.classList.remove('active');
            
            // Return to home tab
            switchTab('home');
            
            // Mark tutorial as seen
            appData.settings = appData.settings || {};
            appData.settings.tutorialSeen = true;
            saveData();
            
            showToast('Tutorial complete! ðŸŽ‰ You\'re ready to go!', 'success');
            SoundManager.play('levelUp');
            
            // Show install banner after tutorial completes
            setTimeout(showInstallBanner, 1500);
        }
        
        // ============ INIT ============
        function init() {
            loadData();
            
            // v1.3.0: Validate streaks on startup (reset broken streaks)
            validateStreaksOnStartup();
            
            // Restore active game state from localStorage (survives app restarts)
            restoreActiveGameState();
            
            // Check if setup is complete - if not, show setup flow for new users
            if (!isSetupComplete()) {
                console.log('ðŸŽ® First time user - showing setup flow');
                startSetupFlow();
            } else {
                // Show activity summary for returning users (delayed to let UI load)
                setTimeout(showActivitySummary, 2000);
                
                // v1.3.2: Check for What's New after activity summary
                setTimeout(checkForWhatsNew, 2500);
            }
            
            renderAll();
            handleShareTarget();
            bindClipboardButtons();
            loadUserBattles();
            
            // Load sent nudges from localStorage
            loadSentNudges();
            
            // Sync any results from Game Shelf games
            syncGameShelfGames();
            
            // Load theme setting
            if (appData.settings?.theme) {
                setTheme(appData.settings.theme);
            }
            
            // Load sound setting (default to enabled)
            const soundToggle = document.getElementById('sound-toggle');
            if (soundToggle) {
                soundToggle.checked = appData.settings?.soundEnabled !== false;
            }
            
            // Load volume setting
            const volumeSlider = document.getElementById('sound-volume');
            if (volumeSlider) {
                volumeSlider.value = SoundManager.volume * 100;
            }
            
            // v1.2.77: Fix iOS sound - AudioContext must be resumed within a user gesture
            // Add one-time listener to ensure AudioContext is ready on first interaction
            const initAudioOnGesture = async () => {
                // Initialize if not already done
                if (!SoundManager.ctx) {
                    SoundManager.init();
                }
                // Resume if suspended
                if (SoundManager.ctx && SoundManager.ctx.state === 'suspended') {
                    try {
                        await SoundManager.ctx.resume();
                        console.log('ðŸ”Š AudioContext resumed on gesture, state:', SoundManager.ctx.state);
                    } catch (e) {
                        console.log('ðŸ”Š AudioContext resume on gesture failed:', e);
                    }
                }
                // Remove listeners after first interaction
                document.removeEventListener('touchstart', initAudioOnGesture);
                document.removeEventListener('click', initAudioOnGesture);
            };
            document.addEventListener('touchstart', initAudioOnGesture, { once: true });
            document.addEventListener('click', initAudioOnGesture, { once: true });
            
            // Load activity summary setting
            const summaryToggle = document.getElementById('activity-summary-toggle');
            if (summaryToggle) {
                summaryToggle.checked = appData.settings?.showActivitySummary !== false;
            }
            
            // Load auto-log setting (default to enabled)
            const autoLogToggle = document.getElementById('autolog-toggle');
            if (autoLogToggle) {
                autoLogToggle.checked = appData.settings?.autoLog !== false;
            }
            
            // Load test mode setting
            initTestModeToggle();
            
            // Load Feedback mode setting
            initHelpButton();
            
            // Check for referral code in URL
            checkReferralParam();
            
            // Check for battle join code in URL
            checkBattleParam();
            
            // Check for friend/profile link in URL
            checkFriendParam();
            
            // Check for purchase result in URL
            checkPurchaseResult();
            
            // Handle hash-based deep links (#log, #settings, #achievements, etc.)
            handleDeepLinks();
            
            // Check clipboard when app becomes visible + return-from-game detection
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') {
                    console.log('ðŸ“± App became visible');
                    
                    // Check if user returned from a game (for prompting on next game click)
                    setTimeout(checkReturnFromGame, 1500);
                    
                    // Check if we need to verify a first-time launch worked
                    setTimeout(checkLaunchVerification, 800);
                    
                    // Start clipboard++ monitoring (works better on non-iOS)
                    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                    if (!isIOS) {
                        startClipboardMonitor();
                    }
                    
                    // Also refresh auth state when app becomes visible
                    const user = auth.currentUser;
                    if (user !== currentUser) {
                        console.log('Visibility change auth sync:', user?.email);
                        currentUser = user;
                        updateAuthUI();
                    }
                } else {
                    console.log('ðŸ“± App going to background - capturing clipboard state');
                    // CRITICAL: Capture clipboard state BEFORE we leave
                    // This lets us detect if user copied something new while away
                    captureClipboardOnLeave();
                    
                    // Reset iOS gesture-deferred clipboard check flags
                    pendingClipboardCheck = false;
                    clipboardCheckCompletedThisReturn = false;
                    clipboardKnownThisSession = false; // Reset so we check clipboard on next return
                    
                    // Stop clipboard monitoring when app goes to background
                    stopClipboardMonitor();
                    // Hide tap-to-log when leaving
                    hideTapToLogCard();
                    // Also hide clipboard nudge
                    const nudge = document.getElementById('clipboard-nudge');
                    if (nudge) nudge.style.display = 'none';
                }
            });
            
            // Capture initial clipboard state as baseline for diff detection
            // This ensures we have something to compare against when user returns
            setTimeout(() => {
                console.log('ðŸ“‹ Init: Capturing initial clipboard state');
                captureClipboardOnLeave();
            }, 1500);
            
            // Also check if user already has a game result ready to log (copy-then-open flow)
            // This is separate from diff detection - it catches the case where user
            // copied a result BEFORE opening the app
            setTimeout(checkClipboardOnInit, 2000);
            
            // Start clipboard++ monitoring
            startClipboardMonitor();
            
            // Show install banner after delay (unless already installed or in setup)
            if (isSetupComplete()) {
                console.log('Setup complete - will show install banner in 1.5s');
                setTimeout(showInstallBanner, 1500);
            } else {
                console.log('Setup NOT complete - skipping install banner');
            }
            
            // Debug helper to reset install banner (call from console)
            window.resetInstallBanner = () => {
                localStorage.removeItem('installBannerDismissed');
                console.log('Install banner reset - refresh page to see it');
            };
            
            // Verify auth state after a short delay (gives Firebase time to restore session)
            setTimeout(() => {
                const user = auth.currentUser;
                console.log('Delayed auth check:', user?.email || 'not signed in');
                if (user && !currentUser) {
                    console.log('Auth state restored from Firebase');
                    currentUser = user;
                    updateAuthUI();
                    loadFromCloud().then(() => renderAll()).catch(e => {
                        console.error('Error loading from cloud on auth restore:', e);
                        renderAll(); // Render anyway with local data
                    });
                }
            }, 1000);
            
            console.log('ðŸ§© Game Shelf PWA v1.2.63 initialized - Test helpers enabled');
            console.log('Setup complete:', isSetupComplete());
            console.log('Standalone:', isStandalone(), 'iOS:', isIOS());
        }
        
        init();
    </script>
    
    <!-- FAQ Data -->
    <script id="faq-data" type="application/json">
{
  "version": "1.0",
  "appVersion": "1.3.4",
  "lastUpdated": "2026-01-29",
  "categories": [
    {
      "id": "getting-started",
      "name": "Getting Started",
      "icon": "ðŸš€",
      "order": 1,
      "questions": [
        {
          "id": "what-is-gs",
          "q": "What is Game Shelf?",
          "a": "Game Shelf is a **free app** that tracks all your daily puzzle games (Wordle, Connections, etc.) in one place. Instead of losing track of streaks or forgetting scores, Game Shelf keeps everything organized automatically.",
          "keywords": ["about", "purpose", "what", "intro", "explain"]
        },
        {
          "id": "how-to-start",
          "q": "How do I get started?",
          "a": "Three simple steps:\n\n1. **Add games** to your shelf from the Games tab\n2. **Play your games** normally\n3. **Record results** by copying share text and tapping Record Game\n\nThat's it! Game Shelf handles the rest.",
          "keywords": ["start", "begin", "setup", "first", "new"]
        },
        {
          "id": "is-free",
          "q": "Is Game Shelf free?",
          "a": "Yes! All core features are **completely free**: tracking, stats, streaks, friends, and battles. Optional coin purchases unlock premium rewards, but you never need to pay.",
          "keywords": ["free", "cost", "price", "pay", "money"]
        },
        {
          "id": "need-account",
          "q": "Do I need to create an account?",
          "a": "No account required for basic tracking. However, **signing in with Google** unlocks: sync across devices, friends, battles, AI hints, leaderboards, and automatic backup.",
          "keywords": ["account", "sign in", "login", "register", "google"]
        }
      ]
    },
    {
      "id": "recording",
      "name": "Recording Games",
      "icon": "ðŸ“‹",
      "order": 2,
      "questions": [
        {
          "id": "how-record",
          "q": "How do I record a game result?",
          "a": "After finishing a puzzle:\n\n1. Tap the game's **share button** to copy results\n2. Return to Game Shelf\n3. Tap **Record Game**\n\nGame Shelf reads your clipboard and logs automatically.",
          "keywords": ["record", "log", "save", "add", "paste", "clipboard"]
        },
        {
          "id": "manual-entry",
          "q": "What if automatic recording doesn't work?",
          "a": "**Long-press** (hold) the Record Game button to open manual entry. Select the game from the dropdown and enter your score manually.",
          "keywords": ["manual", "enter", "type", "hold", "long press", "doesnt work"]
        },
        {
          "id": "multiple-games",
          "q": "Can I record multiple games at once?",
          "a": "Yes! If you copy text containing **multiple game results** (like from a group chat), Game Shelf parses them all in one paste.",
          "keywords": ["multiple", "several", "many", "batch", "bulk"]
        },
        {
          "id": "wrong-score",
          "q": "What if I record the wrong score?",
          "a": "If you record the same game twice in one day, you'll be asked to **Keep** the original or **Replace** it with the new score.",
          "keywords": ["wrong", "mistake", "error", "fix", "change", "replace", "correct"]
        },
        {
          "id": "not-recognized",
          "q": "Why doesn't Game Shelf recognize my result?",
          "a": "Common reasons:\n\nâ€¢ **Game not supported** - check our games list\nâ€¢ **Modified share text** - use the original format\nâ€¢ **Extra text added** - paste only the game result\nâ€¢ **Clipboard empty** - copy the share text first",
          "keywords": ["recognize", "detect", "find", "work", "fail", "error", "cant"]
        },
        {
          "id": "supported-games",
          "q": "Which games are supported?",
          "a": "34+ games including: **Wordle**, **Connections**, **Strands**, Mini, Spelling Bee, Quordle, Queens, Tango, Worldle, Framed, and more. See Games tab â†’ Browse for the full list.",
          "keywords": ["supported", "games", "list", "which", "what games"]
        }
      ]
    },
    {
      "id": "streaks",
      "name": "Streaks & Stats",
      "icon": "ðŸ”¥",
      "order": 3,
      "questions": [
        {
          "id": "how-streaks-work",
          "q": "How do streaks work?",
          "a": "A **streak** counts consecutive days playing the same game. Miss a day = streak resets to 0. Each game has its own separate streak.",
          "keywords": ["streak", "consecutive", "days", "row"]
        },
        {
          "id": "streak-reset",
          "q": "Why did my streak reset?",
          "a": "Streaks reset if you **miss a day**. Playing at 11:59 PM still counts - it's based on calendar days in your local timezone, not 24-hour periods.",
          "keywords": ["reset", "lost", "gone", "zero", "disappeared"]
        },
        {
          "id": "streak-time",
          "q": "What time do streaks reset?",
          "a": "**Midnight in your local timezone.** Note: games themselves might reset at different times (Wordle resets midnight Eastern), but Game Shelf tracks YOUR play in YOUR timezone.",
          "keywords": ["time", "midnight", "reset", "timezone", "when"]
        },
        {
          "id": "view-stats",
          "q": "Where can I see my stats?",
          "a": "Multiple places:\n\nâ€¢ **Stats tab** - overview of all games\nâ€¢ **Game card** - shows streak and today's status\nâ€¢ **Long-press â†’ Stats** - detailed breakdown for one game",
          "keywords": ["stats", "statistics", "view", "see", "find", "where"]
        },
        {
          "id": "what-stats",
          "q": "What stats does Game Shelf track?",
          "a": "For each game: **games played**, **current streak**, **max streak**, **win rate**, **average score**, and complete play history.",
          "keywords": ["track", "measure", "data", "what stats", "information"]
        }
      ]
    },
    {
      "id": "hints",
      "name": "AI Hints",
      "icon": "ðŸ’¡",
      "order": 4,
      "questions": [
        {
          "id": "what-hints",
          "q": "What are AI hints?",
          "a": "Game Shelf can give you **AI-powered hints** for certain puzzles. Hints range from subtle nudges to direct answers - you control the level.",
          "keywords": ["hint", "ai", "help", "clue", "assist"]
        },
        {
          "id": "hint-games",
          "q": "Which games support hints?",
          "a": "**NYT Games**: Connections, Wordle, Strands, Spelling Bee, Mini\n**Game Shelf Originals**: Quotle, Rungs, Slate",
          "keywords": ["which", "games", "supported", "hint games"]
        },
        {
          "id": "hint-cost",
          "q": "How much do hints cost?",
          "a": "**5 tokens per hint.** You start with 50 free tokens and earn more through gameplay.",
          "keywords": ["cost", "price", "tokens", "how much", "expensive"]
        },
        {
          "id": "hint-levels",
          "q": "What are hint levels?",
          "a": "Ten levels from **Whisper** (barely helpful) to **Answer** (full solution):\n\n1-3: Vague nudges\n4-6: Clearer guidance\n7-9: Significant help\n10: Complete answer\n\nDefault is level 4 (Nudge).",
          "keywords": ["levels", "whisper", "nudge", "answer", "spoiler", "how much help"]
        },
        {
          "id": "cant-get-hints",
          "q": "Why can't I get hints?",
          "a": "You need:\n\nâ€¢ **Signed in** with Google\nâ€¢ At least **5 tokens**\nâ€¢ Under rate limits (20/hour, 50/day)\n\nCheck your token balance in the Wallet.",
          "keywords": ["cant", "unable", "not working", "error", "why"]
        }
      ]
    },
    {
      "id": "battles",
      "name": "Battles",
      "icon": "âš”ï¸",
      "order": 5,
      "questions": [
        {
          "id": "what-battles",
          "q": "What are battles?",
          "a": "**Brain Battles** are competitions between 2+ players over multiple days. Everyone plays the same games, and scores are compared. Winner takes the prize pool!",
          "keywords": ["battle", "competition", "compete", "versus", "challenge"]
        },
        {
          "id": "create-battle",
          "q": "How do I create a battle?",
          "a": "Hub tab â†’ Battles â†’ **Create Battle**\n\nChoose: name, games (1-8), duration (1-30 days), battle type, stakes, and visibility.",
          "keywords": ["create", "start", "make", "new battle", "host"]
        },
        {
          "id": "battle-types",
          "q": "What battle types are there?",
          "a": "Four types:\n\nâ€¢ **Total Score** - highest combined score wins\nâ€¢ **Most Wins** - each win = 1 point\nâ€¢ **Perfect Hunter** - only perfect scores count\nâ€¢ **Streak Challenge** - daily completion bonuses",
          "keywords": ["types", "modes", "scoring", "total", "wins", "perfect", "streak"]
        },
        {
          "id": "battle-stakes",
          "q": "What are stakes?",
          "a": "â€¢ **Friendly** - free, bragging rights only\nâ€¢ **Coins** - 1-5 coins entry, winner takes 80%\nâ€¢ **Tokens** - 1-500 tokens entry, winner takes 80%\n\nPublic battles are always friendly.",
          "keywords": ["stakes", "bet", "wager", "coins", "tokens", "prize"]
        },
        {
          "id": "join-battle",
          "q": "How do I join a battle?",
          "a": "Three ways:\n\nâ€¢ Enter the **6-character code**\nâ€¢ Click an **invite link**\nâ€¢ Browse **public battles** in Hub â†’ Battles",
          "keywords": ["join", "enter", "code", "invite", "link"]
        },
        {
          "id": "forgot-play",
          "q": "What if I forget to play a battle game?",
          "a": "Your Home screen shows a **reminder banner** for unplayed battle games. Missing games hurts your score but doesn't disqualify you.",
          "keywords": ["forget", "missed", "reminder", "notification"]
        }
      ]
    },
    {
      "id": "social",
      "name": "Friends & Social",
      "icon": "ðŸ‘¥",
      "order": 6,
      "questions": [
        {
          "id": "add-friends",
          "q": "How do I add friends?",
          "a": "Hub â†’ Friends â†’ **Add Friend**\n\nâ€¢ Enter their **8-character friend code**\nâ€¢ Share your **friend link**\nâ€¢ Use **Find Friends** to check contacts",
          "keywords": ["add", "friend", "connect", "invite"]
        },
        {
          "id": "friend-code",
          "q": "What's my friend code?",
          "a": "Find your unique **8-character code** in Hub â†’ Friends. Share it so others can add you!",
          "keywords": ["code", "my code", "friend code", "share"]
        },
        {
          "id": "friends-see",
          "q": "What can friends see?",
          "a": "Friends can see: your **profile**, **leaderboard rankings**, and **activity status** (played today or not). They can't see your full history or detailed stats.",
          "keywords": ["see", "view", "privacy", "visible", "private"]
        },
        {
          "id": "nudge",
          "q": "How do nudges work?",
          "a": "If a friend hasn't played today, tap their profile â†’ **Nudge to Play**. They'll see a notification next time they open Game Shelf.\n\nLimit: one nudge per friend per day.",
          "keywords": ["nudge", "remind", "poke", "notification"]
        },
        {
          "id": "leaderboard",
          "q": "How do leaderboards work?",
          "a": "Compare with friends by games played: **daily**, **weekly**, or **monthly** rankings. Access via Hub â†’ Friends â†’ Leaderboard.",
          "keywords": ["leaderboard", "ranking", "compare", "score"]
        }
      ]
    },
    {
      "id": "economy",
      "name": "Tokens & Coins",
      "icon": "ðŸ’°",
      "order": 7,
      "questions": [
        {
          "id": "tokens-vs-coins",
          "q": "What's the difference between tokens and coins?",
          "a": "**Tokens** = free currency, earned through play. Use for hints and token battles.\n\n**Coins** = purchased currency. Use for coin battles and rewards shop.",
          "keywords": ["tokens", "coins", "difference", "currency"]
        },
        {
          "id": "earn-tokens",
          "q": "How do I earn tokens?",
          "a": "â€¢ **New account**: 50 tokens\nâ€¢ **5+ games/day**: 5 tokens\nâ€¢ **5-day streak**: 10 tokens\nâ€¢ **All GS originals**: 5 tokens\nâ€¢ **Win battles**: from prize pool\nâ€¢ **Referrals**: 10-50 tokens",
          "keywords": ["earn", "get", "free", "tokens", "how"]
        },
        {
          "id": "buy-coins",
          "q": "How do I buy coins?",
          "a": "Hub â†’ Wallet â†’ **Buy Coins**. Select a package and complete purchase via Stripe. Coins never expire.",
          "keywords": ["buy", "purchase", "coins", "money"]
        },
        {
          "id": "check-balance",
          "q": "Where do I see my balance?",
          "a": "â€¢ **Home screen**: Wallet widget\nâ€¢ **Header**: Token count\nâ€¢ **Menu â†’ Wallet**: Full details and transaction history",
          "keywords": ["balance", "how many", "check", "wallet"]
        }
      ]
    },
    {
      "id": "account",
      "name": "Account & Sync",
      "icon": "â˜ï¸",
      "order": 8,
      "questions": [
        {
          "id": "why-sign-in",
          "q": "Why should I sign in?",
          "a": "Signing in enables: **sync across devices**, friends, battles, AI hints, leaderboards, and **automatic backup**. Without sign-in, data only exists on your current device.",
          "keywords": ["sign in", "login", "why", "benefit", "google"]
        },
        {
          "id": "how-sign-in",
          "q": "How do I sign in?",
          "a": "Menu â†’ Account â†’ **Sign in with Google**. Select your Google account and you're done! Data syncs automatically.",
          "keywords": ["sign in", "login", "how", "google"]
        },
        {
          "id": "switch-devices",
          "q": "Will I lose data if I switch devices?",
          "a": "**If signed in**: No - your data syncs automatically. Just sign in on the new device.\n\n**If not signed in**: Yes - data is device-only and can't be recovered.",
          "keywords": ["switch", "new device", "phone", "transfer", "lose"]
        },
        {
          "id": "delete-account",
          "q": "How do I delete my account?",
          "a": "Menu â†’ Account â†’ **Delete Account**. This permanently removes all data from our servers. This action cannot be undone.",
          "keywords": ["delete", "remove", "account", "data", "privacy"]
        }
      ]
    },
    {
      "id": "troubleshooting",
      "name": "Troubleshooting",
      "icon": "ðŸ”§",
      "order": 9,
      "questions": [
        {
          "id": "streak-not-updating",
          "q": "My streak didn't update!",
          "a": "Check that the game was actually recorded (see History). If it's there, the streak should be correct. If you played close to midnight, timezone differences might have affected which day it counted.",
          "keywords": ["streak", "update", "wrong", "not working", "didnt"]
        },
        {
          "id": "clipboard-ios",
          "q": "Clipboard paste isn't working (iOS)",
          "a": "iOS asks permission each time. When you see **\"Allow Paste?\"**, tap **Allow**. If denied, try again or use manual entry (long-press Record Game).",
          "keywords": ["clipboard", "paste", "ios", "iphone", "permission", "allow"]
        },
        {
          "id": "app-slow",
          "q": "The app is running slowly",
          "a": "Try:\n\nâ€¢ **Refresh** the page\nâ€¢ **Clear cache**: Settings â†’ Developer â†’ Clear Cache\nâ€¢ **Reinstall PWA**: Remove from home screen, re-add",
          "keywords": ["slow", "laggy", "performance", "freeze", "stuck"]
        },
        {
          "id": "data-disappeared",
          "q": "My data disappeared!",
          "a": "**If signed in**: Try signing out and back in.\n\n**If not signed in**: Local data can be lost when clearing browser data - unfortunately this can't be recovered. Always sign in for backup!",
          "keywords": ["data", "lost", "gone", "disappeared", "missing"]
        },
        {
          "id": "no-sound",
          "q": "Sound not working",
          "a": "Check:\n\nâ€¢ **Device not muted** (check mute switch/volume)\nâ€¢ **Sound enabled**: Settings â†’ Sound Effects\nâ€¢ **iOS**: Tap anywhere in app first to enable audio",
          "keywords": ["sound", "audio", "mute", "silent", "hear"]
        },
        {
          "id": "game-not-supported",
          "q": "A game I play isn't supported",
          "a": "Menu â†’ Help â†’ **Send Feedback** and let us know! Include the game name, URL, and sample share text. We add new games regularly.",
          "keywords": ["not supported", "add game", "request", "suggest", "new game"]
        }
      ]
    },
    {
      "id": "privacy",
      "name": "Privacy & Data",
      "icon": "ðŸ”’",
      "order": 10,
      "questions": [
        {
          "id": "what-data",
          "q": "What data does Game Shelf collect?",
          "a": "Your **puzzle results**, stats, and activity. If signed in, your Google profile info (name, email, photo) for identification. We don't track your browsing or access games directly.",
          "keywords": ["data", "collect", "privacy", "information", "track"]
        },
        {
          "id": "data-private",
          "q": "Is my data private?",
          "a": "Yes. Only you can see your full data. Friends only see what you share: leaderboard rankings and profile. You control your visibility.",
          "keywords": ["private", "secure", "safe", "who can see"]
        },
        {
          "id": "export-data",
          "q": "Can I export my data?",
          "a": "Yes! Menu â†’ Settings & Data â†’ **Export Data**. Download all your stats and history.",
          "keywords": ["export", "download", "backup", "copy"]
        }
      ]
    }
  ]
}
    </script>
</body>
</html>
